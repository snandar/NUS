
'use strict';

// Chrome 49: const и let отключают оптимизацию отдельных функций.
// Chrome 71: замена const на let не меняет производительность.
// Chrome 71: замена const и let на var понижает производительность на 1,5%.
// Firefox 63: замена const и let на var повышает производительность на 3%.
// Edge 18: замена const и let на var не меняет производительность.

var ЭТО_ПЛАНШЕТ = navigator.userAgent.includes('Android');
var ДЕЛАТЬ_ПЕРВЫЙ_КАДР_КЛЮЧЕВЫМ = false;

var СОСТОЯНИЕ_СМЕНА_ВАРИАНТА = 9;

function Проверить(пУсловие)
{
	if (!пУсловие)
	{
		throw new Error('Проверка не пройдена');
	}
}


// HACK Chrome 69-, Firefox, Edge: Эмулятор DataView примерно в 10 раз быстрее нативного:
// https://bugs.chromium.org/p/chromium/issues/detail?id=225811
// https://bugzilla.mozilla.org/show_bug.cgi?id=1065894
{
	var СоздатьDataView = мбБуфер => мбБуфер;

	Uint8Array.prototype.getUint8 = function(у)
	{
		у |= 0;
		return this[у];
	};

	Uint8Array.prototype.getInt16 = function(у)
	{
		у |= 0;
		return ((this[у] << 24) >> 16) | this[(у + 1)|0];
	};

	Uint8Array.prototype.getUint16 = function(у)
	{
		у |= 0;
		return (this[у] << 8) | this[(у + 1)|0];
	};

	Uint8Array.prototype.getInt32 = function(у)
	{
		у |= 0;
		return (this[у] << 24) | (this[(у + 1)|0] << 16) | (this[(у + 2)|0] << 8) | this[(у + 3)|0];
	};

	Uint8Array.prototype.getUint32 = function(у)
	{
		у |= 0;
		return ((this[у] << 24) | (this[(у + 1)|0] << 16) | (this[(у + 2)|0] << 8) | this[(у + 3)|0]) >>> 0;
	};

	Uint8Array.prototype.setInt8 = Uint8Array.prototype.setUint8 = function(у, чЗначение)
	{
		у |= 0;
		чЗначение |= 0;
		this[у] = чЗначение;
	};

	Uint8Array.prototype.setInt16 = Uint8Array.prototype.setUint16 = function(у, чЗначение)
	{
		у |= 0;
		чЗначение |= 0;
		this[у        ] = чЗначение >> 8;
		this[(у + 1)|0] = чЗначение;
	};

	Uint8Array.prototype.setInt32 = Uint8Array.prototype.setUint32 = function(у, чЗначение)
	{
		у |= 0;
		чЗначение |= 0;
		this[у        ] = чЗначение >> 24;
		this[(у + 1)|0] = чЗначение >> 16;
		this[(у + 2)|0] = чЗначение >> 8;
		this[(у + 3)|0] = чЗначение;
	};
}

Uint8Array.prototype.getUint64 = function(у)
{
	у |= 0;
	return (((this[у        ] << 24) | (this[(у + 1)|0] << 16) | (this[(у + 2)|0] << 8) | this[(у + 3)|0]) >>> 0) * 4294967296
	     + (((this[(у + 4)|0] << 24) | (this[(у + 5)|0] << 16) | (this[(у + 6)|0] << 8) | this[(у + 7)|0]) >>> 0);
};

Uint8Array.prototype.setInt64 = Uint8Array.prototype.setUint64 = function(у, чЗначение)
{
	у |= 0;
	var ч = Math.trunc(чЗначение);
	if (ч < Number.MIN_SAFE_INTEGER || ч > Number.MAX_SAFE_INTEGER)
	{
		throw new Error(чЗначение);
	}
	var ч32 = (ч / 4294967296)|0;
	this[у        ] = ч32 >> 24;
	this[(у + 1)|0] = ч32 >> 16;
	this[(у + 2)|0] = ч32 >> 8;
	this[(у + 3)|0] = ч32;
	ч32 = ч|0;
	this[(у + 4)|0] = ч32 >> 24;
	this[(у + 5)|0] = ч32 >> 16;
	this[(у + 6)|0] = ч32 >> 8;
	this[(у + 7)|0] = ч32;
};


class Wasm
{
	constructor()
	{
		this._оМодуль    = null;
		this._оПамять    = null;
		this._оЭкземпляр = null;
	}

	_РассчитатьРазмерКучи(кбРазмер)
	// Возвращает размер кучи в байтах.
	{
		return (Math.ceil(кбРазмер) + (Wasm.РАЗМЕР_СТРАНИЦЫ - 1)) & ~(Wasm.РАЗМЕР_СТРАНИЦЫ - 1);
	}

	Компилировать()
	{
		// WebAssembly.compileStreaming() не жрет локальный файл, ругаясь на MIME.
		// Да и не нужна эта функция для локального мелкого файла.
		return fetch('wasm.wasm')
		.then(оОтвет => оОтвет.arrayBuffer())
		.then(буфКод => WebAssembly.compile(буфКод))
		.then(оМодуль =>
		{
			this._оМодуль = оМодуль;
		});
	}

	ВыделитьПамять(кбРазмер)
	{
		кбРазмер = this._РассчитатьРазмерКучи(кбРазмер);
		if (this._оПамять === null)
		{
			this._оПамять = new WebAssembly.Memory({initial: кбРазмер / Wasm.РАЗМЕР_СТРАНИЦЫ});
			this._оЭкземпляр = new WebAssembly.Instance(this._оМодуль, {i: {m: this._оПамять}});
		}
		else
		{
			this._оПамять.grow((кбРазмер - this._оПамять.buffer.byteLength) / Wasm.РАЗМЕР_СТРАНИЦЫ);
		}
		return [this._оПамять.buffer, this._оЭкземпляр.exports];
	}

	ОсвободитьПамять()
	{
		this._оПамять    = null;
		this._оЭкземпляр = null;
	}

	static Доступен()
	{
		return !!self.WebAssembly;
	}
}

Wasm.РАЗМЕР_СТРАНИЦЫ = 65536;

class Asmjs
{
	_РассчитатьРазмерКучи(кбРазмер)
	// Возвращает размер кучи в байтах.
	{
		кбРазмер = Math.ceil(кбРазмер);
		if (кбРазмер <= Wasm.РАЗМЕР_СТРАНИЦЫ)
		{
			return Wasm.РАЗМЕР_СТРАНИЦЫ;
		}
		if (кбРазмер < (1 << 24))
		{
			return 1 << (32 - Math.clz32(кбРазмер - 1));
		}
		return (кбРазмер + 0x00ffffff) & 0xff000000;
	}

	Компилировать()
	{
		importScripts('asmjs.js');
		return Promise.resolve();
	}

	ВыделитьПамять(кбРазмер)
	{
		кбРазмер = this._РассчитатьРазмерКучи(кбРазмер);
		// HACK Firefox 63, 64: Создание ArrayBuffer ускоряет доступ к Uint8Array.
		// Хотя в этом примере все наоборот: https://bugzilla.mozilla.org/show_bug.cgi?id=1512491
		var буфКуча = new ArrayBuffer(кбРазмер);
		return [буфКуча, AsmjsModule(self, null, буфКуча)];
	}

	ОсвободитьПамять() {}
}

class ПотокБитов
{
	constructor(мбБуфер, уНачало, уКонец)
	{
		Проверить(Number.isInteger(уНачало) && Number.isInteger(уКонец) && уНачало >= 0 && уКонец <= мбБуфер.length && уКонец >= уНачало);
		this._мбБуфер = мбБуфер;
		this._уСледующийБайт = уНачало;
		this._чСледующийБит = 7;
		this.кБитОсталось = (уКонец - уНачало) * 8;
	}

	ПропуститьБиты(кБиты)
	{
		Проверить(Number.isInteger(кБиты));
		Проверить((this.кБитОсталось -= кБиты) >= 0);
		if (кБиты === 1)
		{
			if (--this._чСледующийБит < 0)
			{
				this._чСледующийБит = 7;
				++this._уСледующийБайт;
			}
		}
		else
		{
			var ч = this._чСледующийБит - кБиты;
			if (ч >= 0)
			{
				this._чСледующийБит = ч;
			}
			else
			{
				ч = -ч - 1;
				this._чСледующийБит = 7 - (ч & 7);
				this._уСледующийБайт += (ч >>> 3) + 1;
			}
		}
	}

	ПрочестьБиты(кБиты)
	{
		Проверить(Number.isInteger(кБиты));
		Проверить((this.кБитОсталось -= кБиты) >= 0);
		if (кБиты === 1)
		{
			чРезультат = (this._мбБуфер[this._уСледующийБайт] >>> this._чСледующийБит) & 1;
			if (--this._чСледующийБит < 0)
			{
				this._чСледующийБит = 7;
				++this._уСледующийБайт;
			}
		}
		else
		{
			Проверить(кБиты >= 1 && кБиты <= 32);
			var чРезультат = 0;
			var чСледующийБитРезультата = кБиты - 1;
			var чМаска = (1 << (this._чСледующийБит + 1)) - 1;
			do
			{
				var чБиты = this._мбБуфер[this._уСледующийБайт] & чМаска;
				чРезультат |= this._чСледующийБит < чСледующийБитРезультата
					? чБиты << (чСледующийБитРезультата - this._чСледующийБит)
					: чБиты >>> (this._чСледующийБит - чСледующийБитРезультата);
				var кБитДобавлено = Math.min(чСледующийБитРезультата, this._чСледующийБит) + 1;
				if ((this._чСледующийБит -= кБитДобавлено) < 0)
				{
					this._чСледующийБит = 7;
					++this._уСледующийБайт;
					чМаска = 0xFF;
				}
			}
			while ((чСледующийБитРезультата -= кБитДобавлено) >= 0);
		}
		return чРезультат >>> 0;
	}

	ПрочестьБеззнаковыйЭКГ()
	// Читает беззнаковый экспоненциальный код Голомба.
	// ITU-T H.264:2014 9.1 Parsing process for Exp-Golomb codes
	{
		for (var кНачальныеНули = 0; this.ПрочестьБиты(1) === 0; ++кНачальныеНули) {}
		Проверить(кНачальныеНули <= 31);
		return кНачальныеНули === 0 ? 0 : ((1 << кНачальныеНули) >>> 0) - 1 + this.ПрочестьБиты(кНачальныеНули);
	}

	ПрочестьЗнаковыйЭКГ()
	// Читает знаковый экспоненциальный код Голомба.
	// ITU-T H.264:2014 9.1.1 Mapping process for signed Exp-Golomb codes
	{
		var ч = this.ПрочестьБеззнаковыйЭКГ();
		return (ч & 1) !== 0 ? Math.ceil(ч / 2) : -(ч / 2);
	}

	ПропуститьЭКГ()
	// Пропускает беззнаковый и знаковый экспоненциальный код Голомба.
	{
		for (var кНачальныеНули = 0; this.ПрочестьБиты(1) === 0; ++кНачальныеНули) {}
		if (кНачальныеНули !== 0)
		{
			this.ПропуститьБиты(кНачальныеНули);
		}
	}
}


class IsoBaseMedia
// ISO 14496-12:2012
{
	constructor(мбБуфер, dvБуфер, уНачало)
	{
		Проверить(Number.isInteger(уНачало) && уНачало >= 0 && уНачало <= мбБуфер.length);
		this.мбБуфер = мбБуфер;
		this.dvБуфер = dvБуфер;
		this.уНачало = уНачало;
		this.уКонец  = уНачало;
	}

	Завершить()
	{
		Проверить(Number.isInteger(this.уКонец) && this.уКонец >= this.уНачало && this.уКонец <= this.мбБуфер.length);
		return this.мбБуфер.subarray(this.уНачало, this.уКонец);
	}

	AddFullBox(сТип, чВерсия, чФлаги, пСодержимое)
	// uint32_t РазмерЭтойСтруктурыИСодержимого
	// char     Тип[4]
	// uint32_t ВерсияИФлаги
	{
		Проверить(сТип.length === 4 && Number.isFinite(чВерсия) && Number.isFinite(чФлаги));

		Проверить(this.уКонец >= this.уНачало);
		var уНачало = this.уКонец;

		Проверить(this.мбБуфер.length - this.уКонец >= 8);
		this.мбБуфер[уНачало + 4] = сТип.charCodeAt(0);
		this.мбБуфер[уНачало + 5] = сТип.charCodeAt(1);
		this.мбБуфер[уНачало + 6] = сТип.charCodeAt(2);
		this.мбБуфер[уНачало + 7] = сТип.charCodeAt(3);
		this.уКонец += 8;
	
		if (чВерсия !== -1)
		{
			Проверить(чВерсия >= 0 && чВерсия <= 0xFF && чФлаги >= 0 && чФлаги <= 0xFFFFFF);
			Проверить(this.мбБуфер.length - this.уКонец >= 4);
			this.dvБуфер.setUint32(уНачало + 8, (чВерсия << 24) | чФлаги);
			this.уКонец += 4;
		}
	
		if (typeof пСодержимое === 'number')
		{
			// Размер содержимого в байтах.
			Проверить(Number.isInteger(пСодержимое) && пСодержимое >= 0);
			this.уКонец += пСодержимое;
			Проверить(this.уКонец <= this.мбБуфер.length);
		}
		else if (typeof пСодержимое === 'function')
		{
			// Функция заполняет содержимое и изменяет this.уКонец.
			var у = this.уКонец;
			пСодержимое();
			Проверить(Number.isInteger(this.уКонец) && this.уКонец >= у && this.уКонец <= this.мбБуфер.length);
		}
		else
		{
			// Заполнить содержимое из массива пСодержимое.
			this.КопироватьИзМассива(this.уКонец, пСодержимое);
		}

		this.dvБуфер.setUint32(уНачало, this.уКонец - уНачало);
	}

	AddBox(сТип, пСодержимое)
	{
		return this.AddFullBox(сТип, -1, -1, пСодержимое);
	}

	КопироватьИзМассива(уКуда, мчОткуда)
	{
		Проверить(Number.isInteger(уКуда) && уКуда >= this.уКонец);
		// set() кинет исключение при выходе за пределы массива.
		this.мбБуфер.set(мчОткуда, уКуда);
		this.уКонец = уКуда + мчОткуда.length;
	}

	КопироватьИзБуфера(уКуда, мбОткуда, уНачало, уКонец)
	{
		Проверить(Number.isInteger(уКуда) && уКуда >= this.уКонец);
		Проверить(мбОткуда.buffer !== this.мбБуфер.buffer); // В этом случае лучше copyWithin().
		if (arguments.length === 2)
		{
			this.мбБуфер.set(мбОткуда, уКуда);
			this.уКонец = уКуда + мбОткуда.length;
		}
		else
		{
			Проверить(Number.isInteger(уНачало) && Number.isInteger(уКонец) && мбОткуда.byteOffset === 0);
			this.мбБуфер.set(new Uint8Array(мбОткуда.buffer, уНачало, уКонец - уНачало), уКуда);
			this.уКонец = уКуда + уКонец - уНачало;
		}
	}
}

class ID3
// ID3 v2.4.0 http://id3.org/Developer%20Information
{
	constructor(мбБуфер, уНачало, уКонец)
	// Содержимое мбБуфер не меняется.
	{
		var РАЗМЕР_ЗАГОЛОВКА_ТЕГА = 10;
		var РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ = 10;

		Проверить(мбБуфер.BYTES_PER_ELEMENT === 1 && Number.isInteger(уНачало) && Number.isInteger(уКонец) && уНачало >= 0 && уНачало <= уКонец);

		this._мб           = мбБуфер;
		this._уНачалоТега  = -1;
		this._кбРазмерТега = -1;
		this._уНачалоПоля  = -1;
		this._кбРазмерПоля = -1;

		var кбРазмер = уКонец - уНачало;
		if (кбРазмер > РАЗМЕР_ЗАГОЛОВКА_ТЕГА + РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ
		&& this._мб[уНачало    ] === 0x49 // tag identifier[0] == 'I'
		&& this._мб[уНачало + 1] === 0x44 // tag identifier[1] == 'D'
		&& this._мб[уНачало + 2] === 0x33 // tag identifier[2] == '3'
		&& this._мб[уНачало + 3] === 4    // major version == 4
		&& this._мб[уНачало + 5] === 0    // unsynchronisation == extended header == experimental indicator == footer present == undefined flags == 0
		&& this._ParseSynchsafeInteger(уНачало + 6) === кбРазмер - РАЗМЕР_ЗАГОЛОВКА_ТЕГА) // tag size
		{
			this._уНачалоТега  = уНачало  + РАЗМЕР_ЗАГОЛОВКА_ТЕГА;
			this._кбРазмерТега = кбРазмер - РАЗМЕР_ЗАГОЛОВКА_ТЕГА;
		}
	}

	_ParseSynchsafeInteger(уАдрес)
	// Возвращает -1 если не удалось разобрать число.
	{
		var чРезультат = -1;
		var чБайт = this._мб[уАдрес];
		if (чБайт < 0x80)
		{
			var ч4Байта = чБайт << (24 - 3);
			чБайт = this._мб[уАдрес + 1];
			if (чБайт < 0x80)
			{
				ч4Байта |= чБайт << (16 - 2);
				чБайт = this._мб[уАдрес + 2];
				if (чБайт < 0x80)
				{
					ч4Байта |= чБайт << (8 - 1);
					чБайт = this._мб[уАдрес + 3];
					if (чБайт < 0x80)
					{
						чРезультат = ч4Байта | чБайт;
					}
				}
			}
		}
		return чРезультат;
	}

	_ПолучитьТекст()
	{
		if (this._кбРазмерПоля < 2 /* encoding description + 0x00 */ || this._мб[this._уНачалоПоля] !== 3 /* utf-8 */)
		{
			return null;
		}
		if (ID3._oUtf8Decoder === null)
		{
			ID3._oUtf8Decoder = new TextDecoder('utf-8', {fatal: true});
		}
		try
		{
			return ID3._oUtf8Decoder.decode(new Uint8Array(this._мб.buffer, this._мб.byteOffset + this._уНачалоПоля + 1, this._кбРазмерПоля - 1));
		}
		catch (_)
		{
			return null;
		}
	}

	*[Symbol.iterator]()
	// Возвращает идентификаторы всех полей тега.
	{
		var РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ = 10;

		var уТег  = this._уНачалоТега;
		var кбТег = this._кбРазмерТега;
		while (кбТег > РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ)
		{
			// frame identifier
			var чКод1 = this._мб[уТег    ];
			var чКод2 = this._мб[уТег + 1];
			var чКод3 = this._мб[уТег + 2];
			var чКод4 = this._мб[уТег + 3];
			if (((чКод1 < 0x30 || чКод1 > 0x39) && (чКод1 < 0x41 || чКод1 > 0x5A))
			||  ((чКод2 < 0x30 || чКод2 > 0x39) && (чКод2 < 0x41 || чКод2 > 0x5A))
			||  ((чКод3 < 0x30 || чКод3 > 0x39) && (чКод3 < 0x41 || чКод3 > 0x5A))
			||  ((чКод4 < 0x30 || чКод4 > 0x39) && (чКод4 < 0x41 || чКод4 > 0x5A)))
			{
				break;
			}
			// grouping identity, compression, encryption, unsynchronisation, data length indicator, undefined flags
			if (this._мб[уТег + 9] !== 0)
			{
				break;
			}
			// frame size
			var кбПоле = this._ParseSynchsafeInteger(уТег + 4);
			if (кбПоле < 1 || кбПоле > кбТег - РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ)
			{
				break;
			}
			this._уНачалоПоля  = уТег + РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ;
			this._кбРазмерПоля = кбПоле;
			уТег  += РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ + кбПоле;
			кбТег -= РАЗМЕР_ЗАГОЛОВКА_ПОЛЯ + кбПоле;
			yield String.fromCharCode(чКод1, чКод2, чКод3, чКод4);
		}
		this._уНачалоПоля  = -1;
		this._кбРазмерПоля = -1;
	}

	ПолучитьПервуюСтроку()
	{
		var сТекст = this._ПолучитьТекст();
		if (сТекст === null)
		{
			return null;
		}
		var чКонецСтроки = сТекст.indexOf('\0');
		if (чКонецСтроки === -1)
		{
			return null;
		}
		return сТекст.slice(0, чКонецСтроки);
	}

	РазобратьTXXX()
	{
		var сТекст = this._ПолучитьТекст();
		if (сТекст === null)
		{
			return null;
		}
		var чКонецСтроки = сТекст.indexOf('\0');
		if (чКонецСтроки === -1)
		{
			return null;
		}
		var сОписание = сТекст.slice(0, чКонецСтроки);
		var сЗначение = сТекст.slice(чКонецСтроки + 1);
		if (сЗначение.indexOf('\0') !== -1)
		{
			return null;
		}
		return {сОписание, сЗначение};
	}
}

ID3._oUtf8Decoder = null;

class Дорожка
{
	constructor(кбСтруктураСемпла)
	{
		Проверить(Number.isInteger(кбСтруктураСемпла) && кбСтруктураСемпла >= 0);
		this.уНачалоПамятиПотока = 0;
		this.уКонецПамятиПотока  = 0;
		this.уНачалоПотока       = 0;
		this.уКонецПотока        = 0;
		this.уКонецПамятиСемплов = 0;
		this.уНачалоСемплов      = 0;
		this.уКонецСемплов       = 0;
		this.кбСтруктураСемпла   = кбСтруктураСемпла;
		this.чВДНачала           = -1;
		this.nContinuityCounter  = -1;
		this.pPesPacketEnd       = -1;
	}

	Пусто()
	{
		// У метаданных нет семплов и ВД.
		return this.уКонецПотока === this.уНачалоПотока;
	}

	ПолучитьРазмерПотока()
	{
		Проверить(Number.isInteger(this.уНачалоПотока) && Number.isInteger(this.уКонецПотока) && this.уНачалоПотока >= 0 && this.уНачалоПотока <= this.уКонецПотока);
		Проверить(this.уНачалоПотока >= this.уНачалоПамятиПотока && this.уКонецПотока <= this.уКонецПамятиПотока);
		return this.уКонецПотока - this.уНачалоПотока;
	}

	ПолучитьРазмерСемплов()
	{
		Проверить(Number.isInteger(this.уНачалоСемплов) && Number.isInteger(this.уКонецСемплов) && this.уНачалоСемплов >= 0 && this.уНачалоСемплов <= this.уКонецСемплов);
		Проверить(this.уКонецСемплов <= this.уКонецПамятиСемплов);
		Проверить((this.уКонецСемплов - this.уНачалоСемплов) % this.кбСтруктураСемпла === 0);
		return this.уКонецСемплов - this.уНачалоСемплов;
	}

	ПолучитьКоличествоСемплов()
	{
		return this.ПолучитьРазмерСемплов() / this.кбСтруктураСемпла;
	}

	ПолучитьНомерСемпла(уСемпл)
	// Для журнала.
	{
		Проверить(Number.isInteger(this.уНачалоСемплов) && Number.isInteger(this.уКонецСемплов) && this.уНачалоСемплов >= 0 && this.уНачалоСемплов <= this.уКонецСемплов);
		Проверить(this.уКонецСемплов <= this.уКонецПамятиСемплов);
		Проверить(Number.isInteger(уСемпл));
		if (this.Пусто() || уСемпл < this.уНачалоСемплов)
		{
			return NaN;
		}
		Проверить(уСемпл <= this.уКонецСемплов - this.кбСтруктураСемпла);
		Проверить((уСемпл - this.уНачалоСемплов) % this.кбСтруктураСемпла === 0);
		return (уСемпл - this.уНачалоСемплов) / this.кбСтруктураСемпла;
	}
}

var м_Журнал = (() =>
{
	var _мсВажность = [];
	var _мсЗаписи   = [];

	function Добавить(сВажность, сЗапись)
	{
		_мсВажность.push(сВажность);
		_мсЗаписи.push(`[Worker] ${сЗапись}`);
	}

	function Вот(сЗапись)
	{
		Добавить('Вот', сЗапись);
	}

	function Окак(сЗапись)
	{
		Добавить('Окак', сЗапись);
	}

	function Ой(сЗапись)
	{
		Добавить('Ой', сЗапись);
	}

	function Отправить()
	{
		if (_мсВажность.length !== 0)
		{
			postMessage([2, _мсВажность, _мсЗаписи]);
			_мсВажность.length = 0;
			_мсЗаписи.length   = 0;
		}
	}

	return {Вот, Окак, Ой, Отправить};
})();

{
	var РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА   = 188;
	var TS_TIMESCALE                  = 90000;
	var ДЛИНА_АУДИОСЕМПЛА             = 1024;
	var ЧАСТОТА_ДИСКРЕТИЗАЦИИ         = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];

	var НОМЕР_ВИДЕО_ДОРОЖКИ           = 1;
	var НОМЕР_АУДИО_ДОРОЖКИ           = 2;

	var РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА  = 1 * 4; // sample_size
	var РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА  = 4 * 4;
	var ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА      = 0;     // sample_duration
	var РАЗМЕР_ВИДЕОСЕМПЛА            = 4;     // sample_size
	var ФЛАГИ_ВИДЕОСЕМПЛА             = 8;     // sample_flags
	var ВП_ВИДЕОСЕМПЛА                = 12;    // sample_composition_time_offset

	var _мНеобработанныеСообщения = [];
	var _оИсходныйСегмент   = null;

	var _мбКуча             = null;
	var _мцКуча             = null;
	var _dvКуча             = null;
	var _фНайтиПрефикс      = null;

	var _оАссемблер         = Wasm.Доступен() ? new Wasm() : new Asmjs();

	var _лРазрыв            = true;
	var _oPat               = null;
	var _oPmt               = null;
	var _дорВидео           = new Дорожка(РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА);
	var _дорАудио           = new Дорожка(РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА);
	var _дорМетаданные      = new Дорожка(0);
	var _муНачалоМетаданных = [];

	var _чВДПоследнегоВидеоСемпла;
	var _чВДКонцаВидеоСегмента;
	var _чВДКонцаАудиоСегмента;
	var _чДлительностьПервогоВидеоСемпла;

	var _чВДПоследнегоВидеоСемплаПредыдущегоВидеоСегмента;
	var _чВДКонцаПредыдущегоВидеоСегмента;
	var _чВДКонцаПредыдущегоАудиоСегмента;

	//
	// Параметры сжатия.
	//
	var _anDecoderSpecificInfo = [0, 0]; // AudioSpecificConfig, GASpecificConfig
	var _abSequenceParameterSet;
	var _abPictureParameterSet;
	var _abSequenceParameterSetExt;
	var _nProfileIndication;
	var _nConstraintSetFlag;
	var _nLevelIndication;
	var _nChromaFormatIndication;
	var _nBitDepthLumaMinus8;
	var _nBitDepthChromaMinus8;
	var _nMaxNumberReferenceFrames;
	var _чШиринаКартинки;
	var _чВысотаКартинки;
	var _чЧастотаКадров;
	var _чДиапазон;
	var _лЧересстрочное;
	var _nAudioObjectType;
	var _чЧастотаДискретизации;
	var _чКоличествоКаналов;

	//
	// Статистика сегмента. Очищается в ОчиститьСтатистику() перед разбором каждого сегмента.
	//
	var _чПреобразованЗа = NaN;
	var _лЗабраковано;
	var _лПотериВидео;
	var _лПотериЗвука;
	var _чМинДлительностьВидеоСемпла;
	var _чМаксДлительностьВидеоСемпла;
	var _чСредняяДлительностьВидеоСемпла;
	var _чБитрейтЗвука;
	var _чПозицияКодирования;
	var _чПозицияТрансляции;
	var _чВремяКодирования;

	function ОчиститьСтатистику()
	{
		_лЗабраковано                    = false;
		_лПотериВидео                    = false;
		_лПотериЗвука                    = false;
		_чМинДлительностьВидеоСемпла     = +Infinity;
		_чМаксДлительностьВидеоСемпла    = -Infinity;
		_чСредняяДлительностьВидеоСемпла = NaN;
		_чБитрейтЗвука                   = NaN;
		_чПозицияКодирования             = NaN;
		_чПозицияТрансляции              = NaN;
		_чВремяКодирования               = NaN;
	}

	function Браковать(пУсловие)
	{
		if (!пУсловие)
		{
			throw new Error('БРАКОВАТЬ');
		}
	}

	function Мс(чВремяТП, сЕдиницыИзмерения = 'мс')
	{
		return `${(чВремяТП / (TS_TIMESCALE / 1000)).toFixed(2)}${сЕдиницыИзмерения}`;
	}

	function ОтправитьРезультат(мбуфПередать)
	{
		postMessage([1, _оИсходныйСегмент], мбуфПередать);
	}

	function ЗавершитьРаботуИПоказатьСообщение(сКодСообщения)
	{
		postMessage([4, сКодСообщения]);
		throw undefined;
	}

	function ЗавершитьРаботуИОтправитьОтчет(пИсключение)
	{
		var сПричинаЗавершенияРаботы = пИсключение instanceof Error
			? `Поймано исключение в рабочем потоке: ${пИсключение}\n${пИсключение.stack}`
			: `Поймано исключение в рабочем потоке: [typeof ${typeof пИсключение}] ${пИсключение}\n${new Error().stack}`;
		// _оИсходныйСегмент.пДанные - это ArrayBuffer, который не был передан в postMessage()? У переданного (neutered) буфера byteLength == 0.
		if (typeof _оИсходныйСегмент === 'object' && _оИсходныйСегмент !== null
		&&  typeof _оИсходныйСегмент.пДанные === 'object' && _оИсходныйСегмент.пДанные !== null && _оИсходныйСегмент.пДанные.byteLength)
		{
			postMessage([3, сПричинаЗавершенияРаботы, _оИсходныйСегмент.пДанные], [_оИсходныйСегмент.пДанные]);
		}
		else
		{
			postMessage([3, сПричинаЗавершенияРаботы, null]);
		}
		_оИсходныйСегмент = null;
	}

	function ВыброситьВПомойку(мбБарахло)
	{
		if (ЭТО_ПЛАНШЕТ)
		{
			return;
		}
		if (мбБарахло && мбБарахло.buffer.byteLength)
		{
			Проверить(_мбКуча === null || _мбКуча.buffer !== мбБарахло.buffer);
			postMessage([5, мбБарахло.buffer], [мбБарахло.buffer]);
		}
	}

	var м_Память = (() =>
	{
		var МАКС_ДЛИТЕЛЬНОСТЬ_СЕГМЕНТА        = 30;
		var МАКС_ЧАСТОТА_КАДРОВ               = 150;
		// Попадалось 7. В реальности резерв нужен меньше, потому что не у всех nal units размер префикса
		// равен 3 байтам, и 6 байтов access unit delimiter отбрасываются. См. РазобратьВидеоПоток().
		var МАКС_КОЛИЧЕСТВО_NAL_UNITS_В_КАДРЕ = 10;
		// Уменьшить количество выделений кучи. Частое выделение больших блоков нагибает процессор и повышает фрагментацию памяти.
		var ЗАНАЧКА                           = 1.4;
		// Если все блоки памяти будут выравниваться, то удобнее выравнивать размер, а не адрес.
		var РАЗМЕР_КРАТЕН_БАЙТАМ              = 1 << 6; // 64
		var РАЗМЕР_ДАННЫХ_АССЕМБЛЕРА          = Выровнить(4); // _мцКуча[0]
		var РАЗМЕР_ПАМЯТИ_ВИДЕОСЕМПЛОВ        = Выровнить(РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА * МАКС_ЧАСТОТА_КАДРОВ * МАКС_ДЛИТЕЛЬНОСТЬ_СЕГМЕНТА);
		var РАЗМЕР_ПАМЯТИ_АУДИОСЕМПЛОВ        = Выровнить(РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА * ЧАСТОТА_ДИСКРЕТИЗАЦИИ[0] / ДЛИНА_АУДИОСЕМПЛА * МАКС_ДЛИТЕЛЬНОСТЬ_СЕГМЕНТА);
		var РАЗМЕР_ПАМЯТИ_МЕДИАПОТОКА         = Выровнить(10000);
		var РАЗМЕР_РЕЗЕРВА_ВИДЕОПОТОКА        = Выровнить(МАКС_КОЛИЧЕСТВО_NAL_UNITS_В_КАДРЕ * МАКС_ЧАСТОТА_КАДРОВ * МАКС_ДЛИТЕЛЬНОСТЬ_СЕГМЕНТА);

		function Выровнить(чАдресИлиРазмер)
		{
			return (Math.ceil(чАдресИлиРазмер) + (РАЗМЕР_КРАТЕН_БАЙТАМ - 1)) & ~(РАЗМЕР_КРАТЕН_БАЙТАМ - 1);
		}

		function Выделить(мбТранспортныйПоток)
		{
			var уВыделить = РАЗМЕР_ДАННЫХ_АССЕМБЛЕРА;

			_дорВидео.уНачалоСемплов = _дорВидео.уКонецСемплов = уВыделить;
			_дорВидео.уКонецПамятиСемплов = уВыделить += РАЗМЕР_ПАМЯТИ_ВИДЕОСЕМПЛОВ;

			_дорАудио.уНачалоСемплов = _дорАудио.уКонецСемплов = уВыделить;
			_дорАудио.уКонецПамятиСемплов = уВыделить += РАЗМЕР_ПАМЯТИ_АУДИОСЕМПЛОВ;

			_дорМетаданные.уНачалоПамятиПотока = _дорМетаданные.уНачалоПотока = _дорМетаданные.уКонецПотока = уВыделить;
			_дорМетаданные.уКонецПамятиПотока = уВыделить += РАЗМЕР_ПАМЯТИ_МЕДИАПОТОКА;

			_дорВидео.уНачалоПамятиПотока = уВыделить;
			_дорВидео.уНачалоПотока = _дорВидео.уКонецПотока = уВыделить += РАЗМЕР_РЕЗЕРВА_ВИДЕОПОТОКА;

			var кбПостоянныйРазмер = уВыделить;
			
			_дорВидео.уКонецПамятиПотока = уВыделить += Выровнить(мбТранспортныйПоток.length);

			_дорАудио.уНачалоПамятиПотока = _дорАудио.уНачалоПотока = _дорАудио.уКонецПотока = уВыделить;
			_дорАудио.уКонецПамятиПотока = уВыделить += Выровнить(мбТранспортныйПоток.length);

			var кбПеременныйРазмер = уВыделить - кбПостоянныйРазмер;

			if (_мбКуча === null || _мбКуча.length < уВыделить)
			{
				var [буфКуча, оЭкспорт] = _оАссемблер.ВыделитьПамять(кбПостоянныйРазмер + кбПеременныйРазмер * ЗАНАЧКА);
				м_Журнал[_мбКуча === null ? 'Вот' : 'Ой'](`Новый размер кучи ${буфКуча.byteLength} байт`);
				_мбКуча = new Uint8Array(буфКуча);
				_мцКуча = new Int32Array(буфКуча);
				_dvКуча = СоздатьDataView(_мбКуча);
				_фНайтиПрефикс = оЭкспорт.SearchStartCodePrefix;
			}
		}

		function Освободить()
		{
			// Не выбрасывать в помойку буфер, который asmjs использует в качестве кучи. В Firefox 49
			// это вызовет исключение out of memory. С wasm тоже скорее всего будут проблемы.
			_оАссемблер.ОсвободитьПамять();
			_мбКуча        = null;
			_мцКуча        = null;
			_dvКуча        = null;
			_фНайтиПрефикс = null;
		}

		return {Выделить, Освободить};
	})();

	function РазобратьТранспортныйПоток(мбТранспортныйПоток)
	// Возвращает false если сегмент не годится для воспроизведения.
	{
		Браковать(мбТранспортныйПоток.length !== 0 && мбТранспортныйПоток.length % РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА === 0);

		_дорВидео.чВДНачала = _дорАудио.чВДНачала = -1;
		// Не нужно извлекать из транспортного потока DTS и PTS.
		_дорМетаданные.чВДНачала = 0;
		// PES-пакет целиком находится в одном сегменте.
		_дорВидео.pPesPacketEnd = _дорАудио.pPesPacketEnd = _дорМетаданные.pPesPacketEnd = -1;
		_муНачалоМетаданных.length = 0;
		_чВДПоследнегоВидеоСемпла = -1;

		if (_лРазрыв)
		{
			_дорВидео.nContinuityCounter = _дорАудио.nContinuityCounter = _дорМетаданные.nContinuityCounter = -1;
			_oPat = _oPmt = null;
		}

		var nPmtPid = -1, nVideoPid = -1, nAudioPid = -1, nMetadataPid = -1;
		var cPat = 0, cPmt = 0, кИзмененийВД = 0; // Статистика.

		// Большую часть времени эта функция копирует большое количество (несколько тысяч) блоков небольшого
		// (меньше РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА) размера. Копируем транспортный поток в кучу, чтобы вызывать
		// быстрый copyWithin() вместо долгого создания Uint8Array.
		// Не копировать в _дорАудио. Медиаданные звука не заполняют отведенное для них место полностью
		// и это экономит немного физической памяти, по крайней мере в Firefox.
		var уТранспортныйПакет = _дорВидео.уНачалоПотока|0; // Chrome 49
		_мбКуча.set(мбТранспортныйПоток, уТранспортныйПакет);

		for (var уКонецТранспортногоПотока = уТранспортныйПакет + мбТранспортныйПоток.length;
			уТранспортныйПакет !== уКонецТранспортногоПотока;
			уТранспортныйПакет += РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА)
		{
			var чЗаголовокТранспортногоПакета = _dvКуча.getUint32(уТранспортныйПакет)|0; // Chrome 49
			Браковать((чЗаголовокТранспортногоПакета & 0xFF8000C0) === 0x47000000); // sync_byte == 0x47, transport_error_indicator == 0, transport_scrambling_control == 0
			var nPid = (чЗаголовокТранспортногоПакета & 0x001FFF00) >> 8; // pid
			var pPayload = уТранспортныйПакет + 4;

			if ((чЗаголовокТранспортногоПакета & 0x00000020) !== 0) // adaptation_field
			{
				var cbAdaptationField = _мбКуча[pPayload]; // adaptation_field_length
				Проверить(cbAdaptationField <= РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА - 5);
				Проверить(cbAdaptationField === 0 || (_мбКуча[pPayload + 1] & 0x80) === 0); // discontinuity_indicator
				pPayload += 1 + cbAdaptationField;
			}

			var дорОбработать;
			switch (nPid)
			{
			case nVideoPid:
				if ((чЗаголовокТранспортногоПакета & 0x00400000) !== 0) // payload_unit_start_indicator
				{
					Проверить((_dvКуча.getUint32(pPayload) & 0xFFFFFFF0) === 0x000001E0); // packet_start_code_prefix, stream_id == video
				}
				дорОбработать = _дорВидео;
				break;

			case nAudioPid:
				if ((чЗаголовокТранспортногоПакета & 0x00400000) !== 0) // payload_unit_start_indicator
				{
					Проверить((_dvКуча.getUint32(pPayload) & 0xFFFFFFE0) === 0x000001C0); // packet_start_code_prefix, stream_id == audio
				}
				дорОбработать = _дорАудио;
				break;

			case nMetadataPid:
				if ((чЗаголовокТранспортногоПакета & 0x00400000) !== 0) // payload_unit_start_indicator
				{
					Проверить(_dvКуча.getUint32(pPayload) === 0x000001BD); // packet_start_code_prefix, stream_id == private_stream_1
					// Метаданные с размером > 64 KiB не поддерживаются.
					Проверить((_мбКуча[pPayload + 6] & 0x04) !== 0); // data_alignment_indicator
					Проверить((_мбКуча[pPayload + 7] & 0xC0) === 0x80); // pts_dts_flags == pts
					_муНачалоМетаданных.push(_дорМетаданные.уКонецПотока);
				}
				дорОбработать = _дорМетаданные;
				break;

			case 0:
				Проверить((чЗаголовокТранспортногоПакета & 0x00400010) === 0x00400010); // payload_unit_start_indicator | payload
				var oPat = new ProgramAssociationTable(pPayload, уТранспортныйПакет + РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА);
				if (_oPat === null)
				{
					_oPat = oPat;
					м_Журнал.Вот(`PatVersion=${oPat.nPatVersion} ProgramNumber=${oPat.nProgramNumber} PmtPid=${oPat.nPmtPid}`);
				}
				else
				{
					// TODO Разбирать только первую таблицу в сегменте, а у остальных проверять версию?
					Проверить(_oPat.nPatVersion === oPat.nPatVersion && _oPat.nProgramNumber === oPat.nProgramNumber && _oPat.nPmtPid === oPat.nPmtPid);
				}
				nPmtPid = oPat.nPmtPid;
				++cPat;
				continue;

			case nPmtPid:
				Проверить((чЗаголовокТранспортногоПакета & 0x00400010) === 0x00400010); // payload_unit_start_indicator | payload
				var oPmt = new ProgramMapTable(pPayload, уТранспортныйПакет + РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА, _oPat.nProgramNumber);
				if (_oPmt === null)
				{
					_oPmt = oPmt;
					м_Журнал.Вот(`PmtVersion=${oPmt.nPmtVersion} VideoPid=${oPmt.nVideoPid} AudioPid=${oPmt.nAudioPid} MetadataPid=${oPmt.nMetadataPid}`);
				}
				else
				{
					// TODO Разбирать только первую таблицу в сегменте, а у остальных проверять версию?
					Проверить(_oPmt.nPmtVersion === oPmt.nPmtVersion && _oPmt.nVideoPid === oPmt.nVideoPid && _oPmt.nAudioPid === oPmt.nAudioPid && _oPmt.nMetadataPid === oPmt.nMetadataPid);
				}
				({nVideoPid, nAudioPid, nMetadataPid} = oPmt);
				++cPmt;
				continue;

			default:
				// Таких пакетов очень мало.
				continue;
			}

			if (дорОбработать.nContinuityCounter !== (чЗаголовокТранспортногоПакета & 0x0000000F) && дорОбработать.nContinuityCounter !== -1) // continuity_counter
			{
				м_Журнал.Ой(`continuity_counter равен ${чЗаголовокТранспортногоПакета & 0x0000000F} вместо ${дорОбработать.nContinuityCounter} PID=${nPid}`);
				// Первый транспортный пакет с этим PID в сегменте?
				// TODO Добавлять разрыв если пакет первый? Браковать сегмент в остальных случаях.
				// TODO По стандарту возможна одна копия пакета с тем же continuity_counter.
				// TODO Перенести сюда проверку discontinuity_indicator.
				Проверить(дорОбработать.уКонецПотока === дорОбработать.уНачалоПотока);
			}
			дорОбработать.nContinuityCounter = (чЗаголовокТранспортногоПакета + 1) & 0x0000000F;

			switch (чЗаголовокТранспортногоПакета & 0x00400010)
			{
			case 0x00000010: // payload
				// PES-пакет должен целиком находится в одном сегменте. Проверка учитывает, что "внутри"
				// PES-пакета могут находится транспортные пакеты с другим PID, например PAT и PMT.
				Проверить(дорОбработать.уКонецПотока !== дорОбработать.уНачалоПотока);
				break;

			case 0x00400010: // payload_unit_start_indicator | payload
				var cbPesPacket = _dvКуча.getUint16(pPayload + 4); // pes_packet_length
				var cbPesHeader = _мбКуча[pPayload + 8]; // pes_header_data_length

				// Проверка длины последнего PES-пакета находится сразу после цикла ниже по тексту.
				Проверить(дорОбработать.pPesPacketEnd === дорОбработать.уКонецПотока || дорОбработать.pPesPacketEnd === -1);
				if (cbPesPacket !== 0)
				{
					дорОбработать.pPesPacketEnd = дорОбработать.уКонецПотока + cbPesPacket - 3 - cbPesHeader;
				}
				else
				{
					// ITU-T H.222.0:2012 2.4.3.7 Semantic definition of fields in PES packet:
					// A value of 0 indicates that the PES packet length is neither specified nor bounded and is allowed only in PES
					// packets whose payload consists of bytes from a video elementary stream contained in transport stream packets.
					Проверить(nPid === nVideoPid);
					дорОбработать.pPesPacketEnd = -1;
				}

				if (nPid === nVideoPid || дорОбработать.чВДНачала === -1)
				{
					var nPts, nDts;
					switch (_dvКуча.getUint16(pPayload + 6) & 0xF0C0)
					{
					case 0x8080: // marker bits == 2, pes_scrambling_control == 0, pts_dts_flags == pts
						Проверить(cbPesHeader >= 5);
						nPts = DecodeTimestamp(pPayload + 9, 0x21);
						nDts = nPts;
						break;
					case 0x80C0: // marker bits == 2, pes_scrambling_control == 0, pts_dts_flags == pts + dts
						Проверить(cbPesHeader >= 10);
						nPts = DecodeTimestamp(pPayload + 9, 0x31);
						nDts = DecodeTimestamp(pPayload + 14, 0x11);
						break;
					default:
						Проверить(false);
					}
					if (дорОбработать.чВДНачала === -1)
					{
						дорОбработать.чВДНачала = nDts;
					}
					if (nPid === nVideoPid)
					{
						// Если DTS не изменился, то это продолжение предыдущего PES-пакета.
						// Так делают когда размер не умещается в 16 бит pes_packet_length.
						if (nDts === _чВДПоследнегоВидеоСемпла && cbPesPacket !== 0)
						{
							Проверить((_мбКуча[pPayload + 6] & 0x04) === 0); // data_alignment_indicator
						}
						else
						{
							// Начало видеосемпла.
							Проверить(_дорВидео.уКонецСемплов <= _дорВидео.уКонецПамятиСемплов - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА);
							if (_чВДПоследнегоВидеоСемпла !== -1)
							{
								var чДлительностьВидеоСемпла = nDts - _чВДПоследнегоВидеоСемпла;
								// Иногда по ошибке DTS разных семплов равны. Стандарт запрещает нулевую длительность семплов и наличие нескольких
								// access unit в одном семпле. В последнем случае Chrome 63 без аппаратного декодирования показывает артефакты (видимо
								// декодируется только последний access unit). Теоретически могут возникнуть проблемы, если в одном семпле объединены
								// ключевые и обычные кадры. Решение простое: добавить 1 к DTS.
								if (чДлительностьВидеоСемпла <= 0)
								{
									if (чДлительностьВидеоСемпла > -10)
									{
										чДлительностьВидеоСемпла = 1;
										nDts = _чВДПоследнегоВидеоСемпла + чДлительностьВидеоСемпла;
										++кИзмененийВД;
									}
									else
									{
										// а) Время трансляции превысило 33 бита.
										// б) Twitch: Большие потери при приеме потока сервером привели к ошибке создания TS.
										Браковать(false);
									}
								}
								Проверить(чДлительностьВидеоСемпла < TS_TIMESCALE * 60);
								_чМинДлительностьВидеоСемпла  = Math.min(_чМинДлительностьВидеоСемпла,  чДлительностьВидеоСемпла);
								_чМаксДлительностьВидеоСемпла = Math.max(_чМаксДлительностьВидеоСемпла, чДлительностьВидеоСемпла);
								_dvКуча.setUint32(_дорВидео.уКонецСемплов + ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА, чДлительностьВидеоСемпла);
								// В РазобратьВидеоПоток() указатель будет заменен на размер.
								_dvКуча.setUint32(_дорВидео.уКонецСемплов + РАЗМЕР_ВИДЕОСЕМПЛА - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА, _дорВидео.уКонецПотока);
							}
							_dvКуча.setInt32(_дорВидео.уКонецСемплов + ВП_ВИДЕОСЕМПЛА, nPts - nDts);
							_дорВидео.уКонецСемплов += РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
							_чВДПоследнегоВидеоСемпла = nDts;
						}
					}
					else
					{
						// ITU-T H.222.0:2012 2.4.3.7 Semantic definition of fields in PES packet:
						// The presentation time shall be equal to the decoding time for audio access units.
						Проверить(nPts === nDts);
					}
				}
				pPayload += 9 + cbPesHeader;
				break;

			default:
				Проверить(false);
			}

			var cbPayload = уТранспортныйПакет + РАЗМЕР_ТРАНСПОРТНОГО_ПАКЕТА - pPayload;
			// Ошибка в adaptation_field_length или pes_header_data_length?
			Проверить(cbPayload > 0 && cbPayload + дорОбработать.уКонецПотока <= дорОбработать.уКонецПамятиПотока);
			_мбКуча.copyWithin(дорОбработать.уКонецПотока, pPayload, pPayload + cbPayload);
			дорОбработать.уКонецПотока += cbPayload;
		}

		Проверить(_дорВидео     .pPesPacketEnd === _дорВидео     .уКонецПотока || _дорВидео     .pPesPacketEnd === -1);
		Проверить(_дорАудио     .pPesPacketEnd === _дорАудио     .уКонецПотока || _дорАудио     .pPesPacketEnd === -1);
		Проверить(_дорМетаданные.pPesPacketEnd === _дорМетаданные.уКонецПотока || _дорМетаданные.pPesPacketEnd === -1);

		if (cPat !== 1 || cPmt !== 1)
		{
			м_Журнал.Ой(`Количество таблиц в сегменте: PAT=${cPat} PMT=${cPmt}`);
		}

		if (кИзмененийВД !== 0)
		{
			м_Журнал.Ой(`Количество видеосемплов с увеличенным ВД: ${кИзмененийВД}`);
		}

		// В сегменте должны быть PAT, PMT и видео или аудио дорожка.
		Проверить(nVideoPid !== -1 || nAudioPid !== -1);

		// Twitch: Бывают сегменты только с PAT, PMT и ID3.
		// Как минимум данные потока нужны для сегмента инициализации.
		_лПотериВидео = nVideoPid !== -1 && _дорВидео.Пусто();
		_лПотериЗвука = nAudioPid !== -1 && _дорАудио.Пусто();
		if (_лПотериВидео || _лПотериЗвука)
		{
			м_Журнал.Ой(`Сегмент не годится для воспроизведения: нет видео ${_лПотериВидео}, нет звука ${_лПотериЗвука}`);
			return false;
		}

		var сВажность = _муНачалоМетаданных.length > 1 ? 'Ой' : 'Вот';
		var сЗапись = `Метаданных=${_муНачалоМетаданных.length}`;
		if (!_дорВидео.Пусто())
		{
			// ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА будет заполнена в РассчитатьДлительностьПоследнегоВидеосемпла().
			_dvКуча.setUint32(_дорВидео.уКонецСемплов + РАЗМЕР_ВИДЕОСЕМПЛА - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА, _дорВидео.уКонецПотока);

			var кВидеосемплов = _дорВидео.ПолучитьКоличествоСемплов();
			// Средняя длительность на данный момент показывает желаемую частоту кадров, заданную во время кодирования,
			// без учета потерь кадров. Не учитывать изменение длительности первого семпла в СостыковатьСегменты() и
			// последнего семпла в РассчитатьДлительностьПоследнегоВидеосемпла(). Это увеличит точность и упростит код.
			_чСредняяДлительностьВидеоСемпла = (_чВДПоследнегоВидеоСемпла - _дорВидео.чВДНачала) / (кВидеосемплов - 1);

			if (кВидеосемплов < 25)
			{
				сВажность = 'Ой';
			}
			сЗапись += ` ВДПервВидСемпла=${(_дорВидео.чВДНачала / TS_TIMESCALE).toFixed(5)}`
				+ ` ВДПослВидСемпла=${(_чВДПоследнегоВидеоСемпла / TS_TIMESCALE).toFixed(5)}`
				+ ` ДлитВидСегмента>${Мс(_чВДПоследнегоВидеоСемпла - _дорВидео.чВДНачала)} ВидСемплов=${кВидеосемплов}`
				+ ` ДлитВидСемплов=${Мс(_чМинДлительностьВидеоСемпла, '')}<${Мс(_чСредняяДлительностьВидеоСемпла, '')}<${Мс(_чМаксДлительностьВидеоСемпла)}`
				+ `(${(TS_TIMESCALE /     _чМинДлительностьВидеоСемпла).toFixed(2)}`
				+ `<${(TS_TIMESCALE / _чСредняяДлительностьВидеоСемпла).toFixed(2)}`
				+ `<${(TS_TIMESCALE /    _чМаксДлительностьВидеоСемпла).toFixed(2)}к/с)`;
		}
		if (!_дорАудио.Пусто())
		{
			сЗапись += ` ВДПервАудСемпла=${(_дорАудио.чВДНачала / TS_TIMESCALE).toFixed(5)}`;
		}
		if (!_дорВидео.Пусто() && !_дорАудио.Пусто())
		{
			var чСмещениеЗвука = _дорАудио.чВДНачала - _дорВидео.чВДНачала;
			if (чСмещениеЗвука < -TS_TIMESCALE * 0.1 || чСмещениеЗвука > TS_TIMESCALE * 0.2)
			{
				сВажность = 'Ой';
			}
			сЗапись += ` СмещНачалаАудСегмента=${Мс(_дорАудио.чВДНачала - _дорВидео.чВДНачала)}`;
		}
		м_Журнал[сВажность](сЗапись);

		// Рассчитать до изменения чВДНачала в СостыковатьСегменты().
		_чПозицияКодирования = (_дорАудио.чВДНачала !== -1 ? _дорАудио.чВДНачала : _дорВидео.чВДНачала) / TS_TIMESCALE;
		return true;
	}

	function DecodeTimestamp(уАдрес, nMarkerBits)
	// Timestamp занимает 33 бита. Спасибо что не 54.
	{
		var ч1 = _мбКуча[уАдрес]|0;
		var ч2 = _dvКуча.getUint32(уАдрес + 1)|0;
		Проверить((ч1 & 0xF1) === (nMarkerBits|0) && (ч2 & 0x00010001) === 0x00010001);
		return +((ч1 & 0x0E) * (1 << 29) + (((ч2 >> 2) & 0x3FFF8000) | ((ч2 >> 1) & 0x00007FFF)));
	}

	function ProgramAssociationTable(уНачало, уКонец)
	// ITU-T H.222.0:2012 2.4.4.1 Pointer
	// ITU-T H.222.0:2012 2.4.4.3 Program association table
	{
		Проверить(уНачало < уКонец);
		уНачало += 1 + _мбКуча[уНачало]; // pointer_field
		Проверить(уКонец - уНачало >= 16); // Ошибка в pointer_field?
		Проверить(_мбКуча[уНачало] === 0); // table_id == program_association_section
		Проверить((_dvКуча.getUint16(уНачало + 1) & 0xCFFF) === 0x800D); // section_syntax_indicator == 1, '0' == 0, section_length == 13
		Проверить((_мбКуча[уНачало + 5] & 1) === 1); // current_next_indicator == 1
		var nPatVersion = _мбКуча[уНачало + 5] & 0x3E;
		Проверить(_мбКуча[уНачало + 6] === 0); // section_number == 0
		Проверить(_мбКуча[уНачало + 7] === 0); // last_section_number == 0
		var nProgramNumber = _dvКуча.getUint16(уНачало + 8); // program_number
		Проверить(nProgramNumber !== 0);
		var nPmtPid = _dvКуча.getUint16(уНачало + 10) & 0x1FFF; // program_map_pid
		Проверить(nPmtPid >= 0x0010 && nPmtPid <= 0x1FFE);

		this.nPatVersion = nPatVersion;
		this.nProgramNumber = nProgramNumber;
		this.nPmtPid = nPmtPid;
	}

	function ProgramMapTable(уНачало, уКонец, nProgramNumber)
	// ITU-T H.222.0:2012 2.4.4.1 Pointer
	// ITU-T H.222.0:2012 2.4.4.8 Program map table
	// Timed metadata for HLS https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HTTP_Live_Streaming_Metadata_Spec/
	{
		Проверить(уНачало < уКонец);
		уНачало += 1 + _мбКуча[уНачало]; // pointer_field
		Проверить(уКонец - уНачало >= 12); // Ошибка в pointer_field?
		Проверить(_мбКуча[уНачало] === 2); // table_id == ts_program_map_section
		var уКонецСекции = _dvКуча.getUint16(уНачало + 1); // section_length
		Проверить((уКонецСекции & 0xC000) === 0x8000); // section_syntax_indicator == 1, '0' == 0
		уКонецСекции = уНачало + 3 + (уКонецСекции & 0x0FFF) - 4; // offsetof(program_number) + section_length - sizeof(crc_32)
		Проверить(уКонецСекции >= уНачало + 12 && уКонецСекции + 4 <= уКонец); // Ошибка в section_length?
		Проверить(_dvКуча.getUint16(уНачало + 3) === nProgramNumber); // program_number
		Проверить((_мбКуча[уНачало + 5] & 1) === 1); // current_next_indicator == 1
		var nPmtVersion = _мбКуча[уНачало + 5] & 0x3E;
		Проверить(_мбКуча[уНачало + 6] === 0); // section_number == 0
		Проверить(_мбКуча[уНачало + 7] === 0); // last_section_number == 0
		уНачало += 12 + (_dvКуча.getUint16(уНачало + 10) & 0x0FFF); // program_info_length
		var nVideoPid = -1, nAudioPid = -1, nMetadataPid = -1;
		while (уНачало !== уКонецСекции)
		{
			var pDescriptor = уНачало + 5;
			Проверить(pDescriptor <= уКонецСекции); // Ошибка в program_info_length или es_info_length?
			var nElementaryPid = _dvКуча.getUint16(уНачало + 1) & 0x1FFF; // elementary_pid
			Проверить(nElementaryPid >= 0x0010 && nElementaryPid <= 0x1FFE);
			var nEsInfoLength = _dvКуча.getUint16(уНачало + 3) & 0x0FFF; // es_info_length
			Проверить(pDescriptor + nEsInfoLength <= уКонецСекции);
			switch (_мбКуча[уНачало]) // stream_type
			{
			case 0x1B: // AVC video stream H.264
				if (nVideoPid === -1)
				{
					nVideoPid = nElementaryPid;
				}
				else
				{
					м_Журнал.Ой(`Найден дополнительный видеопоток PID=${nElementaryPid}`);
				}
				break;

			case 0x0F: // Audio with ADTS transport syntax
				if (nAudioPid === -1)
				{
					nAudioPid = nElementaryPid;
				}
				else
				{
					м_Журнал.Ой(`Найден дополнительный аудиопоток PID=${nElementaryPid}`);
				}
				break;

			case 0x15: // Metadata carried in PES packets
				// Для упрощения цикл заменен на разбор одного элемента.
				// ITU-T H.222.0:2012 2.6.60 Metadata descriptor
				if (nEsInfoLength === 15
				&& _мбКуча[pDescriptor     ] ===   38 // descriptor_tag == metadata_descriptor
				&& _мбКуча[pDescriptor +  1] ===   13 // descriptor_length
				&& _мбКуча[pDescriptor +  2] === 0xFF // metadata_application_format
				&& _мбКуча[pDescriptor +  3] === 0xFF // metadata_application_format
				&& _мбКуча[pDescriptor +  4] === 0x49 // metadata_application_format_identifier[0] == 'I'
				&& _мбКуча[pDescriptor +  5] === 0x44 // metadata_application_format_identifier[1] == 'D'
				&& _мбКуча[pDescriptor +  6] === 0x33 // metadata_application_format_identifier[2] == '3'
				&& _мбКуча[pDescriptor +  7] === 0x20 // metadata_application_format_identifier[3] == ' '
				&& _мбКуча[pDescriptor +  8] === 0xFF // metadata_format
				&& _мбКуча[pDescriptor +  9] === 0x49 // metadata_format_identifier[0] == 'I'
				&& _мбКуча[pDescriptor + 10] === 0x44 // metadata_format_identifier[1] == 'D'
				&& _мбКуча[pDescriptor + 11] === 0x33 // metadata_format_identifier[2] == '3'
				&& _мбКуча[pDescriptor + 12] === 0x20)// metadata_format_identifier[3] == ' '
				{
					if (nMetadataPid === -1)
					{
						nMetadataPid = nElementaryPid;
					}
					else
					{
						м_Журнал.Ой(`Найден дополнительный метапоток PID=${nElementaryPid} metadata_service_id=${_мбКуча[pDescriptor + 13]}`);
					}
				}
				break;
			}
			уНачало = pDescriptor + nEsInfoLength;
		}

		this.nPmtVersion = nPmtVersion;
		this.nVideoPid = nVideoPid;
		this.nAudioPid = nAudioPid;
		this.nMetadataPid = nMetadataPid;
	}

	function РазобратьМетаданные()
	{
		if (_муНачалоМетаданных.length === 0)
		{
			return;
		}
		// Twitch: Перед основным PES-пакетом с метаданными может идти рекламный, который разбирать не нужно.
		var oID3 = new ID3(_мбКуча, _муНачалоМетаданных[_муНачалоМетаданных.length - 1], _дорМетаданные.уКонецПотока);
		for (var сИдПоля of oID3)
		{
			if (сИдПоля === 'TXXX')
			{
				// TODO Не разбирать метаданные встроенной рекламы.
				var {сОписание, сЗначение} = oID3.РазобратьTXXX();
				if (сОписание === 'segmentmetadata')
				{
					var оМетаданные = JSON.parse(сЗначение);
					if (Number.isFinite(оМетаданные.transc_r))
					{
						Проверить(оМетаданные.transc_r > 1420070400000 && оМетаданные.transc_r < 1846886400000);
						_чВремяКодирования = оМетаданные.transc_r;
					}
					if (Number.isFinite(оМетаданные.stream_offset))
					{
						Проверить(оМетаданные.stream_offset >= 0);
						_чПозицияТрансляции = оМетаданные.stream_offset;
					}
				}
				break;
			}
		}
	}

	function РазобратьВидеоПоток()
	{
		if (_лРазрыв)
		{
			_abSequenceParameterSet    = null;
			_abPictureParameterSet     = null;
			_abSequenceParameterSetExt = null;
		}

		if (_дорВидео.Пусто())
		{
			return true;
		}

		var ФЛАГИ_ОБЫЧНОГО_КАДРА  = 0x00010000; // sample_is_non_sync_sample
		var ФЛАГИ_КЛЮЧЕВОГО_КАДРА = 0x00000000;

		Проверить(_дорВидео.уНачалоПотока > _дорВидео.уНачалоПамятиПотока && _дорВидео.уКонецПотока > _дорВидео.уНачалоПотока && _дорВидео.уКонецСемплов > _дорВидео.уНачалоСемплов);

		var уРазобранныйПоток = _дорВидео.уНачалоПамятиПотока;
		var уСемплПервогоКлючКадра = -1;
		var cNalUnits = 0, cAccessUnits = 0, кСемпловБезVCL = 0, кКлючКадров = 0, уСемплПоследнегоКлючКадра = -1; // Статистика.

		var уСемпл = _дорВидео.уНачалоСемплов;
		var уНачалоСледующегоСемпла = -1;
		var уНачалоРазобранногоСемпла;
		var чФлагиСемпла;

		var pNalUnitEnd = _фНайтиПрефикс(_дорВидео.уНачалоПотока, _дорВидео.уКонецПотока);
		Проверить(pNalUnitEnd === _дорВидео.уНачалоПотока);
		// Сегмент должен начинаться с первого nal unit в access unit.
		// ITU-T H.264:2014 B.1.1 Byte stream NAL unit syntax
		// У первого nal unit в access unit в префиксе должен быть zero_byte.
		Проверить(_мцКуча[0] > 3);
		for (;;)
		{
			var кбРазмерПрефикса = pNalUnitEnd === _дорВидео.уКонецПотока ? 0 : _мцКуча[0];

			// Nal unit может быть размазан по двум PES-пакетам. При определении, какому PES-пакету (а значит
			// и видеосемплу) пренадлежит nal unit, leading_zero_8bits и trailing_zero_8bits не учитываются.
			var лНачалоСемпла = pNalUnitEnd + кбРазмерПрефикса - Math.min(4, кбРазмерПрефикса) >= уНачалоСледующегоСемпла;

			// Окончание видеосемпла?
			if (лНачалоСемпла && уНачалоСледующегоСемпла !== -1)
			{
				// report://04654360436705_15093211313
				// Начало видеосемпла 0 длительность 1мс
				// random_access_indicator = true
				// NAL units: 9, 7 (копия из видеосемпла 1), 8 (копия из видеосемпла 1), 6
				// Начало видеосемпла 1 длительность 32мс
				// random_access_indicator = true
				// NAL units: 9, 7, 8, 5
				// Начало видеосемпла 2 длительность 33мс
				// random_access_indicator = false
				// NAL units: 9, 1
				if (чФлагиСемпла === -1)
				{
					// TODO На примере выше у семпла должны быть ФЛАГИ_КЛЮЧЕВОГО_КАДРА? Я не использую random_access_indicator.
					чФлагиСемпла = ФЛАГИ_ОБЫЧНОГО_КАДРА;
					++кСемпловБезVCL;
				}
				Проверить(уРазобранныйПоток > уНачалоРазобранногоСемпла);
				_dvКуча.setUint32(уСемпл + РАЗМЕР_ВИДЕОСЕМПЛА, уРазобранныйПоток - уНачалоРазобранногоСемпла);
				_dvКуча.setUint32(уСемпл + ФЛАГИ_ВИДЕОСЕМПЛА, чФлагиСемпла);
				уСемпл += РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
			}

			// Весь видеопоток разобран?
			if (pNalUnitEnd === _дорВидео.уКонецПотока)
			{
				Проверить(уСемпл === _дорВидео.уКонецСемплов);
				break;
			}

			var pNalUnitBegin = pNalUnitEnd + кбРазмерПрефикса;
			pNalUnitEnd = _фНайтиПрефикс(pNalUnitBegin, _дорВидео.уКонецПотока);
			Браковать(pNalUnitEnd >= pNalUnitBegin);

			// Начало видеосемпла?
			if (лНачалоСемпла)
			{
				Проверить(уСемпл < _дорВидео.уКонецСемплов);
				уНачалоСледующегоСемпла = _dvКуча.getUint32(уСемпл + РАЗМЕР_ВИДЕОСЕМПЛА);
				уНачалоРазобранногоСемпла = уРазобранныйПоток;
				чФлагиСемпла = -1;
				if (cAccessUnits === 1)
				{
					cAccessUnits = 0;
				}
			}

			// report://04345327250280_15079306647
			// Куча пустышек, которые не влияют на воспроизведение.
			if (pNalUnitBegin === pNalUnitEnd)
			{
				// Не сохранять в видеопотоке.
				continue;
			}
			++cNalUnits;

			var nNalRefIdc = _мбКуча[pNalUnitBegin] & 0xE0; // nal_ref_idc
			Браковать(nNalRefIdc < 0x80); // forbidden_zero_bit == 0

			// ISO 14496-15:2013 5.2 Table 2 NAL unit types in elementary streams
			switch (_мбКуча[pNalUnitBegin] & 0x1F) // nal_unit_type
			{
			case 1: // coded slice of a non-idr picture
			case 2:	// coded slice data partition a
			case 3:	// coded slice data partition b
			case 4:	// coded slice data partition c
				Проверить(чФлагиСемпла !== ФЛАГИ_КЛЮЧЕВОГО_КАДРА);
				чФлагиСемпла = ФЛАГИ_ОБЫЧНОГО_КАДРА;
				break;

			case 5: // coded slice of an idr picture
				// ISO 14496-15:2013 4.8 Sync sample (IDR)
				// HLS допускает отсутствие ключевого кадра в сегменте.
				// TODO Ключевой кадр также можно определить по random_access_indicator, но я не доверяю ПО, создающему транспортный поток.
				Проверить(nNalRefIdc !== 0);
				// Кадр может быть разбит на несколько slices.
				if (чФлагиСемпла !== ФЛАГИ_КЛЮЧЕВОГО_КАДРА)
				{
					Проверить(чФлагиСемпла !== ФЛАГИ_ОБЫЧНОГО_КАДРА);
					чФлагиСемпла = ФЛАГИ_КЛЮЧЕВОГО_КАДРА;
					if (уСемплПервогоКлючКадра === -1)
					{
						уСемплПервогоКлючКадра = уСемпл;
					}
					уСемплПоследнегоКлючКадра = уСемпл;
					++кКлючКадров;
				}
				break;

			case 6: // supplemental enhancement information
				Проверить(nNalRefIdc === 0);
				break;

			case 7: // sequence parameter set
				// HLS допускает отсутствие SPS и PPS в сегменте.
				// Стандарт допускает наличие нескольких SPS с разными параметрами и одинаковым seq_parameter_set_id.
				// PS4: SPS и PPS есть в ключевых кадрах, а также в первом кадре сегмента, даже если он не является ключевым.
				// PS4: Иногда в одном acces unit вместо одной пары SPS + PPS идут подряд несколько пар. В них SPS отличаются
				// размером, значением constraint_set1_flag, значением level_idc, наличием vui_parameters, ...
				// Мы поддерживаем только один SPS, поэтому запоминаем последний.
				Проверить(nNalRefIdc !== 0);
				if (_лРазрыв && (уСемплПервогоКлючКадра === -1 || _abSequenceParameterSet === null))
				{
					// Делаем копию.
					_abSequenceParameterSet = _мбКуча.slice(pNalUnitBegin, pNalUnitEnd);
				}
				// Не сохранять в видеопотоке.
				continue;

			case 8: // picture parameter set
				Проверить(nNalRefIdc !== 0);
				if (_лРазрыв && (уСемплПервогоКлючКадра === -1 || _abPictureParameterSet === null))
				{
					// Делаем копию.
					_abPictureParameterSet = _мбКуча.slice(pNalUnitBegin, pNalUnitEnd);
				}
				// Не сохранять в видеопотоке.
				continue;

			case 9: // access unit delimiter
				Проверить(nNalRefIdc === 0);
				++cAccessUnits;
				// Не сохранять в видеопотоке.
				continue;

			case 10: // end of sequence
				Проверить(nNalRefIdc === 0);
				// Не сохранять в видеопотоке.
				continue;

			case 11: // end of stream
				Проверить(nNalRefIdc === 0);
				Проверить(false); // UNDONE
				// Не сохранять в видеопотоке.
				continue;

			case 12: // filler data
				Проверить(nNalRefIdc === 0);
				// Не сохранять в видеопотоке.
				continue;

			case 13: // sequence parameter set extension
				Проверить(nNalRefIdc !== 0);
				Проверить(false); // UNDONE
				if (_лРазрыв && (уСемплПервогоКлючКадра === -1 || _abSequenceParameterSetExt === null))
				{
					// Делаем копию.
					_abSequenceParameterSetExt = _мбКуча.slice(pNalUnitBegin, pNalUnitEnd);
				}
				// Не сохранять в видеопотоке.
				continue;
			}

			var cbNalUnit = pNalUnitEnd - pNalUnitBegin;
			_dvКуча.setUint32(уРазобранныйПоток, cbNalUnit);
			уРазобранныйПоток += 4;
			Проверить(уРазобранныйПоток < pNalUnitBegin);
			_мбКуча.copyWithin(уРазобранныйПоток, pNalUnitBegin, pNalUnitEnd);
			уРазобранныйПоток += cbNalUnit;
		}

		_дорВидео.уНачалоПотока = _дорВидео.уНачалоПамятиПотока;
		_дорВидео.уКонецПотока = уРазобранныйПоток;

		м_Журнал.Вот('NalUnits=' + cNalUnits
			+ ' КлючКадров='     + кКлючКадров
			+ ' ПервКлючКадр='   + _дорВидео.ПолучитьНомерСемпла(уСемплПервогоКлючКадра)
			+ ' ПослКлючКадр='   + _дорВидео.ПолучитьНомерСемпла(уСемплПоследнегоКлючКадра)
		);

		if (кСемпловБезVCL !== 0)
		{
			м_Журнал.Ой(`Видеосемплов без VCL NAL unit: ${кСемпловБезVCL}`);
		}

		if (cAccessUnits > 1)
		{
			м_Журнал.Ой('Несколько access unit в одном видеосемпле');
		}

		if (_лРазрыв)
		{
			if (уСемплПервогоКлючКадра === -1 || _abSequenceParameterSet === null || _abPictureParameterSet === null)
			{
				м_Журнал.Ой(`Сегмент не годится для воспроизведения: не найден IDR ${уСемплПервогоКлючКадра === -1}, не найден SPS ${_abSequenceParameterSet === null}, не найден PPS ${_abPictureParameterSet === null}`);
				return false;
			}
			// Делаем копию.
			var мбКопия = _abSequenceParameterSet.slice();
			var о = RemoveEmulationPreventionBytesFromNalUnit(мбКопия, 0, мбКопия.length);
			ParseSequenceParameterSet(мбКопия, о.уНачалоRBSP, о.уКонецRBSP);
		}
		else if (ДЕЛАТЬ_ПЕРВЫЙ_КАДР_КЛЮЧЕВЫМ && уСемплПервогоКлючКадра !== _дорВидео.уНачалоСемплов)
		{
			м_Журнал.Ой('Делаю первый видеосемпл ключевым');
			_dvКуча.setUint32(_дорВидео.уНачалоСемплов + ФЛАГИ_ВИДЕОСЕМПЛА, ФЛАГИ_КЛЮЧЕВОГО_КАДРА);
		}
		return true;
	}

	function ParseSequenceParameterSet(мбПоток, уНачало, уКонец)
	// Не изменяет содержимое мбПоток.
	{
		_nProfileIndication = мбПоток[уНачало    ]; // profile_idc
		_nConstraintSetFlag = мбПоток[уНачало + 1]; // constraint_set_flag
		_nLevelIndication   = мбПоток[уНачало + 2]; // level_idc
		var оПотокБитов = new ПотокБитов(мбПоток, уНачало + 3, уКонец);
		оПотокБитов.ПропуститьЭКГ(); // seq_parameter_set_id
		var nSeparateColourPlaneFlag = 0;
		_nChromaFormatIndication     = 1;
		_nBitDepthLumaMinus8         = 0;
		_nBitDepthChromaMinus8       = 0;
		switch (_nProfileIndication)
		{
		case 183:
			_nChromaFormatIndication = 0;
			break;
		case 100:
		case 110:
		case 122:
		case 244:
		case 44:
		case 83:
		case 86:
		case 118:
		case 128:
		case 138:
		case 139:
		case 134:
			_nChromaFormatIndication = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // chroma_format_idc
			Проверить(_nChromaFormatIndication <= 3); // 3 для H.264 и IBMFF
			if (_nChromaFormatIndication === 3)
			{
				nSeparateColourPlaneFlag = оПотокБитов.ПрочестьБиты(1); // separate_colour_plane_flag
			}
			_nBitDepthLumaMinus8 = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // bit_depth_luma_minus8
			Проверить(_nBitDepthLumaMinus8 <= 6); // 6 для H.264, 7 для IBMFF
			_nBitDepthChromaMinus8 = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // bit_depth_chroma_minus8
			Проверить(_nBitDepthChromaMinus8 <= 6); // 6 для H.264, 7 для IBMFF
			оПотокБитов.ПропуститьБиты(1); // qpprime_y_zero_transform_bypass_flag
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // seq_scaling_matrix_present_flag
			{
				for (var i = 0, ic = (_nChromaFormatIndication !== 3 ? 8 : 12); i < ic; ++i)
				{
					if (оПотокБитов.ПрочестьБиты(1) !== 0) // seq_scaling_list_present_flag
					{
						var nLastScale = 8, nNextScale = 8;
						for (var j = 0, jc = (i < 6 ? 16 : 64); j < jc; ++j)
						{
							if (nNextScale !== 0)
							{
								nNextScale = (nLastScale + оПотокБитов.ПрочестьЗнаковыйЭКГ() + 256) % 256; // delta_scale
							}
							if (nNextScale !== 0)
							{
								nLastScale = nNextScale;
							}
						}
					}
				}
			}
		}
		оПотокБитов.ПропуститьЭКГ(); // log2_max_frame_num_minus4
		switch (оПотокБитов.ПрочестьБеззнаковыйЭКГ()) // pic_order_cnt_type
		{
		case 0:
			оПотокБитов.ПропуститьЭКГ(); // log2_max_pic_order_cnt_lsb_minus4
			break;
		case 1:
			оПотокБитов.ПропуститьБиты(1); // delta_pic_order_always_zero_flag
			оПотокБитов.ПропуститьЭКГ(); // offset_for_non_ref_pic
			оПотокБитов.ПропуститьЭКГ(); // offset_for_top_to_bottom_field
			for (var i = 0, ic = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); i < ic; ++i) // num_ref_frames_in_pic_order_cnt_cycle
			{
				оПотокБитов.ПропуститьЭКГ(); // offset_for_ref_frame
			}
		}
		_nMaxNumberReferenceFrames = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // max_num_ref_frames
		оПотокБитов.ПропуститьБиты(1); // gaps_in_frame_num_value_allowed_flag
		var nPictureWidthInMacroblocks = оПотокБитов.ПрочестьБеззнаковыйЭКГ() + 1; // pic_width_in_mbs_minus1
		var nPictureHeightInMapUnits = оПотокБитов.ПрочестьБеззнаковыйЭКГ() + 1; // pic_height_in_map_units_minus1
		var nFrameMacroblocksOnlyFlag = оПотокБитов.ПрочестьБиты(1); // frame_mbs_only_flag
		if (nFrameMacroblocksOnlyFlag === 0)
		{
			оПотокБитов.ПропуститьБиты(1); // mb_adaptive_frame_field_flag 
		}
		оПотокБитов.ПропуститьБиты(1); // direct_8x8_inference_flag
		var nFrameCropLeftOffset   = 0;
		var nFrameCropRightOffset  = 0;
		var nFrameCropTopOffset    = 0;
		var nFrameCropBottomOffset = 0;
		if (оПотокБитов.ПрочестьБиты(1) !== 0) // frame_cropping_flag
		{
			nFrameCropLeftOffset   = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_left_offset
			nFrameCropRightOffset  = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_right_offset
			nFrameCropTopOffset    = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_top_offset
			nFrameCropBottomOffset = оПотокБитов.ПрочестьБеззнаковыйЭКГ(); // frame_crop_bottom_offset
		}

		_чЧастотаКадров = 0;
		_чДиапазон      = -1;
		if (оПотокБитов.ПрочестьБиты(1) !== 0) // vui_parameters
		{
			var nAspectRatioIndication, nSarWidth, nSarHeight;
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // aspect_ratio_info_present_flag
			{
				// 0 Unspecified
				// 1 1:1
				nAspectRatioIndication = оПотокБитов.ПрочестьБиты(8); // aspect_ratio_idc
				if (nAspectRatioIndication === 255)
				{
					nSarWidth  = оПотокБитов.ПрочестьБиты(16); // sar_width
					nSarHeight = оПотокБитов.ПрочестьБиты(16); // sar_height
				}
			}
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // overscan_info_present_flag
			{
				оПотокБитов.ПропуститьБиты(1); // overscan_appropriate_flag
			}
			var nVideoFormat;
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // video_signal_type_present_flag
			{
				// 0 Component
				// 1 PAL
				// 2 NTSC
				// 3 SECAM
				// 4 MAC
				// 5 Unspecified
				nVideoFormat = оПотокБитов.ПрочестьБиты(3); // video_format
				_чДиапазон = оПотокБитов.ПрочестьБиты(1); // video_full_range_flag
				if (оПотокБитов.ПрочестьБиты(1) !== 0) // colour_description_present_flag
				{
					оПотокБитов.ПропуститьБиты(8 + 8 + 8); // colour_primaries + transfer_characteristics + matrix_coefficients
				}
			}
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // chroma_loc_info_present_flag
			{
				оПотокБитов.ПропуститьЭКГ(); // chroma_sample_loc_type_top_field
				оПотокБитов.ПропуститьЭКГ(); // chroma_sample_loc_type_bottom_field
			}
			var nNumUnitsInTick, nTimeScale, nFixedFrameRateFlag;
			if (оПотокБитов.ПрочестьБиты(1) !== 0) // timing_info_present_flag
			{
				nNumUnitsInTick = оПотокБитов.ПрочестьБиты(32); // num_units_in_tick
				nTimeScale = оПотокБитов.ПрочестьБиты(32); // time_scale
				nFixedFrameRateFlag = оПотокБитов.ПрочестьБиты(1); // fixed_frame_rate_flag
				_чЧастотаКадров = nTimeScale / nNumUnitsInTick / (nFixedFrameRateFlag === 0 ? -2 : 2);
			}
		}

		var nCropUnitX = 1;
		var nCropUnitY = 1;
		if (nSeparateColourPlaneFlag === 0 && _nChromaFormatIndication !== 0) // ChromaArrayType !== 0
		{
			nCropUnitX = _nChromaFormatIndication === 3 ? 1 : 2; // = nSubWidthC
			nCropUnitY = _nChromaFormatIndication === 1 ? 2 : 1; // = nSubHeightC
		}
		if (nFrameMacroblocksOnlyFlag === 0)
		{
			nCropUnitY += nCropUnitY;
			nPictureHeightInMapUnits += nPictureHeightInMapUnits;
		}

		_чШиринаКартинки = nPictureWidthInMacroblocks * 16 - nCropUnitX * nFrameCropRightOffset  - nCropUnitX * nFrameCropLeftOffset;
		_чВысотаКартинки = nPictureHeightInMapUnits   * 16 - nCropUnitY * nFrameCropBottomOffset - nCropUnitY * nFrameCropTopOffset;
		_лЧересстрочное = nFrameMacroblocksOnlyFlag === 0;
		Проверить(!_лЧересстрочное); // UNDONE
	}

	function RemoveEmulationPreventionBytesFromNalUnit(мбПоток, уНачало, уКонец)
	// ITU-T H.264:2014 7.4.1 NAL unit semantics
	// Выкидывает все emulation prevention bytes из NAL unit.
	// уНачало - начало NAL unit, уКонец - конец NAL unit.
	// Возвращает {указатель на начало RBSP, указатель на конец RBSP}.
	// Допускается RBSP нулевого размера.
	// В NAL unit не должен встречаться start code prefix.
	{
		// Первый байт не кодируется.
		Проверить(уНачало < уКонец);
		var nNalUnitType = мбПоток[уНачало++] & 0x1F; // nal_unit_type
		// nal_unit_header_svc_extension, nal_unit_header_3davc_extension и nal_unit_header_mvc_extension не кодируются.
		if (nNalUnitType === 14 || nNalUnitType === 20 || nNalUnitType === 21)
		{
			Проверить(уНачало < уКонец);
			уНачало += nNalUnitType === 21 && (мбПоток[уНачало] & 0x80) !== 0 ? 2 : 3;
			Проверить(уНачало <= уКонец);
		}
		var уНачалоRBSP = уНачало;
		var уКонец2 = уКонец - 2;
		while (уНачало < уКонец2)
		{
			if (мбПоток[уНачало++] === 0 && мбПоток[уНачало++] === 0)
			{
				var чТретийБайт = мбПоток[уНачало++];
				// "Within the NAL unit, the following three-byte sequences shall not occur
				// at any byte-aligned position: 0x000000, 0x000001, 0x000002."
				Проверить(чТретийБайт >= 3);
				if (чТретийБайт === 3) // emulation_prevention_three_byte
				{
					var уДекодированныйПоток = уНачало - 1;
					// "Within the NAL unit, any four-byte sequence that starts with 0x000003 other than the following sequences
					// shall not occur at any byte-aligned position: 0x00000300, 0x00000301, 0x00000302, 0x00000303."
					Проверить(уНачало === уКонец || мбПоток[уНачало] <= 3);
					while (уНачало < уКонец2)
					{
						if ((мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++]) === 0
						&&  (мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++]) === 0)
						{
							чТретийБайт = мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++];
							// "Within the NAL unit, the following three-byte sequences shall not occur
							// at any byte-aligned position: 0x000000, 0x000001, 0x000002."
							Проверить(чТретийБайт >= 3);
							if (чТретийБайт === 3) // emulation_prevention_three_byte
							{
								--уДекодированныйПоток;
								// "Within the NAL unit, any four-byte sequence that starts with 0x000003 other than the following sequences
								// shall not occur at any byte-aligned position: 0x00000300, 0x00000301, 0x00000302, 0x00000303."
								Проверить(уНачало === уКонец || мбПоток[уНачало] <= 3);
							}
						}
					}
					while (уНачало !== уКонец)
					{
						var чПоследнийБайт = мбПоток[уДекодированныйПоток++] = мбПоток[уНачало++];
					}
					// "The last byte of the NAL unit shall not be equal to 0x00."
					Проверить(чПоследнийБайт !== 0);
					return {
						уНачалоRBSP,
						уКонецRBSP: уДекодированныйПоток
					};
				}
			}
		}
		// "The last byte of the NAL unit shall not be equal to 0x00."
		Проверить(уНачало === уКонец || мбПоток[уКонец - 1] !== 0);
		// Ни одного байта не выкинуто.
		return {
			уНачалоRBSP,
			уКонецRBSP: уКонец
		};
	}


	function РазобратьАудиоПоток()
	// ISO 14496-3:2009 1.6 Interface to ISO/IEC 14496-1 (MPEG-4 Systems)
	// ISO 13818-7:2004 6.2 Audio Data Transport Stream, ADTS
	// Firefox 46: Жрет HE-AACv1 даже если в названии кодека AAC-LC.
	// Chrome 50+: Жрет HE-AACv1 и HE-AACv2 даже если в названии кодека AAC-LC.
	{
		if (_дорАудио.Пусто())
		{
			return true;
		}

		var ADTS_HEADER_SIZE = 7;

		Проверить(_дорАудио.уКонецПотока > _дорАудио.уНачалоПотока && _дорАудио.уКонецСемплов === _дорАудио.уНачалоСемплов);

		if (_лРазрыв)
		{
			Проверить(_дорАудио.ПолучитьРазмерПотока() > ADTS_HEADER_SIZE);
			ParseAdtsFixedHeader(_dvКуча.getUint32(_дорАудио.уНачалоПотока));
		}

		var pAdtsFrame = _дорАудио.уНачалоПотока;
		var уРазобранныйПоток = _дорАудио.уНачалоПотока;
		var уСемпл = _дорАудио.уНачалоСемплов;
		var уКонецПотока = _дорАудио.уКонецПотока - ADTS_HEADER_SIZE;
		var уКонецПамятиСемплов = _дорАудио.уКонецПамятиСемплов - РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА;
		while (pAdtsFrame < уКонецПотока)
		{
			Проверить(уСемпл <= уКонецПамятиСемплов);
			Проверить(_мбКуча[pAdtsFrame] === 0xFF && _мбКуча[pAdtsFrame + 1] === 0xF1); // syncword = 0xFFF, id = 0, layer = 0, protection_absent = 1
			Проверить((_мбКуча[pAdtsFrame + 6] & 0x03) === 0); // number_of_raw_data_blocks_in_frame == 0
			var cbAdtsFrame = (_dvКуча.getUint32(pAdtsFrame + 3) >> 13) & 0x00001FFF; // aac_frame_length
			var pNextAdtsFrame = pAdtsFrame + cbAdtsFrame;
			Проверить(cbAdtsFrame > ADTS_HEADER_SIZE && pNextAdtsFrame <= _дорАудио.уКонецПотока);
			_мбКуча.copyWithin(уРазобранныйПоток, pAdtsFrame + ADTS_HEADER_SIZE, pNextAdtsFrame);
			cbAdtsFrame -= ADTS_HEADER_SIZE;
			уРазобранныйПоток += cbAdtsFrame;
			_dvКуча.setUint32(уСемпл, cbAdtsFrame); // sample_size
			уСемпл += РАЗМЕР_СТРУКТУРЫ_АУДИОСЕМПЛА;
			pAdtsFrame = pNextAdtsFrame;
		}
		Проверить(pAdtsFrame === _дорАудио.уКонецПотока);
		_дорАудио.уКонецПотока = уРазобранныйПоток;
		_дорАудио.уКонецСемплов = уСемпл;

		var чДлительностьАудиоСемпла = ДЛИНА_АУДИОСЕМПЛА / _чЧастотаДискретизации;
		var чДлительностьАудиоСегмента = _дорАудио.ПолучитьКоличествоСемплов() * чДлительностьАудиоСемпла;
		_чВДКонцаАудиоСегмента = _дорАудио.чВДНачала + Math.round(чДлительностьАудиоСегмента * TS_TIMESCALE);
		_чБитрейтЗвука = _дорАудио.ПолучитьРазмерПотока() * 8 / 1000 / чДлительностьАудиоСегмента;

		м_Журнал.Вот(`ВДКонцаАудСегмента=${(_чВДКонцаАудиоСегмента / TS_TIMESCALE).toFixed(5)}`
			+ ` ДлитАудСегмента=${(чДлительностьАудиоСегмента * 1000).toFixed(2)}мс`
			+ ` ДлитАудСемпла=${(чДлительностьАудиоСемпла * 1000).toFixed(2)}мс`
		);
		return true;
	}

	function ParseAdtsFixedHeader(nAdtsFixedHeader)
	{
		Проверить((nAdtsFixedHeader & 0xFFFF0000) === (0xFFF10000 | 0)); // syncword = 0xFFF, id = 0, layer = 0, protection_absent = 1
		_nAudioObjectType = ((nAdtsFixedHeader >> 14) & 3) + 1; // profile_objecttype
		Проверить(_nAudioObjectType === 2); // UNDONE
		_anDecoderSpecificInfo[0] = _nAudioObjectType << 3; // audioobjecttype
		// ISO 14496-3:2009 Table 1.18 Sampling Frequency Index
		var чИндексЧастотыДискретизации = (nAdtsFixedHeader >> 10) & 0x0F; // sampling_frequency_index
		_чЧастотаДискретизации = ЧАСТОТА_ДИСКРЕТИЗАЦИИ[чИндексЧастотыДискретизации];
		Проверить(_чЧастотаДискретизации !== undefined);
		_anDecoderSpecificInfo[0] |= чИндексЧастотыДискретизации >> 1; // samplingfrequencyindex
		_anDecoderSpecificInfo[1] = (чИндексЧастотыДискретизации << 7) & 0x80; // samplingfrequencyindex
		// ISO 14496-3:2009 Table 1.19 Channel Configuration
		_чКоличествоКаналов = (nAdtsFixedHeader >> 6) & 7; // channel_configuration
		// Если channel_configuration = 0, то нужно найти program_config_element и добавить
		// его в aDecoderSpecificInfo. Chrome 71 такой aDecoderSpecificInfo не поддерживает:
		// https://bugs.chromium.org/p/chromium/issues/detail?id=241171
		Проверить(_чКоличествоКаналов !== 0);
		_anDecoderSpecificInfo[1] |= _чКоличествоКаналов << 3; // channelconfiguration
		// framelengthflag = 0 (1024 samples)
		// dependsoncorecoder = 0
		// extensionflag = 0
		м_Журнал[_nAudioObjectType !== 2 || _чЧастотаДискретизации < 44100 || _чКоличествоКаналов > 2 ? 'Ой' : 'Вот']
			(`AudioObjectType=${_nAudioObjectType} ЧастотаДискретизации=${_чЧастотаДискретизации} КоличествоКаналов=${_чКоличествоКаналов}`);
	}

	function ПолучитьНазваниеКодеков()
	// https://tools.ietf.org/html/rfc6381
	{
		var с = 'video/mp4; codecs="';
		if (!_дорВидео.Пусто())
		{
			// Начало совпадает с типом AVCSampleEntry в ДобавитьДорожкуВСегментИнициализации().
			с += 'avc1.'
				+ ('0' + _nProfileIndication.toString(16)).slice(-2)
				+ ('0' + _nConstraintSetFlag.toString(16)).slice(-2)
				+ ('0' + _nLevelIndication  .toString(16)).slice(-2);
		}
		if (!_дорВидео.Пусто() && !_дорАудио.Пусто())
		{
			с += ', ';
		}
		if (!_дорАудио.Пусто())
		{
			// Начало совпадает с типом MP4AudioSampleEntry в ДобавитьДорожкуВСегментИнициализации().
			с += `mp4a.40.${_nAudioObjectType}`;
		}
		return с + '"';
	}

	function СоздатьСегментИнициализации()
	{
		var кбРазмер = 1100
			+ (_abSequenceParameterSet    === null ? 0 : _abSequenceParameterSet   .length)
			+ (_abPictureParameterSet     === null ? 0 : _abPictureParameterSet    .length)
			+ (_abSequenceParameterSetExt === null ? 0 : _abSequenceParameterSetExt.length)
			+ (_дорАудио.Пусто()                    ? 0 : _anDecoderSpecificInfo    .length);
		var мбСегмент = new Uint8Array(кбРазмер);
		var dvСегмент = СоздатьDataView(мбСегмент);
		var оСегмент = new IsoBaseMedia(мбСегмент, dvСегмент, 0);

		// ISO 14496-12:2012 Annex E File format brands
		// ISO 14496-15:2013 5.4.1 AVC File type and identification
		оСегмент.AddBox('ftyp',
		[
			0x69, 0x73, 0x6F, 0x36,                      // major_brand = 'iso6'
			0, 0, 0, 0,                                  // minor_version = 0
			0x61, 0x76, 0x63, 0x31                       // compatible_brands = 'avc1'
		]);

		оСегмент.AddBox('moov', () =>
		{
			оСегмент.AddFullBox('mvhd', 1, 0,            // Версия 1 для обхода исправленной в Chrome 55 ошибки:
			[                                            // https://bugs.chromium.org/p/chromium/issues/detail?id=649882
				0, 0, 0, 0, 0, 0, 0, 0,                  // creation_time = 0
				0, 0, 0, 0, 0, 0, 0, 0,                  // modification_time = 0
				0, 0, 0, 1,                              // timescale = 1; В моем случае не используется.
				0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, // duration = cannot be determined
				0, 1, 0, 0,                              // rate = 1.0; Firefox 48, Chrome 53: Не используется.
				1, 0,                                    // volume = full; Firefox 48, Chrome 53: Не используется.
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,            // reserved = 0
				0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      // matrix
				0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,      // matrix
				0, 0, 0, 0, 0, 0, 0, 0, 0x40, 0, 0, 0,   // matrix
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      // pre_defined
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      // pre_defined
				0xFF, 0xFF, 0xFF, 0xFF                   // next_track_id = unknown
			]);

			оСегмент.AddBox('mvex', () =>
			{
				if (!_дорВидео.Пусто())
				{
					оСегмент.AddFullBox('trex', 0, 0, 20);
					оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 20, НОМЕР_ВИДЕО_ДОРОЖКИ); // track_id
					оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 16, 1);                   // default_sample_description_index
					// default_sample_duration = 0
					// default_sample_size = 0
					// default_sample_flags = !sample_is_non_sync_sample
				}

				if (!_дорАудио.Пусто())
				{
					оСегмент.AddFullBox('trex', 0, 0, 20);
					оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 20, НОМЕР_АУДИО_ДОРОЖКИ); // track_id
					оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 16, 1);                   // default_sample_description_index
					оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 12, ДЛИНА_АУДИОСЕМПЛА);   // default_sample_duration
					// default_sample_size = 0
					// default_sample_flags = !sample_is_non_sync_sample
				}
			});

			if (!_дорВидео.Пусто())
			{
				ДобавитьДорожкуВСегментИнициализации(true, оСегмент);
			}

			if (!_дорАудио.Пусто())
			{
				ДобавитьДорожкуВСегментИнициализации(false, оСегмент);
			}
		});

		return оСегмент.Завершить();
	}

	function ДобавитьДорожкуВСегментИнициализации(лВидео, оСегмент)
	{
		оСегмент.AddBox('trak', () =>
		{
			оСегмент.AddFullBox('tkhd', 0, 3, 80);                                     // track_in_movie | track_enabled
			// creation_time = 0
			// modification_time = 0
			// reserved = 0
			оСегмент.мбБуфер[оСегмент.уКонец - 64] = 0xFF;                             // duration = cannot be determined
			оСегмент.мбБуфер[оСегмент.уКонец - 63] = 0xFF;                             // duration = cannot be determined
			оСегмент.мбБуфер[оСегмент.уКонец - 62] = 0xFF;                             // duration = cannot be determined
			оСегмент.мбБуфер[оСегмент.уКонец - 61] = 0xFF;                             // duration = cannot be determined
			// reserved = 0
			// layer = 0
			// alternate_group = 0
			// volume = 0
			// reserved = 0
			оСегмент.мбБуфер[оСегмент.уКонец - 43] = 1;                                // matrix
			оСегмент.мбБуфер[оСегмент.уКонец - 27] = 1;                                // matrix
			оСегмент.мбБуфер[оСегмент.уКонец - 12] = 0x40;                             // matrix
			// width = 0
			// height = 0
			if (лВидео)
			{
				оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 72, НОМЕР_ВИДЕО_ДОРОЖКИ); // track_id
				оСегмент.dvБуфер.setUint16(оСегмент.уКонец - 8, _чШиринаКартинки);     // width
				оСегмент.dvБуфер.setUint16(оСегмент.уКонец - 4, _чВысотаКартинки);     // height
			}
			else
			{
				оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 72, НОМЕР_АУДИО_ДОРОЖКИ); // track_id
				оСегмент.dvБуфер.setUint16(оСегмент.уКонец - 48, 0x0100);              // volume = full; Firefox 48, Chrome 53: Не используется.
			}

			оСегмент.AddBox('mdia', () =>
			{
				оСегмент.AddFullBox('mdhd', 0, 0, 20);
				// creation_time = 0
				// modification_time = 0
				оСегмент.dvБуфер.setUint32(оСегмент.уКонец - 12, лВидео ? TS_TIMESCALE : _чЧастотаДискретизации); // timescale
				оСегмент.мбБуфер[оСегмент.уКонец - 8] = 0xFF;                          // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 7] = 0xFF;                          // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 6] = 0xFF;                          // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 5] = 0xFF;                          // duration = cannot be determined
				оСегмент.мбБуфер[оСегмент.уКонец - 4] = 0x55;                          // language = 'und'
				оСегмент.мбБуфер[оСегмент.уКонец - 3] = 0xC4;                          // language = 'und'
				// pre_defined = 0

				оСегмент.AddFullBox('hdlr', 0, 0, 21);
				// pre_defined = 0
				if (лВидео)
				{
					оСегмент.мбБуфер[оСегмент.уКонец - 17] = 0x76;                     // handler_type = 'vide'
					оСегмент.мбБуфер[оСегмент.уКонец - 16] = 0x69;                     // handler_type = 'vide'
					оСегмент.мбБуфер[оСегмент.уКонец - 15] = 0x64;                     // handler_type = 'vide'
					оСегмент.мбБуфер[оСегмент.уКонец - 14] = 0x65;                     // handler_type = 'vide'
				}
				else
				{
					оСегмент.мбБуфер[оСегмент.уКонец - 17] = 0x73;                     // handler_type = 'soun'
					оСегмент.мбБуфер[оСегмент.уКонец - 16] = 0x6F;                     // handler_type = 'soun'
					оСегмент.мбБуфер[оСегмент.уКонец - 15] = 0x75;                     // handler_type = 'soun'
					оСегмент.мбБуфер[оСегмент.уКонец - 14] = 0x6E;                     // handler_type = 'soun'
				}
				// reserved = 0
				// name = '\0'

				оСегмент.AddBox('minf', () =>
				{
					if (лВидео)
					{
						оСегмент.AddFullBox('vmhd', 0, 1, 8);
						// graphicsmode = 0
						// opcolor = {0, 0, 0}
					}
					else
					{
						оСегмент.AddFullBox('smhd', 0, 0, 4);
						// balance = 0
						// reserved = 0
					}

					оСегмент.AddBox('dinf', () =>
					{
						оСегмент.AddFullBox('dref', 0, 0, () =>
						{
							оСегмент.dvБуфер.setUint32(оСегмент.уКонец, 1); // entry_count
							оСегмент.уКонец += 4;
							оСегмент.AddFullBox('url ', 0, 1, 0);
						});
					});

					оСегмент.AddBox('stbl', () =>
					{
						//
						// ISO 14496-12:2012 SampleDescriptionBox
						//
						оСегмент.AddFullBox('stsd', 0, 0, () =>
						{
							оСегмент.dvБуфер.setUint32(оСегмент.уКонец, 1); // entry_count
							оСегмент.уКонец += 4;

							if (лВидео)
							{
								//
								// ISO 14496-15:2013 AVCSampleEntry
								//
								оСегмент.AddBox('avc1', () =>
								{
									//
									// ISO 14496-12:2012 SampleEntry
									//
									// reserved = 0
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 6, 1);                                  // data_reference_index
									//
									// ISO 14496-12:2012 VisualSampleEntry
									//
									// pre_defined = 0
									// reserved = 0
									// pre_defined = 0
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 24, _чШиринаКартинки);                  // width
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 26, _чВысотаКартинки);                  // height
									оСегмент.dvБуфер.setUint32(оСегмент.уКонец + 28, 0x00480000);                        // horizresolution = 72 dpi
									оСегмент.dvБуфер.setUint32(оСегмент.уКонец + 32, 0x00480000);                        // vertresolution = 72 dpi
									// reserved = 0
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 40, 1);                                 // frame_count
									// compressorname = 0
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 74, 0x0018);                            // depth = the video sequence is in colour with no alpha
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 76, 0xFFFF);                            // pre_defined
									оСегмент.уКонец += 78;
									//
									// ISO 14496-15:2013 AVCConfigurationBox
									//
									оСегмент.AddBox('avcC', () =>
									{
										оСегмент.мбБуфер[оСегмент.уКонец    ] = 1;                                       // configurationversion
										оСегмент.мбБуфер[оСегмент.уКонец + 1] = _nProfileIndication;                     // avcprofileindication
										оСегмент.мбБуфер[оСегмент.уКонец + 2] = _nConstraintSetFlag;                     // profile_compatibility
										оСегмент.мбБуфер[оСегмент.уКонец + 3] = _nLevelIndication;                       // avclevelindication
										оСегмент.мбБуфер[оСегмент.уКонец + 4] = 0xFF;                                    // lengthsizeminusone = 3
										оСегмент.мбБуфер[оСегмент.уКонец + 5] = 0xE1;                                    // numofsequenceparametersets = 1
										оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 6, _abSequenceParameterSet.length); // sequenceparametersetlength
										оСегмент.КопироватьИзБуфера(оСегмент.уКонец + 8, _abSequenceParameterSet);       // sequenceparametersetnalunit
										оСегмент.мбБуфер[оСегмент.уКонец] = 1;                                           // numofpictureparametersets = 1
										оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 1, _abPictureParameterSet.length);  // pictureparametersetlength
										оСегмент.КопироватьИзБуфера(оСегмент.уКонец + 3, _abPictureParameterSet);        // pictureparametersetnalunit
										switch (_nProfileIndication)
										{
										case 100:
										case 110:
										case 122:
										case 144:
											оСегмент.мбБуфер[оСегмент.уКонец    ] = 0xFC | _nChromaFormatIndication;     // chroma_format
											оСегмент.мбБуфер[оСегмент.уКонец + 1] = 0xF8 | _nBitDepthLumaMinus8;         // bit_depth_luma_minus8
											оСегмент.мбБуфер[оСегмент.уКонец + 2] = 0xF8 | _nBitDepthChromaMinus8;       // bit_depth_chroma_minus8
											if (_abSequenceParameterSetExt === null)
											{
												// numofsequenceparametersetext = 0
												оСегмент.уКонец += 4;
											}
											else
											{
												оСегмент.мбБуфер[оСегмент.уКонец + 3] = 1;                                          // numofsequenceparametersetext
												оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 4, _abSequenceParameterSetExt.length); // sequenceparametersetextlength
												оСегмент.КопироватьИзБуфера(оСегмент.уКонец + 6, _abSequenceParameterSetExt);       // sequenceparametersetextnalunit
											}
										}
									});
								});
							}
							else
							{
								//
								// ISO 14496-14:2003 MP4AudioSampleEntry
								//
								оСегмент.AddBox('mp4a', () =>
								{
									//
									// ISO 14496-12:2012 SampleEntry
									//
									// reserved = 0
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 6, 1);                             // data_reference_index
									//
									// ISO 14496-12:2012 AudioSampleEntry
									//
									// reserved = 0
									// channelcount = 0
									оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 18, 16);                           // samplesize; Chrome 44 хочет 8, 16 или 32
									// pre_defined = 0
									// reserved = 0
									// samplerate = 0
									оСегмент.уКонец += 28;
									//
									// ISO 14496-14:2003 MP4AudioSampleEntry
									//
									оСегмент.AddFullBox('esds', 0, 0, () =>
									{
										//
										// ISO 14496-1:2010 ES_Descriptor
										//
										оСегмент.мбБуфер[оСегмент.уКонец    ] = 3;                                  // tag = es_descrtag
										оСегмент.мбБуфер[оСегмент.уКонец + 1] = 23 + _anDecoderSpecificInfo.length; // sizeofinstance <= 0x7F
										оСегмент.dvБуфер.setUint16(оСегмент.уКонец + 2, 1);                         // es_id
										// streamdependenceflag = 0
										// url_flag = 0
										// ocrstreamflag = 0
										// streampriority = 0
										//
										// ISO 14496-1:2010 DecoderConfigDescriptor
										//
										оСегмент.мбБуфер[оСегмент.уКонец + 5] = 4;                                  // tag = decoderconfigdescrtag
										оСегмент.мбБуфер[оСегмент.уКонец + 6] = 15 + _anDecoderSpecificInfo.length; // sizeofinstance <= 0x7F
										оСегмент.мбБуфер[оСегмент.уКонец + 7] = 0x40;                               // objecttypeindication = iso 14496-3 audio
										оСегмент.мбБуфер[оСегмент.уКонец + 8] = 0x15;                               // streamtype = audiostream, upstream = 0, reserved = 1
										// buffersizedb = 0
										// maxbitrate = 0
										// avgbitrate = 0
										//
										// ISO 14496-3:2009 AudioSpecificConfig
										//
										оСегмент.мбБуфер[оСегмент.уКонец + 20] = 5;                                 // tag = decspecificinfotag
										оСегмент.мбБуфер[оСегмент.уКонец + 21] = _anDecoderSpecificInfo.length;     // sizeofinstance <= 0x7F
										оСегмент.КопироватьИзМассива(оСегмент.уКонец + 22, _anDecoderSpecificInfo);
										//
										// ISO 14496-1:2010 SLConfigDescriptor
										//
										оСегмент.мбБуфер[оСегмент.уКонец    ] = 6;                                  // tag = slconfigdescrtag
										оСегмент.мбБуфер[оСегмент.уКонец + 1] = 1;                                  // sizeofinstance <= 0x7F
										оСегмент.мбБуфер[оСегмент.уКонец + 2] = 2;                                  // predefined = reserved for use in mp4 files
										оСегмент.уКонец += 3;
									});
								});
							}
						});

						оСегмент.AddFullBox('stts', 0, 0, 4);
						// entry_count = 0

						оСегмент.AddFullBox('stsc', 0, 0, 4);
						// entry_count = 0

						оСегмент.AddFullBox('stco', 0, 0, 4);
						// entry_count = 0

						оСегмент.AddFullBox('stsz', 0, 0, 8);
						// sample_size = 0
						// sample_count = 0
					});
				});
			});
		});
	}

	function СоздатьМедиасегмент(мбМедиасегмент)
	{
		var dvМедиасегмент = СоздатьDataView(мбМедиасегмент);
		var оСегмент = new IsoBaseMedia(мбМедиасегмент, dvМедиасегмент, 0);
		var уСмещениеВидеоданных, уСмещениеАудиоданных;

		оСегмент.AddBox('moof', () =>
		{
			оСегмент.AddFullBox('mfhd', 0, 0, 4);
			dvМедиасегмент.setUint32(оСегмент.уКонец - 4, 0); // sequence_number

			if (!_дорВидео.Пусто())
			{
				оСегмент.AddBox('traf', () =>
				{
					оСегмент.AddFullBox('tfhd', 0, 0x020000, 4); // default-base-is-moof
					dvМедиасегмент.setUint32(оСегмент.уКонец - 4, НОМЕР_ВИДЕО_ДОРОЖКИ); // track_id

					// timestamp занимает 33 бита.
					оСегмент.AddFullBox('tfdt', 1, 0, 8); // unsigned 64-bit integer
					мбМедиасегмент.setUint64(оСегмент.уКонец - 8, _дорВидео.чВДНачала); // basemediadecodetime

					оСегмент.AddFullBox('trun', 1, // signed sample_composition_time_offset
						0xF01, // sample-composition-time-offsets-present | sample-flags-present | sample-size-present | sample-duration-present | data-offset-present
						() =>
						{
							dvМедиасегмент.setUint32(оСегмент.уКонец, _дорВидео.ПолучитьКоличествоСемплов()); // sample_count
							уСмещениеВидеоданных = оСегмент.уКонец + 4; // data_offset
							оСегмент.КопироватьИзБуфера(оСегмент.уКонец + 8, _мбКуча, _дорВидео.уНачалоСемплов, _дорВидео.уКонецСемплов);
						}
					);
				});
			}

			if (!_дорАудио.Пусто())
			{
				оСегмент.AddBox('traf', () =>
				{
					оСегмент.AddFullBox('tfhd', 0, 0x020000, 4); // default-base-is-moof
					dvМедиасегмент.setUint32(оСегмент.уКонец - 4, НОМЕР_АУДИО_ДОРОЖКИ); // track_id

					// timestamp занимает 33 бита.
					оСегмент.AddFullBox('tfdt', 1, 0, 8); // unsigned 64-bit integer
					мбМедиасегмент.setUint64(оСегмент.уКонец - 8, _дорАудио.чВДНачала / TS_TIMESCALE * _чЧастотаДискретизации); // basemediadecodetime

					оСегмент.AddFullBox('trun', 1, // signed sample_composition_time_offset
						0x201, // sample-size-present | data-offset-present
						() =>
						{
							dvМедиасегмент.setUint32(оСегмент.уКонец, _дорАудио.ПолучитьКоличествоСемплов()); // sample_count
							уСмещениеАудиоданных = оСегмент.уКонец + 4; // data_offset
							оСегмент.КопироватьИзБуфера(оСегмент.уКонец + 8, _мбКуча, _дорАудио.уНачалоСемплов, _дорАудио.уКонецСемплов);
						}
					);
				});
			}
		});

		оСегмент.AddBox('mdat', () =>
		{
			if (!_дорВидео.Пусто())
			{
				dvМедиасегмент.setInt32(уСмещениеВидеоданных, оСегмент.уКонец - оСегмент.уНачало);
				оСегмент.КопироватьИзБуфера(оСегмент.уКонец, _мбКуча, _дорВидео.уНачалоПотока, _дорВидео.уКонецПотока);
			}
			
			if (!_дорАудио.Пусто())
			{
				dvМедиасегмент.setInt32(уСмещениеАудиоданных, оСегмент.уКонец - оСегмент.уНачало);
				оСегмент.КопироватьИзБуфера(оСегмент.уКонец, _мбКуча, _дорАудио.уНачалоПотока, _дорАудио.уКонецПотока);
			}
		});

		return оСегмент.Завершить();
	}

	function ОтправитьПреобразованныйСегмент(мбМедиасегмент)
	{
		var мбуфПередать = undefined;
		var оДанные =
		{
			чПреобразованЗа                 : _чПреобразованЗа,
			лЗабраковано                    : _лЗабраковано,
			лПотериВидео                    : _лПотериВидео,
			лПотериЗвука                    : _лПотериЗвука,
			чМинДлительностьВидеоСемпла     : _чМинДлительностьВидеоСемпла     / TS_TIMESCALE * 1000,
			чМаксДлительностьВидеоСемпла    : _чМаксДлительностьВидеоСемпла    / TS_TIMESCALE * 1000,
			чСредняяДлительностьВидеоСемпла : _чСредняяДлительностьВидеоСемпла / TS_TIMESCALE * 1000,
			чБитрейтЗвука                   : _чБитрейтЗвука,
			чПозицияКодирования             : _чПозицияКодирования,
			чПозицияТрансляции              : _чПозицияТрансляции,
			чВремяКодирования               : _чВремяКодирования
		};
		if (мбМедиасегмент)
		{
			оДанные.мбМедиасегмент = СоздатьМедиасегмент(мбМедиасегмент);
			оДанные.лЕстьВидео = !_дорВидео.Пусто();
			оДанные.лЕстьЗвук  = !_дорАудио.Пусто();
			мбуфПередать = [оДанные.мбМедиасегмент.buffer];
			if (_лРазрыв)
			{
				оДанные.мбСегментИнициализации    = СоздатьСегментИнициализации();
				оДанные.сКодеки                   = ПолучитьНазваниеКодеков();
				оДанные.nProfileIndication        = _nProfileIndication;
				оДанные.nConstraintSetFlag        = _nConstraintSetFlag;
				оДанные.nLevelIndication          = _nLevelIndication;
				оДанные.nMaxNumberReferenceFrames = _nMaxNumberReferenceFrames;
				оДанные.чШиринаКартинки           = _чШиринаКартинки;
				оДанные.чВысотаКартинки           = _чВысотаКартинки;
				оДанные.чЧастотаКадров            = _чЧастотаКадров;
				оДанные.чДиапазон                 = _чДиапазон;
				оДанные.лЧересстрочное            = _лЧересстрочное;
				оДанные.nAudioObjectType          = _nAudioObjectType;
				оДанные.чЧастотаДискретизации     = _чЧастотаДискретизации;
				оДанные.чКоличествоКаналов        = _чКоличествоКаналов;
				мбуфПередать.push(оДанные.мбСегментИнициализации.buffer);
			}
			_оИсходныйСегмент.лРазрыв = _лРазрыв;
			м_Журнал.Вот(`Отправляю сегмент Разрыв=${_лРазрыв} Размер=${(оДанные.мбМедиасегмент.length / 1024 / 1024).toFixed(2)}мб`);
		}
		_оИсходныйСегмент.пДанные = оДанные;
		// Отправить журнал перед результатом, чтобы журнал попал в отчет если у получателя во время работы с результатом возникнет ошибка.
		м_Журнал.Отправить();
		ОтправитьРезультат(мбуфПередать);
	}


	function СостыковатьСегменты()
	// Может изменить _лРазрыв.
	{
		_чДлительностьПервогоВидеоСемпла = -1;
		if (_лРазрыв)
		{
			return;
		}

		var чОтклонениеВДВидео = 0, чПерекрытиеВДВидео = 1, чОтклонениеВДАудио = 0;
		if (!_дорВидео.Пусто())
		{
			чОтклонениеВДВидео = _дорВидео.чВДНачала - _чВДКонцаПредыдущегоВидеоСегмента;
			чПерекрытиеВДВидео = _дорВидео.чВДНачала - _чВДПоследнегоВидеоСемплаПредыдущегоВидеоСегмента;
		}
		if (!_дорАудио.Пусто())
		{
			чОтклонениеВДАудио = _дорАудио.чВДНачала - _чВДКонцаПредыдущегоАудиоСегмента;
		}

		// а) Время трансляции превысило 33 бита.
		// б) Twitch: Нарушен порядок следования сегментов.
		if (чПерекрытиеВДВидео <= 0
		// а) Время трансляции превысило 33 бита.
		// б) Twitch: Нарушен порядок следования сегментов.
		// в) Ошибка ПО трансляции.
		// Браузеры добавляют и воспроизводят перекрытые сегменты, но с рассинхронизацией видео и звука.
		|| чОтклонениеВДАудио < -TS_TIMESCALE * 0.100)
		{
			м_Журнал.Ой(`Добавлен разрыв: ОтклонениеВДВидео=${Мс(чОтклонениеВДВидео)} ПерекрытиеВДВидео=${Мс(чПерекрытиеВДВидео)} ОтклонениеВДАудио=${чОтклонениеВДАудио}`);
			_лРазрыв = true;
			return;
		}

		if (Math.abs(чОтклонениеВДВидео) > TS_TIMESCALE * 0.002 || Math.abs(чОтклонениеВДАудио) > 2)
		{
			м_Журнал.Ой(`ОтклонениеВДВидео=${Мс(чОтклонениеВДВидео)} ПерекрытиеВДВидео=${Мс(чПерекрытиеВДВидео)} ОтклонениеВДАудио=${чОтклонениеВДАудио}`);
		}

		// Изменение длительности первого видеосемпла обычно приводит к лишнему визуальному
		// подергиванию видео, поэтому не стоит изменять длительность "на всякий случай".
		// Firefox 52, 62: Если зазор между сегментами >= 500 мс, то в буфере проигрывателя могут
		// появиться невидимые ямы, приводящие к неожиданной остановке воспроизведения.
		if (чОтклонениеВДВидео > TS_TIMESCALE * 0.400)
		{
			_дорВидео.чВДНачала -= чОтклонениеВДВидео;
			if (_дорВидео.ПолучитьКоличествоСемплов() === 1)
			{
				м_Журнал.Ой('ВД единственного видеосемпла было уменьшено');
			}
			else
			{
				_чДлительностьПервогоВидеоСемпла = _dvКуча.getUint32(_дорВидео.уНачалоСемплов + ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА);
				_dvКуча.setUint32(_дорВидео.уНачалоСемплов + ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА,  _чДлительностьПервогоВидеоСемпла + чОтклонениеВДВидео);
				_чМинДлительностьВидеоСемпла  = Math.min(_чМинДлительностьВидеоСемпла,  _чДлительностьПервогоВидеоСемпла + чОтклонениеВДВидео);
				_чМаксДлительностьВидеоСемпла = Math.max(_чМаксДлительностьВидеоСемпла, _чДлительностьПервогоВидеоСемпла + чОтклонениеВДВидео);
				м_Журнал.Ой(`Длительность первого видеосемпла ${Мс(_чДлительностьПервогоВидеоСемпла)} была увеличена`);
			}
		}

		if (чОтклонениеВДАудио > TS_TIMESCALE * 0.100)
		{
			_лПотериЗвука = true;
		}
	}

	function РассчитатьДлительностьПоследнегоВидеосемпла()
	// Также меняет _чВДКонцаВидеоСегмента и _оВППоследнегоВидеосемплаПредыдущегоСегмента.
	// Вызывать после СостыковатьСегменты(), чтобы учесть изменение ВП первого видеосемпла,
	// и после РазобратьАудиоПоток(), чтобы использовать _чВДКонцаАудиоСегмента.
	{
		var кВидеосемплов = _дорВидео.ПолучитьКоличествоСемплов();
		if (кВидеосемплов === 0)
		{
			return;
		}

		var чДлительность;
		if (кВидеосемплов === 1)
		{
			чДлительность = _дорАудио.Пусто() ? Math.round(TS_TIMESCALE / 30) : _чВДКонцаАудиоСегмента - _дорАудио.чВДНачала;
		}
		else
		{
			var чМаксДлительность = Infinity;
			var уСемпл = _дорВидео.уКонецСемплов - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
			var чВД = 0;
			var чВППоследнегоВидеоСемпла = _dvКуча.getInt32(уСемпл + ВП_ВИДЕОСЕМПЛА);
			for (var ы = Math.min(16, кВидеосемплов); --ы !== 0;)
			{
				уСемпл -= РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА;
				чВД -= _dvКуча.getUint32(уСемпл + ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА);
				var чВП = чВД + _dvКуча.getInt32(уСемпл + ВП_ВИДЕОСЕМПЛА);
				if (чВП > чВППоследнегоВидеоСемпла)
				{
					чМаксДлительность = Math.min(чМаксДлительность, чВП - чВППоследнегоВидеоСемпла);
				}
			}
			// Если следующий сегмент начинается не с ключевого кадра, то между чВППоследнегоВидеоСемпла и
			// чВППоследнегоВидеоСемпла + чМаксДлительность может находиться семпл из следующего сегмента.
			// Поэтому нельзя увеличивать чДлительность до чМаксДлительность, можно только уменьшать.
			// Firefox 52, 62: Сегмент не будет добавлен, если предпоследний кадр полностью перекроет последний.
			// Нам нужна исходная длительность первого видеосемпла.
			чДлительность = Math.min(чМаксДлительность, _чДлительностьПервогоВидеоСемпла !== -1 ? _чДлительностьПервогоВидеоСемпла
				: _dvКуча.getUint32(_дорВидео.уКонецСемплов - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА * 2 + ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА));
		}

		м_Журнал[кВидеосемплов === 1 ? 'Ой' : 'Вот'](`Длительность последнего видеосемпла ${Мс(чДлительность)}`);
		_dvКуча.setUint32(_дорВидео.уКонецСемплов - РАЗМЕР_СТРУКТУРЫ_ВИДЕОСЕМПЛА + ДЛИТЕЛЬНОСТЬ_ВИДЕОСЕМПЛА, чДлительность);
		_чВДКонцаВидеоСегмента = _чВДПоследнегоВидеоСемпла + чДлительность;
	}


	function ПреобразоватьСегмент()
	{
		var чНачало = performance.now();
		_лРазрыв = _лРазрыв || _оИсходныйСегмент.лРазрыв;
		м_Журнал.Вот(`ПРЕОБРАЗУЮ СЕГМЕНТ ${_оИсходныйСегмент.чНомер} Разрыв=${_лРазрыв} Длительность=${_оИсходныйСегмент.чДлительность} Размер=${(_оИсходныйСегмент.пДанные.byteLength / 1024 / 1024).toFixed(2)}мб`);
		ОчиститьСтатистику();
		var лСегментПреобразован = false;
		var мбТранспортныйПоток = new Uint8Array(_оИсходныйСегмент.пДанные);
		try
		{
			м_Память.Выделить(мбТранспортныйПоток);
			if (РазобратьТранспортныйПоток(мбТранспортныйПоток))
			{
				СостыковатьСегменты();
				РазобратьМетаданные();
				лСегментПреобразован = РазобратьВидеоПоток() && РазобратьАудиоПоток();
				if (лСегментПреобразован)
				{
					РассчитатьДлительностьПоследнегоВидеосемпла();
				}
			}
		}
		catch (пИсключение)
		{
			if (пИсключение instanceof Error && пИсключение.message === 'БРАКОВАТЬ')
			{
				// Браковать сегменты приходится очень редко.
				м_Журнал.Ой(`Сегмент забракован: ${пИсключение.stack}`);
				ОчиститьСтатистику();
				_лЗабраковано = true;
			}
			else
			{
				throw пИсключение;
			}
		}
		// Сейчас в мбТранспортныйПоток, на который указывает пДанные, будет записан преобразованный сегмент и буфер станет
		// бесполезен для анализа ошибок. Перезаписываем пДанные, чтобы не отсылать буфер при возникновении ошибки.
		_оИсходныйСегмент.пДанные = null;
		if (лСегментПреобразован)
		{
			ОтправитьПреобразованныйСегмент(мбТранспортныйПоток);
		}
		else
		{
			ВыброситьВПомойку(мбТранспортныйПоток);
			ОтправитьПреобразованныйСегмент(null);
		}
		_лРазрыв = !лСегментПреобразован;
		_чВДПоследнегоВидеоСемплаПредыдущегоВидеоСегмента = _чВДПоследнегоВидеоСемпла;
		_чВДКонцаПредыдущегоВидеоСегмента = _чВДКонцаВидеоСегмента;
		_чВДКонцаПредыдущегоАудиоСегмента = _чВДКонцаАудиоСегмента;
		_чПреобразованЗа = performance.now() - чНачало;
	}

	function ОбработатьСменуСостояния()
	{
		м_Журнал.Вот(`ПРОПУСКАЮ СЕГМЕНТ ${_оИсходныйСегмент.чНомер} Состояние=${_оИсходныйСегмент.пДанные}`);
		if (_оИсходныйСегмент.пДанные !== СОСТОЯНИЕ_СМЕНА_ВАРИАНТА)
		{
			м_Память.Освободить();
		}
		м_Журнал.Отправить();
		ОтправитьРезультат();
		_лРазрыв = true;
	}

	function ОбработатьСообщение(пДанные)
	{
		_оИсходныйСегмент = пДанные;
		if (typeof _оИсходныйСегмент.пДанные === 'number')
		{
			ОбработатьСменуСостояния();
		}
		else
		{
			ПреобразоватьСегмент();
		}
		_оИсходныйСегмент = null;
	}

	function ОбработатьИсключение(пИсключение)
	{
		self.onmessage = null;
		_мНеобработанныеСообщения = null;
		// Ошибка могла возникнуть из-за нехватки памяти.
		м_Память.Освободить();
		м_Журнал.Отправить();
		ЗавершитьРаботуИОтправитьОтчет(пИсключение);
		// throw undefined пока не нужно.
	}

	self.onmessage = оСобытие =>
	{
		try
		{
			if (_мНеобработанныеСообщения !== null)
			{
				_мНеобработанныеСообщения.push(оСобытие.data);
				м_Журнал.Ой('Обработка сообщения отложена: компиляция не завершена');
				м_Журнал.Отправить();
			}
			else
			{
				ОбработатьСообщение(оСобытие.data);
			}
		}
		catch (пИсключение)
		{
			ОбработатьИсключение(пИсключение);
		}
	};

	self.onmessageerror = оСобытие =>
	{
		throw new Error(`Произошло событие ${оСобытие.type}`);
	};

	// Компилировать заранее пока загружаются сегменты.
	// См. м_Преобразователь.ПреобразоватьСледующийСегмент() в player.js.
	// HACK Chrome 71: new WebAssembly.Module() обрабатывается только основным компилятором
	// (Liftoff), и никогда оптимизирующим (TurboFan). Чтобы улучшить качество компилируемого
	// кода, приходится трахаться с асинхронной компиляцией.
	_оАссемблер.Компилировать()
	.then(() =>
	{
		м_Журнал.Вот(`Компиляция завершена: ${performance.now().toFixed()}мс Необработанных сообщений: ${_мНеобработанныеСообщения.length}`);
		while (_мНеобработанныеСообщения.length !== 0)
		{
			ОбработатьСообщение(_мНеобработанныеСообщения.shift());
		}
		_мНеобработанныеСообщения = null;
	})
	.catch(ОбработатьИсключение);
}
