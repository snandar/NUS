


'use strict';

const ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ       = 15000; // Миллисекунды.
const ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ = 15000; // Миллисекунды.
const ЗАГРУЖАТЬ_СПИСОК_СЕГМЕНТОВ_НЕ_ДОЛЬШЕ =  6000; // Миллисекунды.

const ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ = 1;
const ОБРАБОТКА_ЗАГРУЖАЕТСЯ   = 2;
const ОБРАБОТКА_ЗАГРУЖЕН      = 3;
const ОБРАБОТКА_ПРЕОБРАЗОВАН  = 4;

// Эти константы также определены в player.css и worker.js.
const СОСТОЯНИЕ_ЗАПУСК                 = 1;
const СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ      = 2; // Сегмент.пДанные
const СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ  = 3; // Сегмент.пДанные
const СОСТОЯНИЕ_ЗАГРУЗКА               = 4;
const СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ = 5;
const СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ        = 6;
const СОСТОЯНИЕ_ОСТАНОВКА              = 7;
const СОСТОЯНИЕ_ПОВТОР                 = 8; // Сегмент.пДанные
const СОСТОЯНИЕ_СМЕНА_ВАРИАНТА         = 9; // Сегмент.пДанные

// Эти константы также определены в player.css.
const ПОДПИСКА_ОБНОВЛЯЕТСЯ  = -1;
const ПОДПИСКА_НЕДОСТУПНА   = 0;
const ПОДПИСКА_НЕОФОРМЛЕНА  = 1;
const ПОДПИСКА_НЕУВЕДОМЛЯТЬ = 2;
const ПОДПИСКА_УВЕДОМЛЯТЬ   = 3;

const КОД_ОТВЕТА = 'Сервер вернул код ';

// Добавить к performance.now(), чтобы получить текущее время.
// Время на компе может быть неправильно установлено и может изменяться во время
// работы проигрывателя, поэтому вместо Date.now() используется performance.now().
let г_чТочноеВремя = NaN;
let г_чИдВкладки = NaN;

// Chrome 65-, Firefox 62-, Edge
if (!navigator.clipboard)
{
	navigator.clipboard = {};
}
if (!navigator.clipboard.writeText)
{
	// Chrome 67: Если открыто окно, которое запрашивает разрешение на доступ к буферу обмена,
	// то все вызовы методов navigator.clipboard ставятся в очередь. Они будут обслужены после
	// закрытия окна.
	navigator.clipboard.writeText = function(сТекст)
	{
		Проверить(typeof сТекст === 'string');
		return new Promise(ДобавитьОбработчикИсключений((фВыполнить, фОтказаться) =>
		{
			const узТекст = document.createElement('input');
			узТекст.type = 'text';
			// Нужен чтобы на планшете не вылезала клавиатура.
			узТекст.readOnly = true;
			узТекст.value = сТекст;
			узТекст.style.position = 'fixed';
			узТекст.style.left = '-100500px';
			document.body.appendChild(узТекст);
			узТекст.select();
			const лПолучилось = document.execCommand('copy');
			узТекст.remove();
			if (лПолучилось)
			{
				фВыполнить();
			}
			else
			{
				// Chrome 67 согласно текущей версии стандарта возвращает undefined.
				// Некоторые методы navigator.clipboard возвращают DOMException.
				фОтказаться();
			}
		}));
	};
}

function Текст(сКод, сПодстановка)
{
	return м_i18n.GetMessage(сКод, сПодстановка);
}

function Округлить(чЗначение, чТочность)
// чТочность - количество дробных знаков.
{
	Проверить(typeof чЗначение === 'number' && Number.isInteger(чТочность) && чТочность >= 0 && чТочность <= 20);
	if (чТочность === 0)
	{
		return Math.round(чЗначение);
	}
	const ч = Math.pow(10, чТочность);
	return Math.round(чЗначение * ч) / ч;
}

function Ограничить(чЗначение, чМинимум, чМаксимум)
{
	Проверить(Number.isFinite(чЗначение) && Number.isFinite(чМинимум) && Number.isFinite(чМаксимум) && чМинимум <= чМаксимум);
	return Math.min(Math.max(чЗначение, чМинимум), чМаксимум);
}

function StripHtmlTags(sText)
{
	Проверить(typeof sText === 'string');
	const elTemplate = document.createElement('template');
	// Commentary for AMO reviewers: <template> does not "load" or "execute" anything.
	elTemplate.innerHTML = sText;
	return elTemplate.content.textContent;
}

function ПреобразоватьРазметкуВТекст(сРазметка)
{
	Проверить(typeof сРазметка === 'string');
	сРазметка = сРазметка.replace(/[\t\r\n]/g, ' ').replace(/<\s*br[\s\/]*>/gi, '\n');
	сРазметка = StripHtmlTags(сРазметка);
	// Удаляет ведущие и конечные пробелы у всех строк. Удаляет пустые строки.
	сРазметка = сРазметка.replace(/^\s+|[^\S\r\n]+$/gm, '');
	return сРазметка.replace(/[^\S\r\n]{2,}/g, ' ');
}

function ResolveRelativeUrl(sRelativeUrl, sAbsoluteBaseUrl)
{
	return (new URL(sRelativeUrl, sAbsoluteBaseUrl)).href;
}

function РазобратьПараметры(оАдрес)
{
	// Edge 15 не поддерживает Location.searchParams и HTMLAnchorElement.searchParams.
	return оАдрес.searchParams || new URLSearchParams(оАдрес.search.slice(1));
}

function ИзменитьЗаголовокДокумента(сЗаголовок)
{
	document.title = сЗаголовок;
}


function ПолучитьApiРасширения(фВызвать)
{
	фВызвать(chrome);
}


function ОткрытьАдресВНовойВкладке(сАдрес)
{
	// Firefox 61: windows.open() может быть заблокировано как всплывающее окно.
	// Firefox 61: Если не указать openerTabId и index, то вкладка будет вставлена в конец списка.
	// Не все версии Firefox поддерживают openerTabId.
	// Edge 16: windows.open() и tabs.create() без index вставляют вкладку в конец списка.
	// Edge 16: openerTabId не влияет на положение вкладки.
	chrome.tabs.getCurrent(ДобавитьОбработчикИсключений(оВкладка =>
	{
		const оПараметры = {url: сАдрес};
		// HACK Edge 17: getCurrent() иногда возвращает фигню.
		if (ЭтоОбъект(оВкладка) && Number.isInteger(оВкладка.index) && оВкладка.index >= 0)
		{
			оПараметры.index = оВкладка.index + 1;
		}
		chrome.tabs.create(оПараметры);
	}));
}

function ЗаписатьТекстВЛокальныйФайл(сТекст, сТипДанных, сИмяФайла)
{
	Проверить(typeof сТекст === 'string' && ЭтоНепустаяСтрока(сТипДанных) && ЭтоНепустаяСтрока(сИмяФайла));
	const узСсылка = document.createElement('a');
	// Протокол data: оставляет в истории загрузок браузера сТекст. Не нужно нам таких подарочков.
	узСсылка.href = URL.createObjectURL(new Blob([сТекст], {type: сТипДанных}));
	узСсылка.download = сИмяФайла;
	// click() не работает пока ссылка не вставлена в документ.
	узСсылка.dispatchEvent(new MouseEvent('click'));
}

function ЭтоСобытиеДляСсылки(оСобытие)
{
	return !!оСобытие.target.closest('a[href]');
}

function ЭлементВЭтойТочкеМожноПрокрутить(x, y)
{
	for (let узЭлемент = document.elementFromPoint(x, y); узЭлемент; узЭлемент = узЭлемент.parentElement)
	{
		if (ЭтотЭлементМожноПрокрутить(узЭлемент))
		{
			return true;
		}
	}
	return false;
}

function ЭтотЭлементМожноПрокрутить(узЭлемент)
{
	const оСтиль = getComputedStyle(узЭлемент);
	return (оСтиль.overflowY === 'scroll' || оСтиль.overflowY === 'auto') && (узЭлемент.clientHeight < узЭлемент.scrollHeight);
}

function ЭлементПолностьюПрокручен(узЭлемент)
{
	// На всякий случай сравниваем не с 0. Из-за дробных rem возможны округления и нестыковки.
	return узЭлемент.scrollHeight - узЭлемент.scrollTop - узЭлемент.clientHeight < 2;
}

function ЭтотЭлементМожноВыделить(узЭлемент)
// Firefox 59: Вопреки стандарту, getComputedStyle() не учитывает значение родительских элементов. Делаем это самостоятельно.
// https://bugzilla.mozilla.org/show_bug.cgi?id=1328475
{
	do
	{
		const оСтиль = getComputedStyle(узЭлемент);
		const сЗначение = оСтиль.getPropertyValue('user-select') || оСтиль.getPropertyValue('-webkit-user-select') || оСтиль.getPropertyValue('-moz-user-select');
		Проверить(сЗначение);
		if (сЗначение !== 'auto')
		{
			return сЗначение !== 'none';
		}
	}
	while (узЭлемент = узЭлемент.parentElement);
	return true;
}

function ПоказатьЭлемент(пЭлемент, лПоказать)
// пЭлемент может являться SVG. У SVG нет атрибута и свойства hidden, элемент скроют CSS.
{
	const узЭлемент = Узел(пЭлемент);
	if (лПоказать)
	{
		узЭлемент.removeAttribute('hidden');
	}
	else
	{
		узЭлемент.setAttribute('hidden', '');
	}
	return узЭлемент;
}

function ЭлементПоказан(пЭлемент)
{
	return !Узел(пЭлемент).hasAttribute('hidden');
}

function ИзменитьКнопку(пКнопка, пСостояние)
{
	const узКнопка = Узел(пКнопка);
	// В пСостояние может быть логическое значение.
	const чСостояние = Number(пСостояние);
	const сузСостояния = узКнопка.getElementsByTagName('use');
	Проверить(чСостояние >= 0 && чСостояние < сузСостояния.length);
	for (let ы = 0; ы < сузСостояния.length; ++ы)
	{
		if (ы === чСостояние)
		{
			// Firefox 56: <title> и xlink:title не показывают всплывающую подсказку если находятся внутри <button>.
			// Edge 15: <title> иногда пропадает после автоскрытия панели.
			const сПодсказка = сузСостояния[ы].getAttributeNS('http://www.w3.org/1999/xlink', 'title');
			if (сПодсказка)
			{
				узКнопка.title = Текст(сПодсказка);
			}
			// Edge 15 падает если во время CSS transition программно менять xlink:href.
			сузСостояния[ы].removeAttribute('display');
		}
		else
		{
			сузСостояния[ы].setAttribute('display', 'none');
		}
	}
	return узКнопка;
}

const м_Отладка = (() =>
{
	let _сСписокВариантов = '';
	let _мСпискиСегментов = [];

	function ВставитьСсылкиДляСкачиванияФайлов(узФорма)
	{
	}

	function ПоказатьСтраницу()
	{
		try
		{
			м_ПолноэкранныйРежим.Отключить();
		}
		catch (_) {}

		document.body.textContent = '';
		for (let уз of document.querySelectorAll('link[rel="stylesheet"], style'))
		{
			уз.remove();
		}
		for (let уз of [document.documentElement, document.body])
		{
			уз.removeAttribute('class');
			уз.removeAttribute('style');
			уз.removeAttribute('hidden');
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			const уз = document.createElement('iframe');
			уз.style.position = 'fixed';
			уз.style.top      = '0';
			уз.style.left     = '0';
			уз.style.width    = '100%';
			уз.style.height   = '100%';
			уз.style.zIndex   = '100500';
			уз.style.border   = '0';
			уз.src = 'report.html';
			уз.addEventListener('load', () =>
			{
				м_i18n.TranslateDocument(уз.contentDocument);
				фВыполнить(уз.contentDocument);
			});
			document.body.appendChild(уз);
		});
	}

	function ПоказатьФорму(оДокумент, сИдентификаторФормы, лНастроитьФон)
	{
		if (лНастроитьФон)
		{
			// HACK Chrome 63+: Если повесить определение цвета фона на body, то у формы #отладка-сообщение
			// фон останется белым. Влияет на это центровка по вертикали и еще черт знает что.
			оДокумент.documentElement.classList.add(сИдентификаторФормы);
		}

		// Chrome 50-: Итераторы я добавил только для текущего контекста.
		// Edge 16: HTMLCollection из другого контекста (iframe) не работает в for...of.
		for (let сузПоказатьИлиСкрыть = оДокумент.forms, ы = 0, узПоказатьИлиСкрыть; узПоказатьИлиСкрыть = сузПоказатьИлиСкрыть[ы]; ++ы)
		{
			if (узПоказатьИлиСкрыть.id === сИдентификаторФормы)
			{
				ПоказатьЭлемент(узПоказатьИлиСкрыть, true);
				const узФокус = узПоказатьИлиСкрыть.querySelector('[autofocus]');
				if (узФокус)
				{
					узФокус.focus();
				}
			}
			else
			{
				ПоказатьЭлемент(узПоказатьИлиСкрыть, false);
			}
		}
	}

	function ПоказатьСообщение(сСообщение)
	{
		ПоказатьСтраницу()
		.then(оДокумент =>
		{
			оДокумент.getElementById('отладка-текстсообщения').textContent = сСообщение;
			ПоказатьФорму(оДокумент, 'отладка-сообщение', true);
		});
	}

	function ПоказатьИОтправитьОтчет(оОтчет, буфОтправить)
	{
		ПоказатьСтраницу()
		.then(оДокумент =>
		{
			let узФорма;
			if (оОтчет.ПричинаЗавершенияРаботы === 'ОТПРАВИТЬ ОТЗЫВ')
			{
				узФорма = оДокумент.getElementById('отладка-отзыв');
			}
			else
			{
				узФорма = оДокумент.getElementById('отладка-ошибка');
				ВставитьСсылкиДляСкачиванияФайлов(узФорма);
			}
			узФорма.elements["отладка-отчет"].value = JSON.stringify(оОтчет);
			ПоказатьФорму(оДокумент, узФорма.id, true);

			оДокумент.addEventListener('reset', оСобытие =>
			{
				оСобытие.preventDefault();
				window.location.reload();
			});

			let оЗапрос, оДанные, лПолучилось = false;
			// Нажимать кнопки можно клавишей ENTER.
			оДокумент.addEventListener('submit', оСобытие =>
			{
				оСобытие.preventDefault();
				switch (оСобытие.target.id)
				{
				case 'отладка-идетотправка':
					лПолучилось = true;
					// Синхронно вызывает обработчик события loadend.
					оЗапрос.abort();
					break;

				case 'отладка-сбойотправки':
					узФорма.querySelector('[type="submit"]').click();
					break;

				default:
					оДокумент.getElementById('отладка-ходотправки').value = 0;
					ПоказатьФорму(оДокумент, 'отладка-идетотправка', false);
		
					if (!оЗапрос)
					{
						оЗапрос = new XMLHttpRequest();
						оЗапрос.upload.addEventListener('progress', оСобытие =>
						{
							оДокумент.getElementById('отладка-ходотправки').value = оСобытие.loaded / оСобытие.total;
						});
						оЗапрос.addEventListener('load', оСобытие =>
						{
							лПолучилось = оСобытие.target.status >= 200 && оСобытие.target.status <= 299;
							// Ждем loadend.
						});
						оЗапрос.addEventListener('loadend', () =>
						{
							if (лПолучилось)
							{
								window.location.reload();
							}
							else
							{
								ПоказатьФорму(оДокумент, 'отладка-сбойотправки', false);
							}
						});

						оДанные = new FormData(оСобытие.target);
						if (буфОтправить)
						{
							оДанные.append('отладка-транспортныйпоток-0', new Blob([буфОтправить], {type: 'video/mp2t'}));
						}
					}

					оЗапрос.open('POST', 'http://r90354g8.beget.tech/tw5/report3.php');
					оЗапрос.send(оДанные);
				}
			});
		});
	}

	function СохранитьСписокВариантов(сСписокВариантов)
	{
		_сСписокВариантов = ОграничитьДлинуСтроки(сСписокВариантов, 15000);
	}

	function СохранитьСписокСегментов(сСписокСегментов)
	{
		if (_мСпискиСегментов.length === 3)
		{
			_мСпискиСегментов.shift();
		}
		_мСпискиСегментов.push(ОграничитьДлинуСтроки(сСписокСегментов, 15000));
	}

	function СохранитьТранспортныйПоток(оСегмент)
	{
	}

	function СохранитьПреобразованныйСегмент(оСегмент)
	{
	}

	function ОбнюхатьПроцессорИОперативку(фВызвать)
	{
		// Firefox 55 и Edge 15 не поддерживают browser.system.
		фВызвать();
	}

	function ОбнюхатьВидюху()
	{
		try
		{
			const oContext = document.createElement('canvas').getContext('webgl');
			const oExtension = oContext.getExtension('WEBGL_debug_renderer_info');
			return `${oContext.getParameter(oExtension.UNMASKED_VENDOR_WEBGL)} | ${oContext.getParameter(oExtension.UNMASKED_RENDERER_WEBGL)}`;
		}
		catch (_) {}
	}

	function ПолучитьЯзыки()
	{
		try
		{
			return `${navigator.language} | ${navigator.languages} | ${Текст('J0103')}`;
		}
		catch (_) {}
	}

	function ПолучитьУстановкиДаты()
	{
		try
		{
			const оУстановки = (new Intl.DateTimeFormat()).resolvedOptions();
			оУстановки.timezoneOffset = (new Date()).getTimezoneOffset();
			return оУстановки;
		}
		catch (_) {}
	}

	function СоздатьПоказатьИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить)
	{
		ОбнюхатьПроцессорИОперативку(пПроцессорИОперативка =>
		{
			ПоказатьИОтправитьОтчет(
				// В JSON не попадут свойства со значением undefined.
				{
					ПричинаЗавершенияРаботы:  сПричинаЗавершенияРаботы,
					ВерсияРасширения:         ВЕРСИЯ_РАСШИРЕНИЯ,
					Оборзеватель:             navigator.userAgent,
					Время:                    (new Date()).toISOString(),
					Рассинхронизация:         Date.now() - performance.now() - г_чТочноеВремя,
					Адрес:                    window.location.href,
					Инкогнито:                chrome.extension.inIncognitoContext,
					Языки:                    ПолучитьЯзыки(),
					Фокусник:                 м_Фокусник.ПолучитьСостояние(),
					Пульс:                    м_Пульс.ПолучитьДанныеДляОтчета(),
					Настройки:                м_Настройки.ПолучитьДанныеДляОтчета(),
					Статистика:               м_Статистика.ПолучитьДанныеДляОтчета(),
					УстановкиДаты:            ПолучитьУстановкиДаты(),
					Видюха:                   ОбнюхатьВидюху(),
					ПроцессорИОперативка:     пПроцессорИОперативка,
					Экран:
					{
						top:                  window.screen.top,
						left:                 window.screen.left,
						width:                window.screen.width,
						height:               window.screen.height,
						availTop:             window.screen.availTop,
						availLeft:            window.screen.availLeft,
						availWidth:           window.screen.availWidth,
						availHeight:          window.screen.availHeight,
						// Firefox 47 Windows: Возвращает реальные значения.
						// Chrome 51 Windows: Всегда возвращает 24.
						colorDepth:           window.screen.colorDepth,
						pixelDepth:           window.screen.pixelDepth,
						orientation:          typeof window.screen.orientation === 'object' ? window.screen.orientation.type : undefined,
						screenX:              window.screenX,
						screenY:              window.screenY,
						outerWidth:           window.outerWidth,
						outerHeight:          window.outerHeight,
						innerWidth:           window.innerWidth,
						innerHeight:          window.innerHeight,
						devicePixelRatio:     window.devicePixelRatio
					},
					СписокВариантов:          _сСписокВариантов,
					СпискиСегментов:          _мСпискиСегментов,
					Журнал:                   м_Журнал.ПолучитьДанныеДляОтчета()
				},
				буфОтправить
			);
		});
	}

	function ЗавершитьРаботуИПоказатьСообщение(сКодСообщения)
	{
		if (!г_лРаботаЗавершена)
		{
			console.error(сКодСообщения);
			ЗавершитьРаботу(false);
			ПоказатьСообщение(Текст(сКодСообщения));
		}
		throw undefined;
	}

	function ЗавершитьРаботуИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить)
	{
		if (!г_лРаботаЗавершена)
		{
			console.error(сПричинаЗавершенияРаботы);
			сПричинаЗавершенияРаботы = String(сПричинаЗавершенияРаботы);
			// Firefox 47 x86 + Windows + XUL: При нехватке памяти (commit) может кинуть исключение out of memory в player.js, worker.js и worker.onerror.
			// Chrome 52 x64 + Windows: При нехватке памяти (commit) процесс сразу падает.
			if (сПричинаЗавершенияРаботы.includes('out of memory'))
			{
				ЗавершитьРаботуИПоказатьСообщение('J0200');
			}
			try
			{
				м_Проигрыватель.ПоказатьСостояние('Вот', '[Отладка] Завершаю работу');
				г_моОчередь.ПоказатьСостояние();
			}
			catch (_) {}
			ЗавершитьРаботу(false);
			СоздатьПоказатьИОтправитьОтчет(сПричинаЗавершенияРаботы, буфОтправить);
		}
		throw undefined;
	}

	function ПойманоИсключение(пИсключение)
	{
		ЗавершитьРаботуИОтправитьОтчет(ПеревестиИсключениеВСтроку(пИсключение));
	}

	function ЗавершитьРаботуИОтправитьОтзыв()
	{
		try
		{
			ЗавершитьРаботуИОтправитьОтчет('ОТПРАВИТЬ ОТЗЫВ');
		}
		catch (_) {}
	}


	return {
		ПойманоИсключение,
		ЗавершитьРаботуИПоказатьСообщение, ЗавершитьРаботуИОтправитьОтчет, ЗавершитьРаботуИОтправитьОтзыв,
		СохранитьСписокВариантов, СохранитьСписокСегментов, СохранитьТранспортныйПоток, СохранитьПреобразованныйСегмент
	};
})();

//
// ОтменаОбещания
//

class ОтменаОбещания
{
	constructor()
	{
		this._лВыполняется = false; // Для отладки.
		this._фОбработчик = null;
	}

	НачалоВыполнения()
	{
		Проверить(!this._лВыполняется);
		this._лВыполняется = true;
	}

	Отменить()
	{
		this._лВыполняется = false;
		if (this._фОбработчик)
		{
			this._фОбработчик();
			this._фОбработчик = null;
		}
	}

	ЗаменитьОбработчик(фОбработчик)
	{
		Проверить(this._лВыполняется);
		Проверить(typeof фОбработчик === 'function' || фОбработчик === null);
		this._фОбработчик = фОбработчик;
	}
}

// TODO new DOMException('', 'AbortError') пока есть только в черновиках стандарта.
// Сообщение нам не нужно, поэтому используем более простой вариант.
ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО = new Error('ОБЕЩАНИЕ ОТМЕНЕНО');

function Ждать(ооОтменаОбещания, чМиллисекунды)
{
	Проверить(Number.isFinite(чМиллисекунды));
	чМиллисекунды = Math.round(чМиллисекунды);
	Проверить(чМиллисекунды >= 0 && чМиллисекунды <= 0x7fffffff);
	// Если чМиллисекунды == 0, то нельзя вместо setTimeout() вызывать Promise.resolve(),
	// потому что это помешает отменить обещание сразу после вызова Ждать().
	return new Promise((фВыполнить, фОтказаться) =>
	{
		const чТаймер = setTimeout(фВыполнить, чМиллисекунды);
		if (ооОтменаОбещания)
		{
			ооОтменаОбещания.ЗаменитьОбработчик(() =>
			{
				clearTimeout(чТаймер);
				фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
			});
		}
	});
}

//
// Сегмент
//

class Сегмент
{
	constructor(чОбработка, пДанные, чДлительность, лРазрыв, чНомер)
	{
		Проверить(typeof чОбработка === 'number' && чОбработка >= ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ && чОбработка <= ОБРАБОТКА_ПРЕОБРАЗОВАН);
		Проверить((typeof пДанные === 'number' && чОбработка >= ОБРАБОТКА_ЗАГРУЖЕН)
		       || (typeof пДанные === 'string' && чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ)
		       || (ЭтоОбъект(пДанные) && чОбработка > ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ));

		switch (arguments.length)
		{
		case 2:
			чДлительность = 0;
			лРазрыв = true;
			//
		case 4:
			Проверить(Number.isFinite(чДлительность) && чДлительность >= 0);
			Проверить(typeof лРазрыв === 'boolean');
			чНомер = ++Сегмент._чНомер;
			//
		case 5:
			Проверить(Number.isFinite(чНомер));
			break;

		default:
			Проверить(false);
		}

		if (typeof пДанные === 'number')
		{
			м_Журнал.Окак(`[Очередь] Добавлен сегмент ${чНомер} Состояние=${пДанные} Обработка=${чОбработка}`);
		}

		this.чОбработка = чОбработка;
		this.пДанные = пДанные;
		this.чДлительность = чДлительность;
		this.лРазрыв = лРазрыв;
		this.чНомер = чНомер;
	}

	toString()
	{
		if (typeof this.пДанные === 'number')
		{
			return `${this.чНомер}-${this.чОбработка}-${this.пДанные}`;
		}
		if (this.лРазрыв)
		{
			return `${this.чНомер}-${this.чОбработка}-Р`;
		}
		return `${this.чНомер}-${this.чОбработка}`;
	}
}

Сегмент._чНомер = 0;

//
// г_моОчередь
//

let г_моОчередь = [];

г_моОчередь.ПодсчитатьПреобразованныеСегменты = function()
{
	let кКоличество = 0, чДлительность = 0;
	for (; кКоличество < this.length && this[кКоличество].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН; ++кКоличество)
	{
		if (typeof this[кКоличество].пДанные !== 'number')
		{
			чДлительность += this[кКоличество].чДлительность;
		}
	}
	return {кКоличество, чДлительность};
};

г_моОчередь.Добавить = function(оСегмент)
{
	Проверить(оСегмент instanceof Сегмент);
	for (let о of this)
	{
		Проверить(о.чНомер !== оСегмент.чНомер);
	}
	if (оСегмент.чОбработка !== ОБРАБОТКА_ПРЕОБРАЗОВАН)
	{
		// Сегменты хранятся в очереди в порядке добавления, не в порядке обработки.
		this.push(оСегмент);
	}
	else
	{
		const {кКоличество, чДлительность} = this.ПодсчитатьПреобразованныеСегменты();
		// Сегменты воспроизводятся медленнее, чем загружаются. Возможные причины:
		// - Остановка воспроизведения из-за ошибки браузера после endOfStream().
		// - Chrome 57-58: Очень медленная работа appendBuffer() из-за ошибки браузера во время работы в фоновой вкладке.
		if (чДлительность > ПЕРЕПОЛНЕНИЕ_БУФЕРА * 1.5)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0208');
		}
		this.splice(кКоличество, 0, оСегмент);
	}
	return оСегмент;
};

г_моОчередь.Удалить = function(пЭлемент, кКоличество = 1)
{
	if (кКоличество === 0)
	{
		return;
	}
	Проверить(Number.isInteger(кКоличество) && кКоличество > 0);

	let чИндекс;
	if (typeof пЭлемент === 'number')
	{
		Проверить(Number.isInteger(пЭлемент) && пЭлемент >= 0);
		чИндекс = пЭлемент;
	}
	else if ((чИндекс = this.indexOf(пЭлемент)) === -1)
	{
		Проверить(пЭлемент instanceof Сегмент);
		return;
	}

	while (--кКоличество >= 0)
	{
		Проверить(чИндекс < this.length);

		switch (this[чИндекс].чОбработка)
		{
		case ОБРАБОТКА_ЗАГРУЖАЕТСЯ:
			if (ЭтоОбъект(this[чИндекс].пДанные))
			{
				м_Журнал.Вот(`[Очередь] Отменяю загрузку ${this[чИндекс]}`);
				this[чИндекс].пДанные.Отменить();
			}
			break;

		case ОБРАБОТКА_ЗАГРУЖЕН:
			м_Помойка.Выбросить(this[чИндекс].пДанные);
			break;

		case ОБРАБОТКА_ПРЕОБРАЗОВАН:
			if (ЭтоОбъект(this[чИндекс].пДанные))
			{
				м_Помойка.Выбросить(this[чИндекс].пДанные.мбСегментИнициализации);
				м_Помойка.Выбросить(this[чИндекс].пДанные.мбМедиасегмент);
			}
			break;
		}

		м_Журнал.Вот(`[Очередь] Удаляю ${this[чИндекс]}`);
		this.splice(чИндекс, 1);
	}
};

г_моОчередь.Очистить = function()
{
	this.Удалить(0, this.length);
};

г_моОчередь.ПоказатьСостояние = function()
{
	м_Журнал.Вот(`[Очередь] ${this.join(' ')}`);
};

//
// ВводЧисла
//

class ВводЧисла
{
	constructor(сИмяНастройки, чШаг, чТочность, сИдУзла)
	{
		Проверить(чТочность >= 0 && ЭтоНепустаяСтрока(сИдУзла));

		this._сИмяНастройки = сИмяНастройки;
		this._чШаг = чШаг;
		this._чТочность = чТочность;

		this._чДобавить = 0;
		this._кИнтервал = 0;
		this._чТаймер   = 0;

		м_События.ДобавитьОбработчик(`тащилка-перетаскивание-${сИдУзла}`, оПараметры => this._ОбработатьПеретаскивание(оПараметры));

		this._узЧисло = document.querySelector(`#${сИдУзла} > .вводчисла-число`);
		this.Обновить();
	}

	Обновить(чЗначение = м_Настройки.Получить(this._сИмяНастройки))
	// Вызвать, если настройка, к которой привязан объект, была изменена.
	{
		this._узЧисло.value = чЗначение === АВТОНАСТРОЙКА
			? Текст(м_Настройки.ПолучитьПараметрыНастройки(this._сИмяНастройки).сАвтонастройка)
			: м_i18n.ФорматироватьЧисло(чЗначение, this._чТочность);
	}

	_ОбработатьПеретаскивание(оПараметры)
	{
		const ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ = 130; // Миллисекунды.

		if (оПараметры.чШаг === 1)
		{
			this._чДобавить = оПараметры.узНажат.classList.contains('вводчисла-минус') ? -this._чШаг : this._чШаг;
			this._кИнтервал = 0;
			this._чТаймер = setInterval(() => this._ОбработатьТаймер(), ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ);
			this._ОбработатьТаймер();
		}

		if (оПараметры.чШаг === 3)
		{
			clearInterval(this._чТаймер);
		}
	}
}

ВводЧисла.prototype._ОбработатьТаймер = ДобавитьОбработчикИсключений(function()
{
	const ЗАДЕРЖКА_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ = 3; // Количество ИНТЕРВАЛ_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ.

	if (++this._кИнтервал === 1 || this._кИнтервал > ЗАДЕРЖКА_ИЗМЕНЕНИЯ_ЗНАЧЕНИЯ)
	{
		const оПараметрыНастройки = м_Настройки.ПолучитьПараметрыНастройки(this._сИмяНастройки);
		const чЗначение = м_Настройки.Получить(this._сИмяНастройки);
		let чНовоеЗначение;
		if ((оПараметрыНастройки.сАвтонастройка && this._чДобавить < 0 && чЗначение === оПараметрыНастройки.чМинимальное)
		||  (оПараметрыНастройки.сАвтонастройка && this._чДобавить > 0 && чЗначение === оПараметрыНастройки.чМаксимальное))
		{
			чНовоеЗначение = АВТОНАСТРОЙКА;
		}
		else if (чЗначение === АВТОНАСТРОЙКА && this._чДобавить > 0)
		{
			чНовоеЗначение = оПараметрыНастройки.чМинимальное;
		}
		else if (чЗначение === АВТОНАСТРОЙКА && this._чДобавить < 0)
		{
			чНовоеЗначение = оПараметрыНастройки.чМаксимальное;
		}
		else
		{
			чНовоеЗначение = чЗначение + this._чДобавить;
		}
		if (чНовоеЗначение !== АВТОНАСТРОЙКА)
		{
			чНовоеЗначение = Ограничить(Округлить(чНовоеЗначение, this._чТочность), оПараметрыНастройки.чМинимальное, оПараметрыНастройки.чМаксимальное);
		}
		if (чНовоеЗначение !== чЗначение)
		{
			м_Настройки.Изменить(this._сИмяНастройки, чНовоеЗначение);
			this.Обновить(чНовоеЗначение);
			this.ПослеИзменения(чНовоеЗначение);
		}
	}
});

ВводЧисла.prototype.ПослеИзменения = ЗАГЛУШКА;

const м_События = (() =>
{
	let _амОбработчики = new Map();

	function ДобавитьОбработчик(сСобытие, фОбработчик)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		Проверить(typeof фОбработчик === 'function' || ЭтоОбъект(фОбработчик));
		let мноОбработчикиСобытия = _амОбработчики.get(сСобытие);
		if (мноОбработчикиСобытия === undefined)
		{
			мноОбработчикиСобытия = new Set();
			_амОбработчики.set(сСобытие, мноОбработчикиСобытия);
		}
		мноОбработчикиСобытия.add(фОбработчик);
	}

	function УдалитьОбработчик(сСобытие, фОбработчик)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		Проверить(typeof фОбработчик === 'function' || ЭтоОбъект(фОбработчик));
		const мноОбработчикиСобытия = _амОбработчики.get(сСобытие);
		if (мноОбработчикиСобытия !== undefined)
		{
			мноОбработчикиСобытия.delete(фОбработчик);
			if (мноОбработчикиСобытия.size === 0)
			{
				_амОбработчики.delete(сСобытие);
			}
		}
	}

	function ПослатьСобытие(сСобытие, пДанные)
	{
		Проверить(ЭтоНепустаяСтрока(сСобытие));
		м_Журнал.Вот(`[События] Произошло событие ${сСобытие}`);
		const мноОбработчикиСобытия = _амОбработчики.get(сСобытие);
		if (мноОбработчикиСобытия !== undefined)
		{
			Проверить(мноОбработчикиСобытия.size !== 0);
			let оСобытие;
			for (let фОбработчик of мноОбработчикиСобытия.values())
			{
				if (typeof фОбработчик === 'function')
				{
					// сСобытие используется очень редко.
					фОбработчик(пДанные, сСобытие);
				}
				else
				{
					if (оСобытие === undefined)
					{
						оСобытие =
						{
							type: сСобытие,
							data: пДанные
						};
					}
					фОбработчик.handleEvent(оСобытие);
				}
			}
		}
	}

	return {
		ДобавитьОбработчик,
		УдалитьОбработчик,
		ПослатьСобытие
	};
})();

const м_Помойка = (() =>
{
	class ПомойкаВКаналеСообщений
	{
		constructor()
		{
			this._оПомойка = null;
		}

		Выбросить(оБарахло)
		// HACK Освобождение памяти посылкой transferable буфера в disentangled порт.
		// https://html.spec.whatwg.org/multipage/comms.html#dom-messageport-postmessage
		{
			if (ЭтоОбъект(оБарахло))
			{
				if (оБарахло.buffer)
				{
					оБарахло = оБарахло.buffer;
				}
				if (оБарахло.byteLength)
				{
					м_Журнал.Вот(`[Помойка] Выбрасываю ${оБарахло.byteLength} байтов`);
					if (this._оПомойка === null)
					{
						this._оПомойка = new MessageChannel();
						this._оПомойка.port2.close();
					}
					this._оПомойка.port1.postMessage(оБарахло, [оБарахло]);
				}
			}
		}

		Сжечь()
		{
			this._оПомойка = null;
		}
	}

	class ПомойкаВРабочемПотоке
	{
		constructor()
		{
			this._сАдрес = '';
			this._оПомойка = null;
			this._кбВПомойке = 0;
		}

		Выбросить(оБарахло)
		// HACK Для освобождение памяти transferable буфер посылается в рабочий поток, затем рабочий
		// поток уничтожается, что приводит к быстрому сбору всего мусора, который в нем накопился.
		{
			const ВМЕСТИМОСТЬ_ПОМОЙКИ = 10000000; // Байты.
			if (ЭтоОбъект(оБарахло))
			{
				if (оБарахло.buffer)
				{
					оБарахло = оБарахло.buffer;
				}
				if (оБарахло.byteLength)
				{
					м_Журнал.Вот(`[Помойка] Выбрасываю ${оБарахло.byteLength} байтов`);
					if (this._оПомойка === null)
					{
						if (this._сАдрес === '')
						{
							this._сАдрес = URL.createObjectURL(new Blob(
								[`
									'use strict';
									self.onmessage = оСобытие =>
									{
										if (!оСобытие.data)
										{
											self.close();
										}
									};
								`],
								{type: 'application/javascript'}
							));
						}
						this._оПомойка = new Worker(this._сАдрес);
					}
					this._кбВПомойке += оБарахло.byteLength;
					this._оПомойка.postMessage(оБарахло, [оБарахло]);
					if (this._кбВПомойке > ВМЕСТИМОСТЬ_ПОМОЙКИ)
					{
						this.Сжечь();
					}
				}
			}
		}

		Сжечь()
		{
			if (this._оПомойка !== null)
			{
				м_Журнал.Вот(`[Помойка] Сжигаю ${this._кбВПомойке} байтов`);
				// terminate() не подходит, нужно дождаться когда барахло попадет в рабочий поток.
				this._оПомойка.postMessage(null);
				this._оПомойка = null;
				this._кбВПомойке = 0;
			}
		}
	}

	class ПомойкаОтсутствует {}
	ПомойкаОтсутствует.prototype.Выбросить = ЗАГЛУШКА;
	ПомойкаОтсутствует.prototype.Сжечь = ЗАГЛУШКА;

	м_События.ДобавитьОбработчик('управление-изменилосьсостояние', чСостояние =>
	{
		if (чСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ || чСостояние === СОСТОЯНИЕ_ОСТАНОВКА || чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			м_Помойка.Сжечь();
		}
	});

	return ЭТО_ПЛАНШЕТ ? new ПомойкаОтсутствует() : new ПомойкаВКаналеСообщений();
})();

const м_Фокусник = (() =>
{
	let _оСостояние = ПолучитьНовоеСостояние();

	function ПолучитьСостояние()
	{
		return _оСостояние;
	}

	function ПолучитьНовоеСостояние()
	{
		const лПоказан = !document.hidden;
		const лАктивен = лПоказан && document.hasFocus();
		return {лПоказан, лАктивен};
	}

	const ОбработатьСобытие = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Вот(`[Фокусник] Событие ${оСобытие.type}, старое состояние ${м_Журнал.O(_оСостояние)}`);
		// HACK Chrome 65-: https://bugs.chromium.org/p/chromium/issues/detail?id=654908
		// HACK Firefox 60: Нужно дать браузеру время на разблокировку воспроизведения в м_Проигрыватель.Запустить().
		setImmediate(ОбновитьСостояние);
	});

	const ОбновитьСостояние = ДобавитьОбработчикИсключений(() =>
	{
		const оНовоеСостояние = ПолучитьНовоеСостояние();
		if (_оСостояние.лПоказан !== оНовоеСостояние.лПоказан || _оСостояние.лАктивен !== оНовоеСостояние.лАктивен)
		{
			м_Журнал.Окак(`[Фокусник] Новое состояние ${м_Журнал.O(оНовоеСостояние)}`);
			_оСостояние = оНовоеСостояние;
			м_События.ПослатьСобытие('фокусник-изменилосьсостояние', оНовоеСостояние);
		}
	});

	м_Журнал.Вот(`[Фокусник] Начальное состояние ${м_Журнал.O(_оСостояние)}`);
	document.addEventListener('visibilitychange', ОбработатьСобытие);
	window.addEventListener('focus', ОбработатьСобытие);
	window.addEventListener('blur', ОбработатьСобытие);

	return {ПолучитьСостояние};
})();

const м_Пульс = (() =>
{
	// Если вкладка неактивна и в ней не воспроизводится видео/звук, то интервал таймера округляется до ближайшей целой секунды.
	// Edge 16 и Chrome 49 не учитывают воспроизведение видео/звука. Firefox 52 только увеличивает до 1 секунды.
	const ИНТЕРВАЛ_ПРОВЕРКИ       = 970;
	const МИН_ОТКЛОНЕНИЕ_ВРЕМЕНИ  = -30;
	const МАКС_ОТКЛОНЕНИЕ_ВРЕМЕНИ = 200;
	const МАКС_ОТКЛОНЕНИЕ_ДАТЫ    = 40;

	let _чМаксимальноеОтклонение = 0;
	let _чТаймер = 0;
	let _чВремя;
	let _чДата;

	const ПроверитьПульс = ДобавитьОбработчикИсключений(() =>
	{
		const чВремя = performance.now();
		const чДата = Date.now();
		const чОтклонениеВремени = чВремя - _чВремя - ИНТЕРВАЛ_ПРОВЕРКИ;
		const чОтклонениеДаты = чДата - _чДата - (чВремя - _чВремя);
		if (чОтклонениеВремени < МИН_ОТКЛОНЕНИЕ_ВРЕМЕНИ || чОтклонениеВремени > МАКС_ОТКЛОНЕНИЕ_ВРЕМЕНИ || Math.abs(чОтклонениеДаты) > МАКС_ОТКЛОНЕНИЕ_ДАТЫ)
		{
			м_Журнал.Ой(`[Пульс] ${м_Журнал.F0(чОтклонениеВремени)} ${м_Журнал.F0(чОтклонениеДаты)}`);
		}
		_чМаксимальноеОтклонение = Math.max(_чМаксимальноеОтклонение, чОтклонениеВремени);
		_чВремя = чВремя;
		_чДата = чДата;
		_чТаймер = setTimeout(ПроверитьПульс, ИНТЕРВАЛ_ПРОВЕРКИ);
	});

	function ОбработатьИзменениеСостояния(чСостояние)
	{
		if (чСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ || чСостояние === СОСТОЯНИЕ_ОСТАНОВКА || чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			if (_чТаймер !== 0)
			{
				м_Журнал.Вот('[Пульс] Таймер остановлен');
				clearTimeout(_чТаймер);
				_чТаймер = 0;
			}
		}
		else
		{
			if (_чТаймер === 0)
			{
				м_Журнал.Вот('[Пульс] Таймер запущен');
				_чВремя = performance.now();
				_чДата = Date.now();
				_чТаймер = setTimeout(ПроверитьПульс, ИНТЕРВАЛ_ПРОВЕРКИ);
			}
		}
	}

	function ПолучитьДанныеДляОтчета()
	{
		return _чМаксимальноеОтклонение;
	}

	м_События.ДобавитьОбработчик('управление-изменилосьсостояние', ОбработатьИзменениеСостояния);

	return {ПолучитьДанныеДляОтчета};
})();

const м_Тащилка = (() =>
/***
Начало перетаскивания - первой нажата левая кнопка любого указателя.
Окончание перетаскивания - отпущена левая кнопка указателя, начавшего перетаскивание.
В любой момент времени может быть активно только одно перетаскивание.

Chrome 68, Firefox 61, Edge 17:
preventDefault() в обработчике события pointerdown отменяет следующие действия:
- перенос фокуса в щелкнутый фрейм
- выделение текста
- перетаскивание изображения и ссылки
- Firefox: селектор :active кнопки и ссылки
- автопрокрутка по СКМ
preventDefault() в обработчике события pointerdown НЕ отменяет следующие действия:
- click по ЛКМ
- contextmenu по ПКМ
- открытие ссылки по ЛКМ
- открытие ссылки по ПКМ
- жесты касания: выделение, контекстное меню, прокрутка, масштабирование
preventDefault() в обработчиках событий pointermove и pointerend ничего не отменяет.

Edge 17: preventDefault() в обработчике события mousemove, но не pointermove, отменяет следующие действия:
- перетаскивание изображения и ссылки

Chrome 49: preventDefault() в обработчике события mousemove (pointer events не поддерживаются) отменяет следующие действия:
- выделение текста
- перетаскивание изображения и ссылки

Chrome 69, Firefox 61: touch-action:none отменяет только жесты прокрутки и масштабирования.

TODO Если понадобится перетаскивать ссылку или изображение, то запретить контекстное меню касанием и перетаскивание мышью.
***/
{
	// Частота requestAnimationFrame() 144 Гц слишком высока для такой долгой
	// операции, как изменение размера фрейма с чатом.
	const МИН_ИНТЕРВАЛ_ПЕРЕТАСКИВАНИЯ = 45; // Миллисекунды.

	let _чИдУказателя = NaN;
	let _оПараметры = null; // Параметры модуля и обработчика события тащилка-перетаскивание.
	let _чВремяПоследнегоПеретаскивания;
	let _чНачальнаяX, _чНачальнаяY;
	let _чПоследняяX, _чПоследняяY;

	function Параметры(узНажат, узТащится)
	{
		this.узНажат      = узНажат;
		this.узТащится    = узТащится;
		this.чШаг         = 1;
		this.лОтмена      = false;
		this.лИзмениласьX = false;
		this.лИзмениласьY = false;
		this.чИзменениеX  = 0;
		this.чИзменениеY  = 0;
	}

	const ОбработатьPointerDown = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (!Number.isNaN(_чИдУказателя) || оСобытие.button !== ЛЕВАЯ_КНОПКА)
		{
			return;
		}

		if (оСобытие.target.nodeType !== Node.ELEMENT_NODE)
		{
			return;
		}

		const узНажат = оСобытие.target.closest('[data-тащилка]');
		if (узНажат === null)
		{
			return;
		}

		_чИдУказателя = оСобытие.pointerId;
		_оПараметры = new Параметры(узНажат, Узел(узНажат.getAttribute('data-тащилка')));
		_чВремяПоследнегоПеретаскивания = 0;
		_чНачальнаяX = _чПоследняяX = оСобытие.clientX;
		_чНачальнаяY = _чПоследняяY = оСобытие.clientY;

		м_Журнал.Окак(`[Тащилка] Начинаю перетаскивать ${_оПараметры.узТащится.id} X=${_чНачальнаяX} Y=${_чНачальнаяY} id=${_чИдУказателя} type=${оСобытие.pointerType} primary=${оСобытие.isPrimary}`);

		document.addEventListener('pointermove', ОбработатьPointerMove, ПАССИВНЫЙ_ОБРАБОТЧИК);
		document.addEventListener('pointerup', ОбработатьPointerUpИPointerCancel, ПАССИВНЫЙ_ОБРАБОТЧИК);
		document.addEventListener('pointercancel', ОбработатьPointerUpИPointerCancel);
		м_События.ДобавитьОбработчик('фокусник-изменилосьсостояние', ОбработатьПокиданиеВкладки);

		м_Меню.Закрыть(true);

		// Нельзя добавлять класс тащилка-перехват к узНажат и узТащится: они могут быть кнопками, внутри
		// которых стандартом запрещены интерактивные элементы. Придется задавать курсор скриптом.
		м_ПолноэкранныйРежим.ПолучитьЭлемент().style.setProperty('cursor', getComputedStyle(узНажат).cursor, 'important');
		м_ПолноэкранныйРежим.ПолучитьЭлемент().classList.add('тащилка-перехват');
		_оПараметры.узТащится.classList.add('тащилка');

		м_События.ПослатьСобытие(`тащилка-перетаскивание-${_оПараметры.узТащится.id}`, _оПараметры);
	});

	const ОбработатьPointerMove = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_чИдУказателя === оСобытие.pointerId)
		{
			if ((оСобытие.buttons & НАЖАТА_ЛЕВАЯ_КНОПКА) === 0)
			{
				ЗавершитьПеретаскивание('кнопка отпущена');
			}
			else
			{
				// Cобытие pointermove может посылаться с очень высокой частотой,
				// не давая процессору заниматься более важными вещами.
				const чВремя = performance.now();
				if (чВремя - _чВремяПоследнегоПеретаскивания >= МИН_ИНТЕРВАЛ_ПЕРЕТАСКИВАНИЯ)
				{
					_чВремяПоследнегоПеретаскивания = чВремя;

					_оПараметры.лИзмениласьX = _чПоследняяX !== оСобытие.clientX;
					_оПараметры.лИзмениласьY = _чПоследняяY !== оСобытие.clientY;
					if (_оПараметры.лИзмениласьX || _оПараметры.лИзмениласьY)
					{
						_чПоследняяX = оСобытие.clientX;
						_чПоследняяY = оСобытие.clientY;

						_оПараметры.чШаг = 2;
						_оПараметры.чИзменениеX = _чПоследняяX - _чНачальнаяX;
						_оПараметры.чИзменениеY = _чПоследняяY - _чНачальнаяY;
						м_События.ПослатьСобытие(`тащилка-перетаскивание-${_оПараметры.узТащится.id}`, _оПараметры);
					}
				}
			}
		}
	});

	const ОбработатьPointerUpИPointerCancel = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_чИдУказателя === оСобытие.pointerId)
		{
			ЗавершитьПеретаскивание(оСобытие.type);
		}
	});

	function ОбработатьПокиданиеВкладки({лАктивен})
	{
		if (!лАктивен)
		{
			ЗавершитьПеретаскивание('вкладка неактивна');
		}
	}

	function ОтменитьПеретаскивание(сИдУзла)
	{
		Проверить(сИдУзла === undefined || ЭтоНепустаяСтрока(сИдУзла));
		if (!Number.isNaN(_чИдУказателя) && (сИдУзла === undefined || сИдУзла === _оПараметры.узТащится.id))
		{
			_оПараметры.лОтмена = true;
			ЗавершитьПеретаскивание('операция отменена');
		}
	}

	function ЗавершитьПеретаскивание(сПричина)
	{
		if (_оПараметры.чШаг !== 3)
		{
			м_Журнал.Окак(`[Тащилка] Заканчиваю перетаскивание: ${сПричина} X=${_чПоследняяX} Y=${_чПоследняяY}`);

			_оПараметры.чШаг = 3;
			м_События.ПослатьСобытие(`тащилка-перетаскивание-${_оПараметры.узТащится.id}`, _оПараметры);

			м_ПолноэкранныйРежим.ПолучитьЭлемент().style.removeProperty('cursor');
			м_ПолноэкранныйРежим.ПолучитьЭлемент().classList.remove('тащилка-перехват');
			_оПараметры.узТащится.classList.remove('тащилка');

			document.removeEventListener('pointermove', ОбработатьPointerMove);
			document.removeEventListener('pointerup', ОбработатьPointerUpИPointerCancel);
			document.removeEventListener('pointercancel', ОбработатьPointerUpИPointerCancel);
			м_События.УдалитьОбработчик('фокусник-изменилосьсостояние', ОбработатьПокиданиеВкладки);

			_чИдУказателя = NaN;
			_оПараметры = null;
		}
	}

	// Firefox: preventDefault() совершает лишнее действие: отменяет анимацию нажатия кнопки (не работает селектор :active).
	// Firefox 61: preventDefault() не работает в расширениях: https://bugzilla.mozilla.org/show_bug.cgi?id=1484186
	document.addEventListener('pointerdown', ОбработатьPointerDown, ПАССИВНЫЙ_ОБРАБОТЧИК);

	return {ОтменитьПеретаскивание};
})();

const м_Оформление = (() =>
{
	const СЕЛЕКТОР_КНОПКИ_ЦВЕТА = 'input[type="color"]';

	let _сШаблон = '';
	let _оПрозрачность = null;

	const ОбработатьВводЦвета = ДобавитьОбработчикИсключений(оСобытие =>
	// Это событие посылает пока только Firefox.
	{
		if (оСобытие.target.matches(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			ОбновитьСтили();
		}
	});

	const ОбработатьИзменениеЦвета = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.matches(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			м_Настройки.Изменить(оСобытие.target.id, оСобытие.target.value);
		}
	});

	function ОбработатьИзменениеПредустановкиОформления()
	{
		ОбновитьОкноНастроек();
		ОбновитьСтили();
	}

	function ОбновитьОкноНастроек()
	{
		for (let узКнопка of document.querySelectorAll(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			узКнопка.value = м_Настройки.Получить(узКнопка.id);
		}
		_оПрозрачность.Обновить();
	}

	function ОбновитьСтили()
	{
		Проверить(_сШаблон);
		const оПеременные = {};
		оПеременные.чНепрозрачность = 1 - м_Настройки.Получить('чПрозрачность') / 100;
		оПеременные.чНепрозрачностьОкна = Ограничить(оПеременные.чНепрозрачность, 0.85, 1);
		for (let узКнопка of document.querySelectorAll(СЕЛЕКТОР_КНОПКИ_ЦВЕТА))
		{
			оПеременные[узКнопка.id] =
				Number.parseInt(узКнопка.value.slice(1, 3), 16) + ',' +
				Number.parseInt(узКнопка.value.slice(3, 5), 16) + ',' +
				Number.parseInt(узКнопка.value.slice(5, 7), 16);
		}
		document.getElementById('стиль').textContent = ЗаполнитьШаблон(_сШаблон, оПеременные);
	}

	function ЗаполнитьШаблон(сШаблон, оПеременные)
	{
		return сШаблон.replace(/{{.*?}}/g, сИмя =>
		{
			const пЗначение = оПеременные[сИмя.slice(2, -2)];
			if (typeof пЗначение === 'string')
			{
				return пЗначение;
			}
			Проверить(Number.isFinite(пЗначение));
			// 2 знака для opacity.
			return String(Округлить(пЗначение, 2));
		});
	}

	function Запустить()
	{
		_оПрозрачность = new ВводЧисла('чПрозрачность', 5, 0, 'прозрачность');
		_оПрозрачность.ПослеИзменения = ОбновитьСтили;

		document.addEventListener('input', ОбработатьВводЦвета);
		document.addEventListener('change', ОбработатьИзменениеЦвета);

		м_События.ДобавитьОбработчик('настройки-измениласьпредустановка-оформление', ОбработатьИзменениеПредустановкиОформления);
		ОбработатьИзменениеПредустановкиОформления();
	}

	function ЗапуститьАсинхронно()
	{
		return м_Загрузчик.ЗагрузитьТекст(null, chrome.extension.getURL('player.css'), 0, 'шаблон', false)
		.then(сРезультат =>
		{
			Проверить(!_сШаблон && сРезультат);
			_сШаблон = сРезультат;
		});
	}
	
	return {ЗапуститьАсинхронно, Запустить};
})();

const м_Статистика = (() =>
{
	const ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ  = 3;     // Количество обновлений в секунду.
	const РАЗМЕР_ИСТОРИИ_СПИСКА          = 30;    // Количество.
	const РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ        = 30;    // Количество.
	const РАЗМЕР_ИСТОРИИ_БУФЕРА          = 40;    // Количество.

	const ВЫДЕЛИТЬ_ИНТЕРВАЛ_ОБНОВЛЕНИЯ   = 150;   // Процент target duration.
	const ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО      = 0.33;  // Часть target duration.
	const ВЫДЕЛИТЬ_ОЖИДАНИЕ_ОТВЕТА       = 1.0;   // Секунды.
	const ВЫДЕЛИТЬ_ПРЕОБРАЗОВАНО         = 2;     // Количество преобразованных сегментов.
	const ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МИН    = 1.5;   // Секунды.
	const ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МАКС   = 0.5;   // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПРОПУЩЕННЫЕ_КАДРЫ     = 100;	  // Количество.
	const ВЫДЕЛИТЬ_ЧАСТОТУ_КАДРОВ        = 0.85;  // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_ОТН      = 1 / 5; // Отношение. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_АБС      = 300;   // Миллисекунды. TODO Подобрать подходящее значение.
	const ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА     = 5;     // Количество. TODO Подобрать подходящее значение.

	let _чТаймер                         = 0;
	let _nTargetDuration                 = 0;
	let _кСегментовВСписке               = 0;
	let _чМинДлительностьВидеосемпла     = -Infinity;
	let _чМаксДлительностьВидеосемпла    = +Infinity;
	let _оИнтервалОбновления             = null;
	let _оСегментовДобавлено             = null;
	let _оСекундДобавлено                = null;
	let _оТолщинаСегмента                = null;
	let _оТолщинаКанала                  = null;
	let _оОжиданиеОтвета                 = null;
	let _оНеПросмотрено                  = null;
	let _кИсходныхСегментов              = 0;
	let _кЗабракованныхСегментов         = 0;
	let _кбВсегоСкачано                  = 0;
	let _кОшибокЗагрузки                 = 0;
	let _кНезагруженныхСегментов         = 0;
	let _кПотерьВидео                    = 0;
	let _кПотерьЗвука                    = 0;
	let _кИсчерпанийБуфера               = 0;
	let _кИсчерпанийБуфераДосрочно       = 0;
	let _кПереполненийБуфера             = 0;
	let _чПропущеноВБуфере               = 0;

	let _чВремяПоследнегоОбновления;
	let _чНеПросмотреноСек;
	let _кНеПросмотреноСек;

	function ВыделитьИнтервалОбновления(чЧисло)
	{
		return чЧисло >= ВЫДЕЛИТЬ_ИНТЕРВАЛ_ОБНОВЛЕНИЯ;
	}
	
	function ВыделитьСегментовДобавлено(чЧисло)
	{
		return чЧисло === 0 || чЧисло > 2;
	}

	function ВыделитьОжиданиеОтвета(чЧисло)
	{
		return чЧисло >= ВЫДЕЛИТЬ_ОЖИДАНИЕ_ОТВЕТА;
	}

	function ВыделитьНеПросмотрено(чЧисло)
	{
		return чЧисло < ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МИН
		    || чЧисло >= м_Настройки.Получить('чМаксРазмерБуфера') + м_Настройки.Получить('чРастягиваниеБуфера') * ВЫДЕЛИТЬ_НЕ_ПРОСМОТРЕНО_МАКС;
	}

	class Анализ
	{
		constructor(сИдУзла, чРазмерИстории, чТочность)
		{
			Проверить(чРазмерИстории > 0 && чТочность >= 0);
			this._узТаблица = Узел(сИдУзла);
			this._мчИстория  = new Array(чРазмерИстории); // Кольцевой буфер.
			this._млВыделить = new Array(чРазмерИстории); // Кольцевой буфер.
			this._чТочность  = чТочность;
			this._Очистить();
		}

		Освободить()
		{
			this._узТаблица.textContent = '';
			this._узТаблица = null;
		}

		Очистить()
		{
			if (this._кЗаполнено !== 0)
			{
				this._Очистить();
			}
		}

		ПолучитьПоследнееЧисло(чЗаглушка)
		{
			return this._кЗаполнено === 0 ? чЗаглушка : this._мчИстория[this._чИндекс];
		}

		ДобавитьЧисло(чЧисло, пВыделить, пВыделитьСреднее)
		// чЧисло - добавляемое число в историю. Только значения Number.isFinite() будут показаны и будут принимать участие в расчетах.
		// пВыделить - выделить чЧисло. Простой тип или функция.
		// пВыделитьСреднее - выделить среднее, рассчитанное после добавления чЧисло. Простой тип или функция.
		// Возвращает среднее число.
		{
			const НАЧАЛО_ИСТОРИИ = 5;

			const лВыделить = Boolean(typeof пВыделить === 'function' ? пВыделить(чЧисло) : пВыделить);

			if (this._кЗаполнено !== 0)
			{
				this._узТаблица.children[НАЧАЛО_ИСТОРИИ + this._чИндекс].classList.add('статистика-подробно');
			}

			if (this._кЗаполнено !== this._мчИстория.length)
			{
				++this._кЗаполнено;
			}
			if (++this._чИндекс === this._мчИстория.length)
			{
				this._чИндекс = 0;
			}
			this._мчИстория[this._чИндекс] = чЧисло;
			this._млВыделить[this._чИндекс] = лВыделить;

			let чМинимальноеЧисло = Infinity, лВыделитьМинимальное = false;
			let чМаксимальноеЧисло = -Infinity, лВыделитьМаксимальное = false;
			let чСреднееЧисло = 0, кЧисел = 0;
			for (let ы = 0; ы < this._кЗаполнено; ++ы)
			{
				if (Number.isFinite(this._мчИстория[ы]))
				{
					if (this._мчИстория[ы] < чМинимальноеЧисло || (this._мчИстория[ы] === чМинимальноеЧисло && this._млВыделить[ы]))
					{
						чМинимальноеЧисло = this._мчИстория[ы];
						лВыделитьМинимальное = this._млВыделить[ы];
					}
					if (this._мчИстория[ы] > чМаксимальноеЧисло || (this._мчИстория[ы] === чМаксимальноеЧисло && this._млВыделить[ы]))
					{
						чМаксимальноеЧисло = this._мчИстория[ы];
						лВыделитьМаксимальное = this._млВыделить[ы];
					}
					чСреднееЧисло += this._мчИстория[ы];
					++кЧисел;
				}
			}

			let лВыделитьСреднее;
			if (кЧисел === 0)
			{
				чСреднееЧисло = NaN;
				лВыделитьСреднее = false;
			}
			else
			{
				чСреднееЧисло /= кЧисел;
				лВыделитьСреднее = Boolean(typeof пВыделитьСреднее === 'function' ? пВыделитьСреднее(чСреднееЧисло) : пВыделитьСреднее);
			}

			ОбновитьЗначение(this._узТаблица.children[0], this._ВСтроку(чМинимальноеЧисло),лВыделитьМинимальное);
			ОбновитьЗначение(this._узТаблица.children[2], this._ВСтроку(чСреднееЧисло), лВыделитьСреднее);
			ОбновитьЗначение(this._узТаблица.children[4], this._ВСтроку(чМаксимальноеЧисло), лВыделитьМаксимальное);
			ОбновитьЗначение(this._узТаблица.children[НАЧАЛО_ИСТОРИИ + this._чИндекс], this._ВСтроку(чЧисло), лВыделить)
			.classList.remove('статистика-подробно');

			return чСреднееЧисло;
		}

		_Очистить()
		{
			this._кЗаполнено = 0;
			this._чИндекс = -1;

			const узФрагмент = document.createDocumentFragment();
			узФрагмент.appendChild(document.createElement('td'))
			.className = 'анализ-минимум';
			узФрагмент.appendChild(document.createElement('td'))
			.textContent = '\u2009<\u2009';
			узФрагмент.lastChild.className = 'статистика-символ';
			узФрагмент.appendChild(document.createElement('td'))
			.className = 'анализ-среднее';
			узФрагмент.appendChild(document.createElement('td'))
			.textContent = '\u2009<\u2009';
			узФрагмент.lastChild.className = 'статистика-символ';
			узФрагмент.appendChild(document.createElement('td'))
			.className = 'анализ-максимум';
			for (let ы = this._мчИстория.length; --ы >= 0;)
			{
				узФрагмент.appendChild(document.createElement('td'))
				.className = 'анализ-история статистика-подробно';
			}
			this._узТаблица.textContent = '';
			this._узТаблица.appendChild(узФрагмент);
		}

		_ВСтроку(чЧисло)
		{
			// Не использовать пустую строку, чтобы не сработал селектор :empty.
			return Number.isFinite(чЧисло) ? чЧисло.toFixed(this._чТочность) : '\u00A0';
		}
	}

	function ОбновитьЗначение(пЭлемент, пЗначение, лВыделить)
	{
		const узЭлемент = Узел(пЭлемент);
		узЭлемент.classList.toggle('статистика-выделить', лВыделить);
		узЭлемент.textContent = пЗначение;
		return узЭлемент;
	}

	function ПолучитьНазваниеПрофиляH264(nProfileIndication, nConstraintSetFlag)
	// ITU-T H.264:2014 A.2 Profiles
	{
		switch (nProfileIndication)
		{
			case 66: return (nConstraintSetFlag & 0x40) === 0 ? 'Baseline' : 'Constrained Baseline'; // constraint_set1_flag
			case 77: return 'Main';
			case 88: return 'Extended';
			case 100:
				switch (nConstraintSetFlag & 0x0C)
				{
					case 0x08: return 'Progressive High'; // constraint_set4_flag
					case 0x0C: return 'Constrained High'; // constraint_set4_flag | constraint_set5_flag
				}
				return 'High';
			case 110: return (nConstraintSetFlag & 0x10) === 0 ? 'High 10' : 'High 10 Intra'; // constraint_set3_flag
			case 122: return (nConstraintSetFlag & 0x10) === 0 ? 'High 4:2:2' : 'High 4:2:2 Intra'; // constraint_set3_flag
			case 244: return (nConstraintSetFlag & 0x10) === 0 ? 'High 4:4:4 Predictive' : 'High 4:4:4 Intra'; // constraint_set3_flag
			case 44:  return 'CAVLC 4:4:4 Intra';
		}
		м_Журнал.Ой(`[Статистика] Неизвестный профиль H.264 ProfileIndication=${nProfileIndication} ConstraintSetFlag=${nConstraintSetFlag}`);
		return `P${nProfileIndication}C${nConstraintSetFlag}`;
	}

	function ОбновитьСтатистику()
	{
		document.getElementById('статистика-длительностьпросмотра').textContent = м_i18n.ПеревестиСекундыВСтроку(performance.now() / 1000, true);

		const {droppedVideoFrames, totalVideoFrames} = м_Проигрыватель.ПолучитьКоличествоПропущенныхКадров();
		ОбновитьЗначение('статистика-пропущено', droppedVideoFrames, droppedVideoFrames >= ВЫДЕЛИТЬ_ПРОПУЩЕННЫЕ_КАДРЫ)
		.nextElementSibling.nextElementSibling.textContent = totalVideoFrames;

		let чЖдетЗагрузки = 0, чЗагружается = 0, кПреобразовано = 0, чПреобразовано = 0;
		for (let оСегмент of г_моОчередь)
		{
			switch (оСегмент.чОбработка)
			{
			case ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ:
				чЖдетЗагрузки += оСегмент.чДлительность;
				break;
				
			case ОБРАБОТКА_ЗАГРУЖАЕТСЯ:
			case ОБРАБОТКА_ЗАГРУЖЕН:
				чЗагружается += оСегмент.чДлительность;
				break;

			case ОБРАБОТКА_ПРЕОБРАЗОВАН:
				кПреобразовано += 1;
				чПреобразовано += оСегмент.чДлительность;
				break;

			default:
				Проверить(false);
			}
		}

		const {чПросмотрено, чНеПросмотрено} = м_Проигрыватель.ПолучитьЗаполненностьБуфера();

		let уз = ОбновитьЗначение('статистика-очередь', чЖдетЗагрузки.toFixed(1), чЖдетЗагрузки > м_Настройки.Получить('чМаксРазмерБуфера'));
		уз = уз.nextElementSibling.nextElementSibling;
		уз.textContent = чЗагружается.toFixed(1);
		уз = уз.nextElementSibling;
		ОбновитьЗначение(уз, чПреобразовано.toFixed(1), кПреобразовано >= ВЫДЕЛИТЬ_ПРЕОБРАЗОВАНО);
		уз = уз.nextElementSibling;
		ОбновитьЗначение(уз, чНеПросмотрено.toFixed(1), ВыделитьНеПросмотрено(чНеПросмотрено));
		уз = уз.nextElementSibling.nextElementSibling;
		уз.textContent = чПросмотрено.toFixed(1);

		if ([СОСТОЯНИЕ_ЗАГРУЗКА, СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ, СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ].includes(м_Управление.ПолучитьСостояние()))
		{
			_чНеПросмотреноСек = Math.min(_чНеПросмотреноСек, чНеПросмотрено);
			_кНеПросмотреноСек = (_кНеПросмотреноСек + 1) % ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ;
			if (_кНеПросмотреноСек === 0)
			{
				_оНеПросмотрено.ДобавитьЧисло(_чНеПросмотреноСек, ВыделитьНеПросмотрено, ВыделитьНеПросмотрено);
				_чНеПросмотреноСек = Infinity;
			}
		}
	}

	function ОкноПоказано()
	{
		return _чТаймер !== 0;
	}

	function ОткрытьОкно()
	{
		if (ОкноПоказано())
		{
			return;
		}

		_оИнтервалОбновления = new Анализ('статистика-интервалобновления', РАЗМЕР_ИСТОРИИ_СПИСКА,   0);
		_оСегментовДобавлено = new Анализ('статистика-сегментовдобавлено', РАЗМЕР_ИСТОРИИ_СПИСКА,   0);
		_оСекундДобавлено    = new Анализ('статистика-секунддобавлено',    РАЗМЕР_ИСТОРИИ_СПИСКА,   1);
		_оТолщинаСегмента    = new Анализ('статистика-толщинасегмента',    РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оТолщинаКанала      = new Анализ('статистика-толщинаканала',      РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оОжиданиеОтвета     = new Анализ('статистика-ожиданиеответа',     РАЗМЕР_ИСТОРИИ_ЗАГРУЗКИ, 1);
		_оНеПросмотрено      = new Анализ('статистика-непросмотрено',      РАЗМЕР_ИСТОРИИ_БУФЕРА,   1);

		_чВремяПоследнегоОбновления = NaN;
		_чНеПросмотреноСек = Infinity;
		_кНеПросмотреноСек = 0;

		//
		// Вывод редко изменяемых показаний.
		//
		Узел('статистика-исходных').textContent = _кИсходныхСегментов;
		ОбновитьЗначение('статистика-забракованных', _кЗабракованныхСегментов, _кЗабракованныхСегментов !== 0);
		ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки, _кОшибокЗагрузки !== 0)
		.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов;
		ОбновитьЗначение('статистика-потерьвидео', _кПотерьВидео, _кПотерьВидео !== 0);
		ОбновитьЗначение('статистика-потерьзвука', _кПотерьЗвука, _кПотерьЗвука !== 0);
		ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера, _кИсчерпанийБуфера >= ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА);
		ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера, _кПереполненийБуфера !== 0)
		.nextElementSibling.nextElementSibling.textContent = _чПропущеноВБуфере.toFixed(1);

		_чТаймер = setInterval(ДобавитьОбработчикИсключений(ОбновитьСтатистику), 1000 / ЧАСТОТА_ОБНОВЛЕНИЯ_СТАТИСТИКИ);
		ОбновитьСтатистику();

		м_События.ДобавитьОбработчик('тащилка-перетаскивание-статистика', ОбработатьПеретаскиваниеОкна);

		ПоказатьЭлемент('статистика', true);
		м_Настройки.Изменить('лПоказатьСтатистику', true);
	}

	function ЗакрытьОкно()
	{
		if (!ОкноПоказано())
		{
			return;
		}

		ПоказатьЭлемент('статистика', false);

		_оИнтервалОбновления.Освободить(); _оИнтервалОбновления = null;
		_оСегментовДобавлено.Освободить(); _оСегментовДобавлено = null;
		_оСекундДобавлено.Освободить();    _оСекундДобавлено    = null;
		_оТолщинаСегмента.Освободить();    _оТолщинаСегмента    = null;
		_оТолщинаКанала.Освободить();      _оТолщинаКанала      = null;
		_оОжиданиеОтвета.Освободить();     _оОжиданиеОтвета     = null;
		_оНеПросмотрено.Освободить();      _оНеПросмотрено      = null;

		for (let уз of document.querySelectorAll('[data-очистить]'))
		{
			уз.textContent = '';
		}

		clearInterval(_чТаймер);
		_чТаймер = 0;

		м_Настройки.Изменить('лПоказатьСтатистику', false);
	}

	function ОбработатьПеретаскиваниеОкна(оПараметры)
	{
		switch (оПараметры.чШаг)
		{
		case 1:
			const оСтиль = getComputedStyle(оПараметры.узТащится);
			оПараметры._чНачальнаяX = Number.parseInt(оСтиль.left, 10);
			оПараметры._чНачальнаяY = Number.parseInt(оСтиль.top,  10);
			break;

		case 2:
			оПараметры.узТащится.style.setProperty('--x', `${оПараметры._чНачальнаяX + оПараметры.чИзменениеX}px`);
			оПараметры.узТащится.style.setProperty('--y', `${оПараметры._чНачальнаяY + оПараметры.чИзменениеY}px`);
			break;

		case 3:
			break;

		default:
			Проверить(false);
		}
	}

	function Запустить()
	{
		if (м_Настройки.Получить('лПоказатьСтатистику'))
		{
			ОткрытьОкно();
		}
	}

	function ОчиститьИсторию()
	// Вызвать после изменения настроек, которые влияют на загрузку сегментов.
	{
		if (_оИнтервалОбновления !== null)
		{
			_оИнтервалОбновления.Очистить();
			_оСегментовДобавлено.Очистить();
			_оСекундДобавлено.Очистить();
			_оТолщинаСегмента.Очистить();
			_оТолщинаКанала.Очистить();
			_оОжиданиеОтвета.Очистить();
			_оНеПросмотрено.Очистить();

			_чВремяПоследнегоОбновления = NaN;
			_чНеПросмотреноСек = Infinity;
			_кНеПросмотреноСек = 0;
		}

		ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки = 0, false)
		.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов = 0;
		ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера = 0, false);
		ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера = 0, false)
		.nextElementSibling.nextElementSibling.textContent = (_чПропущеноВБуфере = 0).toFixed(1);
	}

	function ПолучитьTargetDuration()
	{
		return _nTargetDuration;
	}

	function ПолучитьДлительностьКадраВСекундах()
	// Часто в исходном видео длительность кадров округлена до целых миллисекунд.
	{
		return {
			// Edge 15: Минимальные интервалы для перемотки: -17 мс и +16 мс.
			чМинимальная: Math.max(17, _чМинДлительностьВидеосемпла) / 1000,
			чМаксимальная: Math.min(1000 / 25, _чМаксДлительностьВидеосемпла) / 1000
		};
	}

	function ПолучитьДанныеДляОтчета()
	{
		return {
			ПараметрыВидео:           Узел('статистика-разрешениевидео').textContent + ' ' + Узел('статистика-сжатиевидео').textContent,
			ПараметрыЗвука:           Узел('статистика-сжатиезвука').textContent,
			ЗабракованныхСегментов:   _кЗабракованныхСегментов,
			ОшибокЗагрузки:           _кОшибокЗагрузки,
			НезагруженныхСегментов:   _кНезагруженныхСегментов,
			ПотерьВидео:              _кПотерьВидео,
			ПотерьЗвука:              _кПотерьЗвука,
			ИсчерпанийБуфера:         _кИсчерпанийБуфера,
			ИсчерпанийБуфераДосрочно: _кИсчерпанийБуфераДосрочно,
			ПереполненийБуфера:       _кПереполненийБуфера,
			ПропущеноВБуфере:         _чПропущеноВБуфере
		};
	}

	function РазобранСписокСегментов(оСписок, чДлительностьСписка)
	{
		if (ОкноПоказано())
		{
			if (оСписок.моСегменты.length !== 0)
			{
				Узел('статистика-сервер').textContent = (new URL(оСписок.моСегменты[0].сАдрес)).host;
			}
			const уз = Узел('статистика-список');
			уз.textContent = `${оСписок.моСегменты.length} × ${(чДлительностьСписка / оСписок.моСегменты.length).toFixed(1)} = ${чДлительностьСписка.toFixed(1)}`;
			ОбновитьЗначение(уз.nextElementSibling.nextElementSibling, оСписок.nTargetDuration, оСписок.nTargetDuration !== _nTargetDuration);
		}
		_nTargetDuration = оСписок.nTargetDuration;
		_кСегментовВСписке = оСписок.моСегменты.length;
	}

	function ДобавленыСегментыВОчередь(кСегментовДобавлено, кСекундДобавлено)
	{
		if (ОкноПоказано())
		{
			// Рассчитываем интервал после получения списка сегментов, а не перед получением,
			// чтобы продолжительность получения была отражена в статистике.
			const чВремя = performance.now();
			_оИнтервалОбновления.ДобавитьЧисло((чВремя - _чВремяПоследнегоОбновления) / _nTargetDuration / 10,
				ВыделитьИнтервалОбновления, ВыделитьИнтервалОбновления);
			_чВремяПоследнегоОбновления = чВремя;

			const чВСреднемСегментовДобавлено = _оСегментовДобавлено.ДобавитьЧисло(кСегментовДобавлено,
				ВыделитьСегментовДобавлено, ВыделитьСегментовДобавлено);

			_оСекундДобавлено.ДобавитьЧисло(кСекундДобавлено,
				кСекундДобавлено / кСегментовДобавлено < _nTargetDuration * ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО,
				чЧисло => чЧисло / чВСреднемСегментовДобавлено < _nTargetDuration * ВЫДЕЛИТЬ_СЕКУНД_ДОБАВЛЕНО
			);
		}
	}

	function ПолученИсходныйСегмент()
	{
		++_кИсходныхСегментов;
		if (ОкноПоказано())
		{
			document.getElementById('статистика-исходных').textContent = _кИсходныхСегментов;
		}
	}

	function ЗабракованСегмент()
	{
		++_кЗабракованныхСегментов;
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-забракованных', _кЗабракованныхСегментов, true);
		}
	}

	function СкачаноНечто(кбСкачано)
	{
		if (Number.isFinite(кбСкачано))
		{
			_кбВсегоСкачано += кбСкачано;
			if (ОкноПоказано())
			{
				document.getElementById('статистика-скачано').textContent = (_кбВсегоСкачано / 1024 / 1024).toFixed();
			}
		}
	}

	function ЗагруженСегмент(чРазмерСегмента, чДлительностьСегмента, чДлительностьЗагрузки, чОжиданиеОтвета)
	{
		if (ОкноПоказано())
		{
			const чСредняяТолщинаСегмента = _оТолщинаСегмента.ДобавитьЧисло(чРазмерСегмента * 8 / 1000000 / чДлительностьСегмента);

			чДлительностьЗагрузки /= 1000;
			_оТолщинаКанала.ДобавитьЧисло(
				чРазмерСегмента * 8 / 1000000 / чДлительностьЗагрузки,
				чДлительностьЗагрузки > чДлительностьСегмента,
				чЧисло => чЧисло < чСредняяТолщинаСегмента
			);

			_оОжиданиеОтвета.ДобавитьЧисло(чОжиданиеОтвета / 1000, ВыделитьОжиданиеОтвета, ВыделитьОжиданиеОтвета);
		}
	}

	function НеЗагруженыСегменты(кНезагруженныхСегментов)
	{
		Проверить(кНезагруженныхСегментов > 0);
		_кОшибокЗагрузки += 1;
		_кНезагруженныхСегментов += кНезагруженныхСегментов;
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-незагружено', _кОшибокЗагрузки, true)
			.nextElementSibling.nextElementSibling.textContent = _кНезагруженныхСегментов;
		}
	}

	function ПолученПреобразованныйСегмент(оСегмент)
	{
		const лОкноПоказано = ОкноПоказано();
		const оДанные = оСегмент.пДанные;
	
		if (оДанные.hasOwnProperty('мбМедиасегмент'))
		{
			if (оСегмент.лРазрыв)
			{
				if (оДанные.лЕстьВидео)
				{
					let сСжатиеВидео = 'H.264'
						+ `\u2002${ПолучитьНазваниеПрофиляH264(оДанные.nProfileIndication, оДанные.nConstraintSetFlag)}`
						+ `\u2002L${(оДанные.nLevelIndication / 10).toFixed(1)}`
						+ `\u2002RF${оДанные.nMaxNumberReferenceFrames}`;
					if (оДанные.чДиапазон !== -1)
					{
						сСжатиеВидео += оДанные.чДиапазон === 0 ? '\u200216-235' : '\u20020-255';
					}
					if (оДанные.лЧересстрочное)
					{
						сСжатиеВидео += '\u2002чересстрочное';
					}
					if (оДанные.чЧастотаКадров !== 0)
					{
						// Иногда чЧастотаКадров равна 1000 при фактической 60.
						сСжатиеВидео += `\u2002${оДанные.чЧастотаКадров < 0 ? '≈' : ''}${Math.abs(оДанные.чЧастотаКадров).toFixed(2)} ${Текст('J0140')}`;
					}
					Узел('статистика-сжатиевидео').textContent = сСжатиеВидео;
					Узел('статистика-разрешениевидео').textContent = `${оДанные.чШиринаКартинки}x${оДанные.чВысотаКартинки}`;
				}
				else
				{
					Узел('статистика-сжатиевидео').textContent = '\u2014';
					Узел('статистика-разрешениевидео').textContent = '\u2014';
				}
				Узел('статистика-частотакадров').textContent = '';

				if (оДанные.лЕстьЗвук)
				{
					Узел('статистика-сжатиезвука').textContent = ['AAC-Main', 'AAC-LC', 'AAC-SSR', 'AAC-LTP'][оДанные.nAudioObjectType - 1]
						+ `\u2002${оДанные.чЧастотаДискретизации} ${Текст('J0141')}`
						+ `\u2002${оДанные.чКоличествоКаналов} ${Текст('J0142')}`;
				}
				else
				{
					Узел('статистика-сжатиезвука').textContent = '\u2014';
				}
				Узел('статистика-битрейтзвука').textContent = '';
			}

			if (Number.isFinite(оДанные.чСредняяДлительностьВидеоСемпла))
			{
				_чМинДлительностьВидеосемпла = оДанные.чМинДлительностьВидеоСемпла;
				_чМаксДлительностьВидеосемпла = оДанные.чМаксДлительностьВидеоСемпла;
				Проверить(_чМинДлительностьВидеосемпла <= _чМаксДлительностьВидеосемпла);

				// TODO Для нахождения потери кадров среднее арифметическое можно заменить на медиану, которая более
				// преближена к исходной частоте кадров. Но нагружать процессор сортировкой не хочется.
				const чОтносительноеОтклонение = оДанные.чСредняяДлительностьВидеоСемпла / оДанные.чМаксДлительностьВидеоСемпла;
				const чАбсолютноеОтклонение = оДанные.чМаксДлительностьВидеоСемпла - оДанные.чСредняяДлительностьВидеоСемпла;
				if (чОтносительноеОтклонение <= ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_ОТН && чАбсолютноеОтклонение >= ВЫДЕЛИТЬ_ПОТЕРЮ_ВИДЕО_АБС)
				{
					м_Журнал.Ой(`[Статистика] Превышено отклонение длительности кадра в сегменте ${оСегмент.чНомер}`
						+ ` СредняяДлительностьКадра=${м_Журнал.F0(оДанные.чСредняяДлительностьВидеоСемпла)}мс`
						+ ` АбсолютноеОтклонение=${м_Журнал.F0(чАбсолютноеОтклонение)}мс`
						+ ` ОтносительноеОтклонение=${м_Журнал.F2(чОтносительноеОтклонение)}`);
					оДанные.лПотериВидео = true;
				}

				if (лОкноПоказано)
				{
					let сОтклонение = `@${(1000 / оДанные.чСредняяДлительностьВидеоСемпла).toFixed(1)}`;
					// Часто длительность кадров округляют до целых миллисекунд.
					if (оДанные.чМаксДлительностьВидеоСемпла - оДанные.чМинДлительностьВидеоСемпла > 2)
					{
						сОтклонение += `\u2002−${(100 - оДанные.чСредняяДлительностьВидеоСемпла / оДанные.чМаксДлительностьВидеоСемпла * 100).toFixed()}%`
						             + `\u2002+${(оДанные.чСредняяДлительностьВидеоСемпла  / оДанные.чМинДлительностьВидеоСемпла * 100 - 100).toFixed()}%`;
					}
					ОбновитьЗначение('статистика-частотакадров', сОтклонение, чОтносительноеОтклонение <= ВЫДЕЛИТЬ_ЧАСТОТУ_КАДРОВ);
				}
			}

			if (Number.isFinite(оДанные.чБитрейтЗвука) && лОкноПоказано)
			{
				Узел('статистика-битрейтзвука').textContent = `${оДанные.чБитрейтЗвука.toFixed()} ${Текст('J0143')}`;
			}
		}

		if (ЭтоЧисло(оДанные.чПреобразованЗа) && лОкноПоказано)
		{
			Узел('статистика-преобразованза').textContent = оДанные.чПреобразованЗа.toFixed();
		}

		if (оДанные.лЗабраковано)
		{
			ЗабракованСегмент();
		}

		if (оДанные.лПотериВидео)
		{
			++_кПотерьВидео;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-потерьвидео', _кПотерьВидео, true);
			}
		}

		if (оДанные.лПотериЗвука)
		{
			++_кПотерьЗвука;
			if (лОкноПоказано)
			{
				ОбновитьЗначение('статистика-потерьзвука', _кПотерьЗвука, true);
			}
		}
	}

	function ИсчерпанБуферПроигрывателя(лДосрочно)
	{
		++_кИсчерпанийБуфера;
		if (лДосрочно)
		{
			++_кИсчерпанийБуфераДосрочно;
		}
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-исчерпано', _кИсчерпанийБуфера, _кИсчерпанийБуфера >= ВЫДЕЛИТЬ_ИСЧЕРПАНИЕ_БУФЕРА);
		}
	}
	
	м_События.ДобавитьОбработчик('проигрыватель-переполненбуфер', чПропущено =>
	{
		++_кПереполненийБуфера;
		_чПропущеноВБуфере += чПропущено;
		if (ОкноПоказано())
		{
			ОбновитьЗначение('статистика-переполнено', _кПереполненийБуфера, true)
			.nextElementSibling.nextElementSibling.textContent = _чПропущеноВБуфере.toFixed(1);
		}
	});

	м_События.ДобавитьОбработчик('управление-изменилосьсостояние', чСостояние =>
	{
		if (чСостояние === СОСТОЯНИЕ_ЗАПУСК)
		{
			ОчиститьИсторию();
		}
	});

	м_События.ДобавитьОбработчик('список-выбранварианттрансляции', ([моСписокВариантов]) =>
	{
		if (моСписокВариантов)
		{
			ОчиститьИсторию();
		}
	});

	return {
		Запустить,
		ОкноПоказано, ОткрытьОкно, ЗакрытьОкно,
		ОбновитьЗначение,
		ОчиститьИсторию,
		ПолучитьTargetDuration,
		ПолучитьДлительностьКадраВСекундах,
		ПолучитьДанныеДляОтчета,
		РазобранСписокСегментов,
		ДобавленыСегментыВОчередь,
		ПолученИсходныйСегмент,
		ЗабракованСегмент,
		СкачаноНечто,
		ЗагруженСегмент,
		НеЗагруженыСегменты,
		ПолученПреобразованныйСегмент,
		ИсчерпанБуферПроигрывателя
	};
})();

const м_Чат = (() =>
{
	let _узЧат = null; // iframe

	function ПолучитьПоложениеПанели()
	// Возвращает текущую сторону даже если включено автоположение панели.
	{
		switch (getComputedStyle(document.getElementById('проигрывательичат')).flexDirection)
		{
			case 'column-reverse': return ВЕРХНЯЯ_СТОРОНА;
			case 'row': return ПРАВАЯ_СТОРОНА;
			case 'column': return НИЖНЯЯ_СТОРОНА;
			case 'row-reverse': return ЛЕВАЯ_СТОРОНА;
			default: Проверить(false);
		}
	}

	const ОбработатьОкончаниеЗагрузкиЧата = ДобавитьОбработчикИсключений(оСобытие =>
	{
		оСобытие.target.classList.remove('загружается');
		оСобытие.target.removeEventListener('load', ОбработатьОкончаниеЗагрузкиЧата);
	});

	const ОбработатьЗаголовкиОтвета = ДобавитьОбработчикИсключений(оОтвет =>
	{
		if (!( оОтвет.frameId > 0 && оОтвет.parentFrameId === 0 ))
		{
			throw new Error(`Неизвестный источник запроса: ${м_Журнал.O(оОтвет)}`);
		}
		for (let ы = 0; ы < оОтвет.responseHeaders.length; ++ы)
		{
			if (оОтвет.responseHeaders[ы].name.toLowerCase() === 'x-frame-options')
			{
				м_Журнал.Окак(`[Чат] Удаляю заголовок X-Frame-Options из ${оОтвет.url}`);
				оОтвет.responseHeaders.splice(ы, 1);
				return {responseHeaders: оОтвет.responseHeaders};
			}
		}
	});


	function ВставитьПанель()
	{
		if (_узЧат)
		{
			return;
		}
		const сАдрес = м_Twitch.ПолучитьАдресПанелиЧата();
		м_Журнал.Вот(`[Чат] Вставляю iframe ${сАдрес}`);
		// Chrome: Создавать фоновую страницу ради перехвата запросов - это лишний процесс и потеря 20 МБ памяти.
		if (м_Настройки.Получить('лПолноценныйЧат'))
		{
			chrome.webRequest.onHeadersReceived.addListener(
				ОбработатьЗаголовкиОтвета,
				{
					urls:
					[
						'https://www.twitch.tv/popout/*/chat',
						'https://www.twitch.tv/popout/*/chat?*',
						// UNDONE Рейд меняет адрес чата на этот устаревший, добавляя параметры no-reload=true&referrer=raid.
						// Далее скрипт перенаправляет на адрес, указанный выше. Удалить устаревший адрес после того,
						// как его перестанет использовать рейд.
						'https://www.twitch.tv/*/chat?*'
					],
					types:
					[
						'sub_frame'
					],
					tabId: г_чИдВкладки
				},
				[
					'responseHeaders',
					'blocking'
				]
			);
		}
		// Чат перенаправляет twitch.tv на www.twitch.tv, потом меняет document.domain c www.twitch.tv на twitch.tv.
		// Атрибут sandbox запрещает менять document.domain, поэтому sandbox использовать нельзя.
		_узЧат = document.createElement('iframe');
		_узЧат.src = сАдрес;
		_узЧат.id = 'чат';
		_узЧат.width = м_Настройки.Получить('чШиринаПанелиЧата');
		_узЧат.height = м_Настройки.Получить('чВысотаПанелиЧата');
		_узЧат.className = 'загружается';
		_узЧат.addEventListener('load', ОбработатьОкончаниеЗагрузкиЧата);
		Узел('размерчата').insertAdjacentElement('afterend', _узЧат);
	}

	function УдалитьПанель()
	{
		if (_узЧат)
		{
			м_Журнал.Вот(`[Чат] Удаляю iframe ${_узЧат.src}`);
			chrome.webRequest.onHeadersReceived.removeListener(ОбработатьЗаголовкиОтвета);
			_узЧат.removeEventListener('load', ОбработатьОкончаниеЗагрузкиЧата);
			_узЧат.remove();
			_узЧат = null;
		}
	}

	function ПрименитьАдрес()
	// Вызвать, если изменились настройки, влияющие на адрес чата.
	{
		if (_узЧат)
		{
			м_Журнал.Окак('[Чат] Меняю адрес iframe');
			УдалитьПанель();
			ВставитьПанель();
		}
	}

	function ПрименитьСостояниеПанели()
	// Вызвать, если изменилась настройка чСостояниеЧата.
	// Проще не удалять iframe, а менять его src, но тогда в чате кнопки браузера Вперед и Назад будут перезагружать чат.
	{
		const чСостояние = м_Настройки.Получить('чСостояниеЧата');
		м_Журнал.Окак(`[Чат] Новое состояние панели: ${чСостояние}`);
		ОтменитьПеретаскиваниеПанели();
		switch (чСостояние)
		{
		case ЧАТ_ВЫГРУЖЕН:
			document.body.classList.add('скрытьчат');
			УдалитьПанель();
			break;

		case ЧАТ_СКРЫТ:
			ВставитьПанель();
			document.body.classList.add('скрытьчат');
			break;

		case ЧАТ_ПАНЕЛЬ:
			ВставитьПанель();
			document.body.classList.remove('скрытьчат');
			break;

		default:
			Проверить(false);
		}
	}

	function ПрименитьПоложениеПанели()
	// Вызвать, если изменились настройки, влияющие на положение чата.
	{
		ОтменитьПеретаскиваниеПанели();
		const оКлассы = document.body.classList;
		if (м_Настройки.Получить('лАвтоПоложениеЧата'))
		{
			оКлассы.add('автоположениечата');
			оКлассы.toggle('чатвверху', м_Настройки.Получить('чВертикальноеПоложениеЧата') === ВЕРХНЯЯ_СТОРОНА);
			оКлассы.toggle('чатслева', м_Настройки.Получить('чГоризонтальноеПоложениеЧата') === ЛЕВАЯ_СТОРОНА);
		}
		else
		{
			const чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
			оКлассы.remove('автоположениечата');
			оКлассы.toggle('чатвверху', чПоложение === ВЕРХНЯЯ_СТОРОНА);
			оКлассы.toggle('чатсправа', чПоложение === ПРАВАЯ_СТОРОНА);
			оКлассы.toggle('чатвнизу', чПоложение === НИЖНЯЯ_СТОРОНА);
			оКлассы.toggle('чатслева', чПоложение === ЛЕВАЯ_СТОРОНА);
		}
	}

	function СохранитьИПрименитьСостояниеЗакрытойПанели(чНовоеСостояние)
	{
		м_Настройки.Изменить('чСостояниеЗакрытогоЧата', чНовоеСостояние);
		const чСостояние = м_Настройки.Получить('чСостояниеЧата');
		if ((чСостояние === ЧАТ_ВЫГРУЖЕН || чСостояние === ЧАТ_СКРЫТ) && чСостояние !== чНовоеСостояние)
		{
			м_Настройки.Изменить('чСостояниеЧата', чНовоеСостояние);
			ПрименитьСостояниеПанели();
		}
	}

	function ПереключитьСостояниеПанели()
 	{
		const лПолноэкранныйРежим = м_ПолноэкранныйРежим.Включен();
		switch (м_Настройки.Получить('чСостояниеЧата'))
		{
		case ЧАТ_ВЫГРУЖЕН:
		case ЧАТ_СКРЫТ:
			м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ПАНЕЛЬ, лПолноэкранныйРежим);
			break;

		case ЧАТ_ПАНЕЛЬ:
			м_Настройки.Изменить('чСостояниеЧата', лПолноэкранныйРежим ? ЧАТ_СКРЫТ : м_Настройки.Получить('чСостояниеЗакрытогоЧата'), лПолноэкранныйРежим);
			break;

		default:
			Проверить(false);
		}
		ПрименитьСостояниеПанели();
	}

	function ПереключитьПоложениеПанели()
 	{
		let чПоложение;
		if (м_Настройки.Получить('лАвтоПоложениеЧата'))
		{
			м_Настройки.Изменить('лАвтоПоложениеЧата', false);
			чПоложение = ПолучитьПоложениеПанели();
		}
		else
		{
			чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
		}
		switch (чПоложение)
		{
			case ВЕРХНЯЯ_СТОРОНА: м_Настройки.Изменить('чПоложениеПанелиЧата', ПРАВАЯ_СТОРОНА); break;
			case ПРАВАЯ_СТОРОНА:  м_Настройки.Изменить('чПоложениеПанелиЧата', НИЖНЯЯ_СТОРОНА); break;
			case НИЖНЯЯ_СТОРОНА:  м_Настройки.Изменить('чПоложениеПанелиЧата', ЛЕВАЯ_СТОРОНА); break;
			case ЛЕВАЯ_СТОРОНА:   м_Настройки.Изменить('чПоложениеПанелиЧата', ВЕРХНЯЯ_СТОРОНА); break;
			default: Проверить(false);
		}
		ПрименитьПоложениеПанели();
	}

	function ОбработатьПеретаскиваниеПанели(оПараметры)
	{
		if (оПараметры.лОтмена)
		{
			return;
		}
		const чПоложение = ПолучитьПоложениеПанели();
		// Это может произойти если включено автоположение чата.
		if (оПараметры.чШаг !== 1 && оПараметры._чНачальноеПоложение !== чПоложение)
		{
			м_Журнал.Ой(`[Чат] Положение перетаскиваемой панели изменилось с ${оПараметры._чНачальноеПоложение} на ${чПоложение}`);
			ОтменитьПеретаскиваниеПанели();
			return;
		}
		switch (оПараметры.чШаг)
		{
		case 1:
			оПараметры._чНачальноеПоложение = чПоложение;
			if (чПоложение === ПРАВАЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА)
			{
				// Учитывать min-width.
				оПараметры._чНачальныйРазмер = Number.parseInt(getComputedStyle(_узЧат).width, 10);
			}
			else
			{
				// Учитывать min-height.
				оПараметры._чНачальныйРазмер = Number.parseInt(getComputedStyle(_узЧат).height, 10);
			}
			break;

		case 2:
			if (чПоложение === ПРАВАЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА)
			{
				if (оПараметры.лИзмениласьX)
				{
					const чМаксРазмер = Number.parseInt(getComputedStyle(Узел('проигрывательичат')).width, 10)
					                  - Number.parseInt(getComputedStyle(Узел('проигрыватель' )).minWidth, 10);
					_узЧат.width = Math.max(Math.min(чПоложение === ЛЕВАЯ_СТОРОНА
						? оПараметры._чНачальныйРазмер + оПараметры.чИзменениеX
						: оПараметры._чНачальныйРазмер - оПараметры.чИзменениеX,
						чМаксРазмер), 0);
				}
			}
			else
			{
				if (оПараметры.лИзмениласьY)
				{
					const чМаксРазмер = Number.parseInt(getComputedStyle(Узел('проигрывательичат')).height, 10);
					                  - Number.parseInt(getComputedStyle(Узел('проигрыватель' )).minHeight, 10);
					_узЧат.height = Math.max(Math.min(чПоложение === ВЕРХНЯЯ_СТОРОНА
						? оПараметры._чНачальныйРазмер + оПараметры.чИзменениеY
						: оПараметры._чНачальныйРазмер - оПараметры.чИзменениеY,
						чМаксРазмер), 0);
				}
			}
			break;

		case 3:
			if (чПоложение === ПРАВАЯ_СТОРОНА || чПоложение === ЛЕВАЯ_СТОРОНА)
			{
				м_Настройки.Изменить('чШиринаПанелиЧата', Number.parseInt(getComputedStyle(_узЧат).width, 10));
			}
			else
			{
				м_Настройки.Изменить('чВысотаПанелиЧата', Number.parseInt(getComputedStyle(_узЧат).height, 10));
			}
			break;

		default:
			Проверить(false);
		}
	}

	function ОтменитьПеретаскиваниеПанели()
	{
		м_Тащилка.ОтменитьПеретаскивание('размерчата');
	}

	ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме = -1;
	
	function ОбработатьИзменениеПолноэкранногоРежима(лВключен)
	{
		if (лВключен)
		{
			if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме === -1)
			{
				ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме = м_Настройки.Получить('чСостояниеЧата');
				if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме === ЧАТ_ПАНЕЛЬ)
				{
					м_Настройки.Изменить('чСостояниеЧата', ЧАТ_СКРЫТ, true);
					ПрименитьСостояниеПанели();
				}
			}
		}
		else
		{
			if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме !== -1)
			{
				if (ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме === ЧАТ_ПАНЕЛЬ)
				{
					м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ПАНЕЛЬ);
					ПрименитьСостояниеПанели();
				}
				else if (м_Настройки.Получить('чСостояниеЧата') === ЧАТ_СКРЫТ
				&& м_Настройки.Получить('чСостояниеЗакрытогоЧата') === ЧАТ_ВЫГРУЖЕН)
				{
					м_Настройки.Изменить('чСостояниеЧата', ЧАТ_ВЫГРУЖЕН);
					ПрименитьСостояниеПанели();
				}
				ОбработатьИзменениеПолноэкранногоРежима.чСостояниеВОбычномРежиме = -1;
			}
		}
	}

	function Восстановить()
	{
		ПрименитьСостояниеПанели();
		ПрименитьПоложениеПанели();
		м_События.ДобавитьОбработчик('тащилка-перетаскивание-размерчата', ОбработатьПеретаскиваниеПанели);
		м_События.ДобавитьОбработчик('полноэкранныйрежим-изменен', ОбработатьИзменениеПолноэкранногоРежима);
	}
	
	return {
		Восстановить,
		ПрименитьПоложениеПанели,
		ПрименитьАдрес,
		СохранитьИПрименитьСостояниеЗакрытойПанели,
		ПереключитьСостояниеПанели,
		ПереключитьПоложениеПанели
	};
})();

const м_Шкала = (() =>
{
	let _чНачало = 0;
	let _чКонец  = 0;
	let _чПросмотрено;

	function ОграничитьВремя(чВремя)
	{
		return Ограничить(чВремя, _чНачало, _чКонец);
	}

	function Обновить()
	{
		Проверить(Number.isFinite(_чНачало) && Number.isFinite(_чКонец) && Number.isFinite(_чПросмотрено));
		Узел('шкала-просмотрено').style.transform = `scaleX(${((_чПросмотрено - _чНачало) / (_чКонец - _чНачало)).toFixed(4)})`;
	}

	const ОбработатьЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ПОВТОР)
		{
			return;
		}
		const оБордюр = оСобытие.currentTarget.getBoundingClientRect();
		const оСтиль = getComputedStyle(оСобытие.currentTarget);
		// У шкалы пока нет бордюра.
		const чНачалоШкалы = Math.round(оБордюр.left + Number.parseFloat(оСтиль.paddingLeft));
		const чКонецШкалы = Math.round(оБордюр.right - Number.parseFloat(оСтиль.paddingRight));
		// Windows 7: Hot spot курсора pointer находится левее центра указательного пальца. Исправляем это надоразумение.
		const чУказатель = оСобытие.clientX + 1;
		// Щелчок по левому полю перематывает на первый кадр. По правому полю - на последний.
		const чПеремотатьДо = ОграничитьВремя((чУказатель - чНачалоШкалы) / (чКонецШкалы - чНачалоШкалы) * (_чКонец - _чНачало) + _чНачало);
		м_Журнал.Окак(`[Шкала] Перематываю до ${чПеремотатьДо}`);
		м_Проигрыватель.ПеремотатьПовторДо(чПеремотатьДо);
	});

	function ЗадатьНачалоИКонец(чНачало, чКонец)
	{
		Проверить(чНачало <= чКонец);
		_чНачало = чНачало;
		_чКонец = чКонец;
		document.getElementById('шкала').addEventListener('click', ОбработатьЩелчок);
	}

	function ЗадатьПросмотрено(чПросмотрено)
	{
		_чПросмотрено = ОграничитьВремя(чПросмотрено);
		Обновить();
	}

	function ПолучитьНачало()
	{
		return _чНачало;
	}

	function ПолучитьКонец()
	{
		return _чКонец;
	}

	return {
		ЗадатьНачалоИКонец, ЗадатьПросмотрено,
		ПолучитьНачало, ПолучитьКонец
	};
})();

const м_Окна = (() =>
{
	function ПолучитьОткрытое()
	{
		return document.body.getAttribute('data-окно-открыто') || '';
	}

	function ОткрытьОкно(сИдОкна)
	{
		const узОкно = Узел(сИдОкна);
		Проверить(узОкно.classList.contains('окно'));
		узОкно.classList.add('окнооткрыто');
		document.body.setAttribute('data-окно-открыто', сИдОкна);
		м_События.ПослатьСобытие(`окна-открыто-${сИдОкна}`);
	}

	function ЗакрытьОкно(сИдОкна)
	{
		const узОкно = Узел(сИдОкна);
		Проверить(узОкно.classList.contains('окно'));
		узОкно.classList.remove('окнооткрыто');
		document.body.removeAttribute('data-окно-открыто');
		м_События.ПослатьСобытие('окна-закрыто', сИдОкна);
	}

	function Открыть(сИдОкна)
	{
		Проверить(ЭтоНепустаяСтрока(сИдОкна));
		const сИдОткрытогоОкна = ПолучитьОткрытое();
		if (сИдОкна === сИдОткрытогоОкна)
		{
			return false;
		}
		if (сИдОткрытогоОкна)
		{
			ЗакрытьОкно(сИдОткрытогоОкна);
		}
		ОткрытьОкно(сИдОкна);
		return true;
	}

	function Закрыть(сИдОкна)
	{
		Проверить(typeof сИдОкна === 'string');
		if (!сИдОкна || сИдОкна !== ПолучитьОткрытое())
		{
			return false;
		}
		ЗакрытьОкно(сИдОкна);
		return true;
	}

	function Переключить(сИдОкна)
	{
		Открыть(сИдОкна) || ЗакрытьОкно(сИдОкна);
	}

	function ОбработатьЛевыйЩелчок({target: узЩелчок})
	{
		// Щелчок по пункту меню не должен закрывать окно.
		if (Узел('проигрыватель').contains(узЩелчок))
		{
			const сИдОкна = узЩелчок.getAttribute('data-окно-переключить');
			if (сИдОкна)
			{
				Переключить(сИдОкна);
			}
			else
			{
				const сИдОткрытогоОкна = ПолучитьОткрытое();
				if (сИдОткрытогоОкна && !Узел(сИдОткрытогоОкна).contains(узЩелчок))
				{
					ЗакрытьОкно(сИдОткрытогоОкна);
				}
			}
		}
	}

	м_События.ДобавитьОбработчик('управление-левыйщелчок', ОбработатьЛевыйЩелчок);

	return {
		ПолучитьОткрытое,
		Открыть,
		Закрыть,
		Переключить
	};
})();

const м_Меню = (() =>
{
	function ПолучитьОткрытоеМеню()
	{
		return document.getElementsByClassName('менюоткрыто')[0];
	}

	function ОткрытьМеню(узМеню)
	{
		Проверить(узМеню.id);
		Проверить(узМеню.classList.contains('меню'));
		document.body.classList.remove('меню-безанимации');
		document.body.classList.add('меню-открыто');
		узМеню.classList.add('менюоткрыто');
		м_События.ПослатьСобытие(`меню-открыто-${узМеню.id}`);
	}

	function ЗакрытьМеню(узМеню, лБезАнимации)
	{
		Проверить(узМеню.classList.contains('меню'));
		document.body.classList.toggle('меню-безанимации', лБезАнимации);
		document.body.classList.remove('меню-открыто');
		узМеню.classList.remove('менюоткрыто');
	}

	function Закрыть(лБезАнимации)
	{
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню)
		{
			ЗакрытьМеню(узОткрытоеМеню, лБезАнимации);
		}
	}

	function ПереместитьМенюКТочке(узМеню, x, y)
	// getComputedStyle() не учитывает transform, getBoundingClientRect() учитывает.
	{
		const оСтиль = getComputedStyle(узМеню);
		const чШиринаМеню = Number.parseFloat(оСтиль.width,  10);
		const чВысотаМеню = Number.parseFloat(оСтиль.height, 10);
		const чШиринаОкна = window.innerWidth;
		const чВысотаОкна = window.innerHeight;

		let чМенюX;
		if (x + чШиринаМеню <= чШиринаОкна)
		{
			// Оставить курсор вне меню, чтобы щелчок левой кнопкой закрыл меню.
			// Такая большая поправка нужна для Chrome 68 с измененным масштабом.
			чМенюX = x + 1.999;
		}
		else if (чШиринаМеню <= x)
		{
			чМенюX = x - чШиринаМеню - 0.5;
		}
		else
		{
			чМенюX = Math.max(чШиринаОкна - чШиринаМеню, 0);
		}

		let чМенюY;
		if (y + чВысотаМеню <= чВысотаОкна)
		{
			чМенюY = y + 1.999;
		}
		else
		{
			// По возможности размещаем меню ниже курсора, потому что часто используемые команды
			// находятся в верхней части главного меню. Предполагается, что ширина окна минимум
			// в 2 раза больше ширины меню и поэтому курсор окажется вне меню.
			чМенюY = Math.max(чВысотаОкна - чВысотаМеню, 0);
		}

		узМеню.style.left = `${чМенюX}px`;
		узМеню.style.top  = `${чМенюY}px`;
	}

	function ПереместитьМенюКЭлементу(узМеню, узЭлемент)
	{
		const {left: x, top: y, right: x2, bottom: y2} = узЭлемент.getBoundingClientRect();
		const оСтиль = getComputedStyle(узМеню);
		const чШиринаМеню = Number.parseFloat(оСтиль.width,  10);
		const чВысотаМеню = Number.parseFloat(оСтиль.height, 10);
		const чШиринаОкна = window.innerWidth;
		const чВысотаОкна = window.innerHeight;

		let чМенюX;
		if (x + чШиринаМеню <= чШиринаОкна)
		{
			чМенюX = x;
		}
		else if (чШиринаМеню <= x2)
		{
			чМенюX = x2 - чШиринаМеню;
		}
		else
		{
			чМенюX = Math.max(чШиринаОкна - чШиринаМеню, 0);
		}

		let чМенюY;
		if (y2 + чВысотаМеню <= чВысотаОкна)
		{
			чМенюY = y2;
		}
		else if (чВысотаМеню <= y)
		{
			чМенюY = y - чВысотаМеню;
		}
		else
		{
			чМенюY = Math.max(чВысотаОкна - чВысотаМеню, 0);
		}

		узМеню.style.left = `${чМенюX}px`;
		узМеню.style.top  = `${чМенюY}px`;
		узМеню.style.minWidth = `${x2 - x}px`;
	}

	const ОбработатьКонтекстноеМеню = ДобавитьОбработчикИсключений(оСобытие =>
	{
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню && узОткрытоеМеню.contains(оСобытие.target))
		{
			// Ссылки в меню выделять запрещено, поэтому ЭтоСобытиеДляСсылки() вместо ЭтотЭлементМожноВыделить().
			if (!ЭтоСобытиеДляСсылки(оСобытие))
			{
				оСобытие.preventDefault();
			}
			return;
		}
		// Контекстное меню браузера запрещать...
		// - Нужно для тега video, команды которого могут поломать работу проигрывателя.
		// - Нельзя для ссылок, там есть полезные команды. Ссылки разрешено выделять.
		// - Нельзя для элементов, содержимое которых можно выделить, потому что на сенсорном экране выделение
		//   начинается "правым щелчком". На настольных компьютерах контекстное меню браузера пригодится, чтобы
		//   совершить действие над выделенным текстом: копировать, искать в интернете.
		let узОткрытьМеню = null;
		if (!ЭтотЭлементМожноВыделить(оСобытие.target))
		{
			оСобытие.preventDefault();
			узОткрытьМеню = Узел('главноеменю');
		}
		if (узОткрытоеМеню && узОткрытоеМеню !== узОткрытьМеню)
		{
			ЗакрытьМеню(узОткрытоеМеню, false);
		}
		if (узОткрытьМеню)
		{
			// Edge 17: С измененным масштабом координаты могут быть дробными.
			ПереместитьМенюКТочке(узОткрытьМеню, оСобытие.clientX, оСобытие.clientY);
			if (узОткрытьМеню !== узОткрытоеМеню)
			{
				ОткрытьМеню(узОткрытьМеню);
			}
		}
	});

	function ОбработатьЛевыйЩелчок({target: узЩелчок})
	{
		// Закрыть меню после щелчка по его пункту.
		if (узЩелчок.classList.contains('меню-пункт'))
		{
			ЗакрытьМеню(узЩелчок.parentNode, true);
			return;
		}
		const узОткрытоеМеню = ПолучитьОткрытоеМеню();
		if (узОткрытоеМеню && !узОткрытоеМеню.contains(узЩелчок))
		{
			ЗакрытьМеню(узОткрытоеМеню, false);
		}
		// Открыть меню после нажатия на кнопку.
		const сОткрытьМеню = узЩелчок.getAttribute('data-меню-переключить');
		if (сОткрытьМеню)
		{
			const узОткрытьМеню = Узел(сОткрытьМеню);
			if (узОткрытьМеню !== узОткрытоеМеню)
			{
				// Не использовать координаты из оСобытие, они без дробных частей, поэтому будут нестыковки в 1-2 пиксела.
				ПереместитьМенюКЭлементу(узОткрытьМеню, узЩелчок);
				ОткрытьМеню(узОткрытьМеню);
			}
		}
	}

	function ОбработатьИзменениеПолноэкранногоРежима(лВключен)
	{
		Закрыть(true);
	}

	// Нажатие SHIFT+F10 может послать событие в html и body.
	// Не вешать на document, Firefox 60 может послать туда событие во время загрузки страницы.
	// report://00000000000000_15274341445
	document.documentElement.addEventListener('contextmenu', ОбработатьКонтекстноеМеню);
	м_События.ДобавитьОбработчик('управление-левыйщелчок', ОбработатьЛевыйЩелчок);
	м_События.ДобавитьОбработчик('полноэкранныйрежим-изменен', ОбработатьИзменениеПолноэкранногоРежима);

	return {Закрыть};
})();

const м_ПолноэкранныйРежим = (() =>
{
	let _sRequestFullscreen = 'requestFullscreen';
	let _sExitFullscreen    = 'exitFullscreen';
	let _sFullscreenElement = 'fullscreenElement';
	let _sFullscreenchange  = 'fullscreenchange';
	if (!document.requestFullscreen)
	{
		_sRequestFullscreen = 'mozRequestFullScreen';
		_sExitFullscreen    = 'mozCancelFullScreen';
		_sFullscreenElement = 'mozFullScreenElement';
		_sFullscreenchange  = 'mozfullscreenchange';
	}

	const ОбработатьИзменениеРежима = ДобавитьОбработчикИсключений(() =>
	{
		const лВключен = Обновить();
		м_События.ПослатьСобытие('полноэкранныйрежим-изменен', лВключен);
	});

	const ОбработатьДвойнойЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		// Вешать переход в полноэкранный режим на все элементы страницы нельзя,
		// потому что двойным щелчком выделяют текст и быстро нажимают на кнопку.
		if (оСобытие.button === ЛЕВАЯ_КНОПКА && оСобытие.target.id === 'проигрыватель')
		{
			оСобытие.preventDefault();
			Переключить();
		}
	});

	function ПолучитьЭлемент()
	// В полноэкранном режиме должно быть доступно контекстное меню.
	{
		return Узел('проигрывательичат');
	}

	function Включен()
	{
		return !!document[_sFullscreenElement];
	}

	function Обновить()
	{
		const лВключен = Включен();
		м_Журнал.Окак(`[ПолноэкранныйРежим] Текущее состояние: ${лВключен}`);
		ИзменитьКнопку('переключитьполноэкранный', лВключен);
		return лВключен;
	}

	function Включить()
	{
		if (Включен())
		{
			return false;
		}
		м_Журнал.Вот('[ПолноэкранныйРежим] Вход в полноэкранный режим');
		м_Автоскрытие.Скрыть(true);
		ПолучитьЭлемент()[_sRequestFullscreen]();
		return true;
	}

	function Отключить()
	// Может вызываться до Запустить().
	{
		if (!Включен())
		{
			return false;
		}
		м_Журнал.Вот('[ПолноэкранныйРежим] Выход из полноэкранного режима');
		м_Автоскрытие.Скрыть(true);
		document[_sExitFullscreen]();
		return true;
	}

	function Переключить()
	{
		Включить() || Отключить();
	}

	document.addEventListener(_sFullscreenchange, ОбработатьИзменениеРежима);
	document.addEventListener('dblclick', ОбработатьДвойнойЩелчок);
	Обновить();

	return {
		Включен,
		Отключить,
		Переключить,
		ПолучитьЭлемент
	};
})();

const м_Уведомление = (() =>
// TODO Новое уведомление не заменяет незавершенное, а помещается в очередь.
// TODO Игнорировать идущие подряд одинаковые уведомления.
{
	const ПОКАЗЫВАТЬ_УВЕДОМЛЕНИЕ = 2000; // Миллисекунды.

	let _чТаймер = 0;

	function Показать(сИдЗначка, лЖопа)
	{
		Проверить(document.getElementById(сИдЗначка) && typeof лЖопа === 'boolean');
		const узУведомление = Узел('уведомление');
		узУведомление.classList.toggle('жопа', лЖопа);
		ПоказатьЭлемент(узУведомление, true);
		// UNDONE HACK Исправлено в Firefox 64 https://bugzilla.mozilla.org/show_bug.cgi?id=1502658
		узУведомление.getBoundingClientRect();
		узУведомление.firstElementChild.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#${сИдЗначка}`)
		if (_чТаймер !== 0)
		{
			clearTimeout(_чТаймер);
		}
		_чТаймер = setTimeout(СкрытьУведомление, ПОКАЗЫВАТЬ_УВЕДОМЛЕНИЕ);
	}

	function ПоказатьСчастье()
	{
		Показать('svg-success', false);
	}

	function ПоказатьЖопу()
	{
		Показать('svg-fail', true);
	}

	const СкрытьУведомление = ДобавитьОбработчикИсключений(() =>
	{
		ПоказатьЭлемент('уведомление', false);
		_чТаймер = 0;
	});

	return {
		Показать,
		ПоказатьСчастье, ПоказатьЖопу
	};
})();

const м_Автоскрытие = (() =>
{
	const МИН_ИНТЕРВАЛ_РЕДКОГО_ДВИЖЕНИЯ = 95;  // Миллисекунды.
	const ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ         = 90;  // Миллисекунды. Частота опроса мыши обычно >= 60 Гц.
	const ПОРОГ_ОКОНЧАНИЯ_ДВИЖЕНИЯ      = 300; // Миллисекунды.
	
	const _узАвтоскрытие = document.getElementById('проигрыватель');

	let _чТаймер = 0; // 0 если таймер неактивен и интерфейс скрыт.
	let _чСкрытьВ;
	let _nScreenX, _nScreenY;
	let _nClientX, _nClientY;
	let _чНачалоДвижения = 0;
	let _чПоследнееДвижение = 0;

	const ОбработатьТаймер = ДобавитьОбработчикИсключений(() =>
	{
		Проверить(_чТаймер !== 0);
		const чСкрытьЧерез = _чСкрытьВ - performance.now();
		if (чСкрытьЧерез > 100)
		{
			_чТаймер = setTimeout(ОбработатьТаймер, чСкрытьЧерез);
			_чСкрытьВ = 0;
		}
		else
		{
			Скрыть(false);
		}
	});

	function Показать()
	{
		if (_чТаймер === 0)
		{
			document.body.classList.remove('автоскрытие', 'панель-безанимации');
			_чТаймер = setTimeout(ОбработатьТаймер, м_Настройки.Получить('чИнтервалАвтоскрытия') * 1000);
			_чСкрытьВ = 0;
		}
		else
		{
			// Не вызывать лишний раз clearTimeout() и setTimeout().
			_чСкрытьВ = performance.now() + м_Настройки.Получить('чИнтервалАвтоскрытия') * 1000;
		}
	}

	function Скрыть(лБезАнимации)
	// Может вызываться до Запустить().
	{
		if (_чТаймер !== 0)
		{
			clearTimeout(_чТаймер);
			_чТаймер = 0;
			document.body.classList.add('автоскрытие');
			document.body.classList.toggle('панель-безанимации', лБезАнимации);
			if (лБезАнимации)
			{
				// Не реагировать на небольшие движения мыши.
				_чНачалоДвижения = _чПоследнееДвижение = 0;
			}
		}
	}

	function ОбработатьРедкоеДвижениеУказателя(оСобытие)
	{
		// Chrome 52: Событие всегда посылается при входе в полноэкранный режим.
		// Windows 7: WIN + TAB может менять координаты screen, поэтому добавлена проверка client.
		if ((_nScreenX === оСобытие.screenX && _nScreenY === оСобытие.screenY)
		||  (_nClientX === оСобытие.clientX && _nClientY === оСобытие.clientY))
		{
			return;
		}
		_nScreenX = оСобытие.screenX; _nScreenY = оСобытие.screenY;
		_nClientX = оСобытие.clientX; _nClientY = оСобытие.clientY;

		if (оСобытие.pointerType !== 'mouse')
		{
			Показать();
		}
		else
		{
			// Игнорировать движение, продолжительность которого меньше ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ. Зритель мог случайно задеть
			// мышь или стол, на котором она лежит. "Лишнее" отключение автоскрытия во время просмотра может мешать.
			// timeStamp можно заменить на performance.now().
			const чВремя = оСобытие.timeStamp;
			if (чВремя - _чПоследнееДвижение >= ПОРОГ_ОКОНЧАНИЯ_ДВИЖЕНИЯ)
			{
				_чНачалоДвижения = чВремя;
			}
			else if (чВремя - _чНачалоДвижения >= ПОРОГ_НАЧАЛА_ДВИЖЕНИЯ)
			{
				Показать();
			}
			_чПоследнееДвижение = чВремя;
		}
	}

	const ОбработатьДвижениеУказателя = ДобавитьОбработчикИсключений(оСобытие =>
	// pointermove может посылаться с частотой 1000 Гц (например в Edge 17), а при наличии нескольких указателей
	// в теории частота может быть еще выше. Моя обработка события не занимает много времени, но Chrome 51 не
	// любит, когда часто вызывается setTimeout(), да и очередь ни к чему захламлять ненужными событиями. Поэтому
	// обработка события сокращается до МИН_ИНТЕРВАЛ_РЕДКОГО_ДВИЖЕНИЯ. Высокая точность для автоскрытия не требуется.
	{
		_узАвтоскрытие.removeEventListener('pointermove', ОбработатьДвижениеУказателя);
		setTimeout(ПерехватитьДвижениеУказателя, МИН_ИНТЕРВАЛ_РЕДКОГО_ДВИЖЕНИЯ);
		ОбработатьРедкоеДвижениеУказателя(оСобытие);
	});

	const ПерехватитьДвижениеУказателя = ДобавитьОбработчикИсключений(() =>
	{
		_узАвтоскрытие.addEventListener('pointermove', ОбработатьДвижениеУказателя, ПАССИВНЫЙ_ОБРАБОТЧИК);
	});

	const ОбработатьЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		Показать();
	});

	const ОбработатьПокиданиеУказателя = ДобавитьОбработчикИсключений(оСобытие =>
	{
		Скрыть(false);
	});

	function Запустить()
	{
		_узАвтоскрытие.addEventListener('pointermove', ОбработатьДвижениеУказателя, ПАССИВНЫЙ_ОБРАБОТЧИК);
		// Firefox 61 Android: Если click заменить на pointerdown, то tap не только отключит автоскрытие,
		// но и нажмет появившуюся кнопку. Мышью кнопка не нажимается.
		_узАвтоскрытие.addEventListener('click', ОбработатьЩелчок, ПАССИВНЫЙ_ОБРАБОТЧИК);
		// В отличие от pointerleave и pointerout, mouseleave работает как мне нужно даже с указателями,
		// не поддерживающими hover. Например, tap в чате посылает mouseleave. Мелочь, а приятно.
		_узАвтоскрытие.addEventListener('mouseleave', ОбработатьПокиданиеУказателя);
	}

	return {
		Запустить,
		Скрыть,
		Показать
	};
})();

const м_Управление = (() =>
{
	// После изменения этой константы также изменить всплывающую подсказку.
	const ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА = 5; // Секунды, назад и вперед.
	const ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА = 5; // Кадры, только назад.

	// Текст для ссылки до получения метаданных.
	const НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО = '• • •';

	let _чСостояние;
	let _оНачалоВоспроизведения, _оРазмерБуфера, _оРастягиваниеБуфера, _оИнтервалОбновленияСписков, _оДлительностьПовтора;
	let _оРазмерИнтерфейса, _оИнтервалАвтоскрытия;

	function ЗапуститьИзменениеГромкостиКолесом()
	{
		if (м_Настройки.Получить('лМенятьГромкостьКолесом'))
		{
			document.addEventListener('wheel', ОбработатьВращениеКолеса);
			document.addEventListener('pointerdown', ОбработатьНажатиеКолеса);
		}
		else
		{
			document.removeEventListener('wheel', ОбработатьВращениеКолеса);
			document.removeEventListener('pointerdown', ОбработатьНажатиеКолеса);
		}
	}

	const ОбработатьВращениеКолеса = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (!оСобытие.shiftKey && !оСобытие.ctrlKey && !оСобытие.altKey && !оСобытие.metaKey
		&& !ЭлементВЭтойТочкеМожноПрокрутить(оСобытие.clientX, оСобытие.clientY))
		{
			// Chrome 59 переводит строки в пикселы. Edge 15 переводит строки и страницы в пикселы.
			м_Журнал.Вот(`[Управление] Движение колеса deltaY=${оСобытие.deltaY} deltaMode=${оСобытие.deltaMode}`);
			оСобытие.preventDefault();
			// Оставить звук приглушенным, потому что зритель мог случайно задеть колесо.
			// Кроме того, см. коментарий в НачатьВоспроизведение() для Chrome.
			if (оСобытие.deltaY < 0)
			{
				СохранитьИПрименитьНастройкиЗвука(undefined, Math.min(
					м_Настройки.Получить('чГромкость2') + м_Настройки.Получить('чШагИзмененияГромкостиКолесом'), МАКСИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			if (оСобытие.deltaY > 0)
			{
				СохранитьИПрименитьНастройкиЗвука(undefined, Math.max(
					м_Настройки.Получить('чГромкость2') - м_Настройки.Получить('чШагИзмененияГромкостиКолесом'), МИНИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
		}
	});

	const ОбработатьНажатиеКолеса = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.button === СРЕДНЯЯ_КНОПКА
		&& !оСобытие.shiftKey && !оСобытие.ctrlKey && !оСобытие.altKey && !оСобытие.metaKey
		&& !ЭтоСобытиеДляСсылки(оСобытие))
		{
			оСобытие.preventDefault();
			СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
		}
	});

	function ПрименитьМасштабированиеИзображения()
	{
		Узел('глаз').classList.toggle('масштабировать', м_Настройки.Получить('лМасштабироватьИзображение'));
	}

	function ПрименитьРазмерИнтерфейса()
	{
		// Не используем для 100% небольшие числа, например 1px, которые могут быть перебиты
		// настройкой минимального размера шрифта браузера. На данный момент 16px можно заменить
		// на большее значение (пересчитав rem в css). 10px маловато, потому что значение настройки
		// может быть меньше 100%.
		document.documentElement.style.fontSize = `${16 * м_Настройки.Получить('чРазмерИнтерфейса') / 100}px`;
	}

	function ПрименитьАнимациюИнтерфейса()
	{
		document.body.classList.toggle('санимацией', м_Настройки.Получить('лАнимацияИнтерфейса'));
	}

	function ОстановитьПросмотрТрансляции()
	{
		if (_чСостояние === СОСТОЯНИЕ_ОСТАНОВКА || _чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			return false;
		}
		м_Журнал.Окак('[Управление] Останавливаю просмотр трансляции');
		м_Список.Остановить();
		// Удалить сегменты, застрявшие в рабочем потоке.
		м_Преобразователь.Остановить();
		// Очистить очередь и отменить загрузку сегментов.
		г_моОчередь.Очистить();
		// Изменить состояние, остановить воспроизведение, сменить поведение на повтор.
		г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ПРЕОБРАЗОВАН, СОСТОЯНИЕ_ПОВТОР));
		// Ждать завершения _лАсинхроннаяОперация.
		м_Проигрыватель.ДобавитьСледующийСегмент();
		return true;
	}

	function ПереключитьПросмотрТрансляции()
	{
		if (!ОстановитьПросмотрТрансляции())
		{
			м_Журнал.Окак('[Управление] Начинаю просмотр трансляции');
			// Удалить СОСТОЯНИЕ_ПОВТОР если оно еще находится в очереди.
			г_моОчередь.Очистить();
			// Изменить состояние, очистить буфер проигрывателя, сменить поведение на прямую трансляцию.
			м_Проигрыватель.Перезагрузить(СОСТОЯНИЕ_ЗАПУСК);
			м_Список.Запустить();
		}
	}

	function ПереключитьОкноСтатистики()
	{
		if (м_Статистика.ОкноПоказано())
		{
			м_Статистика.ЗакрытьОкно();
		}
		else
		{
			м_Статистика.ОткрытьОкно();
		}
	}
	
	function ПереключитьПроверкуЦвета(оСобытие)
	{
		if (document.body.classList.toggle('проверкацвета'))
		{
			document.body.classList.toggle('проверкацветафон', !оСобытие.shiftKey);
			м_Новости.ОткрытьСправку();
		}
		else
		{
			document.body.classList.remove('проверкацветафон');
		}
	}

	function КопироватьТекстВБуферОбмена(сТекст)
	{
		Проверить(typeof сТекст === 'string');
		if (сТекст === '')
		{
			м_Уведомление.ПоказатьЖопу();
			return;
		}
		navigator.clipboard.writeText(сТекст)
		.then(
			() =>
			{
				м_Журнал.Вот('[Управление] Копирование в буфер обмена завершено');
				м_Уведомление.ПоказатьСчастье();
			},
			пПричина =>
			{
				м_Журнал.Ой(`[Управление] Ошибка при копировании в буфер обмена: ${пПричина}`);
				м_Уведомление.ПоказатьЖопу();
			}
		)
		.catch(м_Отладка.ПойманоИсключение);
	}

	function КопироватьАдресТрансляцииВБуферОбмена()
	{
		if (КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение)
		{
			return;
		}
		КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение = true;
		м_Журнал.Окак('[Управление] Получаю адрес трансляции для копирования');
		// VLC Media Player не любит https.
		м_Twitch.ПолучитьАбсолютныйАдресСпискаВариантов(null, true)
		.then(сРезультат =>
		{
			м_Журнал.Вот('[Управление] Копирую адрес трансляции в буфер обмена');
			// Firefox: Расширение должно иметь разрешение clipboardWrite, чтобы
			// записывать в буфер обмена вне обработчика действия пользователя.
			return navigator.clipboard.writeText(сРезультат)
			.then(
				() =>
				{
					КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение = false;
					м_Журнал.Вот('[Управление] Копирование в буфер обмена завершено');
					м_Управление.ОстановитьПросмотрТрансляции();
					м_Уведомление.ПоказатьСчастье();
				},
				// Не помещаем этот обработчик в главную цепочку обещаний, чтобы можно
				// было отделить ошибки копирования от ошибок получения адреса.
				пПричина =>
				{
					// Преобразуем пПричина в строку.
					throw `Ошибка при копировании в буфер обмена: ${пПричина}`;
				}
			);
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			КопироватьАдресТрансляцииВБуферОбмена.лИдетВыполнение = false;
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Управление] Ошибка при копировании адреса трансляции в буфер обмена: ${пПричина}`);
				м_Уведомление.ПоказатьЖопу();
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	const ОбработатьИзменениеГромкости = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СохранитьИПрименитьНастройкиЗвука(false, Number.parseFloat(оСобытие.target.value));
	});

	function СохранитьИПрименитьНастройкиЗвука(лПриглушить /* необязательный */, чГромкость /* необязательный */)
	{
		Проверить(лПриглушить !== undefined || чГромкость !== undefined);
		if (document.body.classList.contains('нетзвука'))
		{
			return;
		}
		if (лПриглушить !== undefined)
		{
			м_Настройки.Изменить('лПриглушить', лПриглушить);
		}
		if (чГромкость !== undefined)
		{
			м_Настройки.Изменить('чГромкость2', Math.round(чГромкость));
		}
		ОбновитьНастройкиЗвука();
		м_Проигрыватель.ПрименитьНастройкиЗвука();
		м_Автоскрытие.Показать();
	}

	function ОбновитьНастройкиЗвука()
	{
		Узел('громкость').value = м_Настройки.Получить('чГромкость2');
		ИзменитьКнопку('переключитьприглушить', м_Настройки.Получить('лПриглушить'));
	}

	function ОбновитьКоличествоДорожек(лЕстьВидео, лЕстьЗвук)
	{
		document.body.classList.toggle('нетвидео', !лЕстьВидео);
		document.body.classList.toggle('нетзвука', !лЕстьЗвук );
	}

	function ИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		// pointer-events: none позволяет нажимать кнопки клавой.
		if (!document.getElementById('зритель-подписка').classList.contains('обновляется'))
		{
			м_Twitch.ИзменитьПодпискуЗрителяНаКанал(чПодписка);
		}
	}

	const ОбработатьЛевыйЩелчок = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.button !== ЛЕВАЯ_КНОПКА)
		{
			return;
		}

		const узЩелчок = оСобытие.target;
		let узПозывной = узЩелчок;
		let сПозывной = узПозывной.id || узПозывной.name;
		if (!сПозывной && узЩелчок.parentNode)
		{
			узПозывной = узЩелчок.parentNode;
			сПозывной = узПозывной.id || узПозывной.name;
		}

		оСобытие.узПозывной = узПозывной;
		оСобытие.сПозывной = сПозывной;
		м_События.ПослатьСобытие('управление-левыйщелчок', оСобытие);

		switch (сПозывной)
		{
		case 'переключитьтрансляцию':
			ПереключитьПросмотрТрансляции();
			break;

		case 'переключитьпаузу':
			if (_чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Проигрыватель.ПереключитьПаузу();
			}
			break;

		case 'переключитьприглушить':
			СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
			break;

		case 'переключитьчат':
			м_Чат.ПереключитьСостояниеПанели();
			break;

		case 'создатьклип':
			м_Twitch.СоздатьКлип();
			break;

		case 'переключитьполноэкранный':
			м_ПолноэкранныйРежим.Переключить();
			break;

		case 'одновременныхзагрузок':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('кОдновременныхЗагрузок', Number.parseInt(узЩелчок.value, 10));
			м_Статистика.ОчиститьИсторию();
			break;

		case 'анимацияинтерфейса':
			м_Настройки.Изменить('лАнимацияИнтерфейса', узЩелчок.checked);
			ПрименитьАнимациюИнтерфейса();
			break;

		case 'масштабироватьизображение':
			м_Настройки.Изменить('лМасштабироватьИзображение', узЩелчок.checked);
			ПрименитьМасштабированиеИзображения();
			break;


		case 'автоположениечата':
			м_Настройки.Изменить('лАвтоПоложениеЧата', узЩелчок.checked);
			ОбновитьОкноНастроек();
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'горизонтальноеположениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чГоризонтальноеПоложениеЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'вертикальноеположениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чВертикальноеПоложениеЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'положениечата':
			Проверить(узЩелчок.checked);
			м_Настройки.Изменить('чПоложениеПанелиЧата', Number.parseInt(узЩелчок.value, 10));
			м_Чат.ПрименитьПоложениеПанели();
			break;

		case 'состояниезакрытогочата':
			Проверить(узЩелчок.checked);
			м_Чат.СохранитьИПрименитьСостояниеЗакрытойПанели(Number.parseInt(узЩелчок.value, 10));
			break;

		case 'переключитьстатистику':
		case 'позиция-текст':
			ПереключитьОкноСтатистики();
			break;

		case 'открытьновости':
		case 'открытьновости2':
			м_Новости.ОткрытьНовости();
			break;

		case 'открытьсправку':
			м_Новости.ОткрытьСправку();
			break;

		case 'отправитьотзыв':
			м_Отладка.ЗавершитьРаботуИОтправитьОтзыв();
			break;

		case 'экспортнастроек':
			м_Настройки.Экспорт();
			break;

		case 'импортнастроек':
			const уз = document.getElementById('выборфайладляимпортанастроек');
			уз.value = ''; // onchange
			уз.click();
			break;

		case 'сброситьнастройки':
			м_Настройки.Сбросить();
			break;

		case 'проверкацвета':
			ПереключитьПроверкуЦвета(оСобытие);
			break;

		case 'типтрансляции':
			Проверить(узЩелчок.nodeName === 'BUTTON');
			if (!узЩелчок.disabled)
			{
				window.location.assign(узЩелчок.getAttribute('data-адрес'));
			}
			break;

		case 'зритель-подписаться':
			ИзменитьПодпискуЗрителяНаКанал(ПОДПИСКА_УВЕДОМЛЯТЬ);
			break;

		case 'зритель-отписаться':
			ИзменитьПодпискуЗрителяНаКанал(ПОДПИСКА_НЕОФОРМЛЕНА);
			break;

		case 'зритель-уведомлять':
			ИзменитьПодпискуЗрителяНаКанал(узЩелчок.checked ? ПОДПИСКА_УВЕДОМЛЯТЬ : ПОДПИСКА_НЕУВЕДОМЛЯТЬ);
			break;

		case 'закрытьстатистику':
			м_Статистика.ЗакрытьОкно();
			break;

		case 'копироватьадресзаписи':
			м_Журнал.Вот('[Управление] Копирую адрес записи в буфер обмена');
			КопироватьТекстВБуферОбмена(м_Twitch.ПолучитьАдресЗаписиДляТекущейПозиции());
			break;

		case 'копироватьадресканала':
			м_Журнал.Вот('[Управление] Копирую адрес канала в буфер обмена');
			КопироватьТекстВБуферОбмена(м_Twitch.ПолучитьАдресКанала(false));
			break;

		case 'копироватьадрестрансляции':
			КопироватьАдресТрансляцииВБуферОбмена();
			break;
		}
	});

	const ОбработатьНажатиеИОтпусканиеКлавы = ДобавитьОбработчикИсключений(оСобытие =>
	// Firefox 47: <button> нажимается по отпусканию SPACE.
	// TODO Проверять <input type=text>.
	{
		const SHIFT_KEY = 1 << 16;
		const CTRL_KEY  = 1 << 17;
		const ALT_KEY   = 1 << 18;
		const META_KEY  = 1 << 19;

		const лНажатие = оСобытие.type === 'keydown';
		const лНажатие1 = лНажатие && !оСобытие.repeat;
		switch (оСобытие.keyCode + оСобытие.shiftKey * SHIFT_KEY + оСобытие.ctrlKey * CTRL_KEY + оСобытие.altKey * ALT_KEY + оСобытие.metaKey * META_KEY)
		{
		case 13: // ENTER
		case 13 + ALT_KEY: // ALT + ENTER
			if (лНажатие1)
			{
				м_ПолноэкранныйРежим.Переключить();
			}
			break;

		case 27: // ESC
			// Firefox на нажатие ESC прерывает загрузку фрейма с чатом. Отключаем это безобразие.
			// Отключаем ДО выполнения команды, чтобы браузер не прервал загрузку фрейма с отчетом
			// об ошибке, если ошибка произойдет во время выполнения этой команды.
			оСобытие.preventDefault();
			if (лНажатие1)
			{
				м_Меню.Закрыть(true);
				м_Окна.Закрыть(м_Окна.ПолучитьОткрытое());
				м_Автоскрытие.Скрыть(true);
			}
			break;

		case 86: // V
			if (лНажатие1)
			{
				м_Окна.Переключить('настройки');
			}
			break;

		case 73: // I
			if (лНажатие1)
			{
				м_Окна.Переключить('канал');
			}
			break;

		case 83: // S
			if (лНажатие1)
			{
				ПереключитьОкноСтатистики();
			}
			break;

		case 112: // F1
			if (лНажатие1)
			{
				м_Новости.ОткрытьСправку();
			}
			break;

		case 67: // C
			if (лНажатие1)
			{
				м_Чат.ПереключитьСостояниеПанели();
			}
			break;

		case 85: // U
			if (лНажатие1)
			{
				м_Чат.ПереключитьПоложениеПанели();
				ОбновитьОкноНастроек();
			}
			break;

		case 32: // SPACE
			if (лНажатие1)
			{
				ПереключитьПросмотрТрансляции();
				м_Автоскрытие.Показать();
			}
			break;

		case 48: // 0
		case 49: // 1
		case 50: // 2
		case 51: // 3
		case 52: // 4
		case 53: // 5
		case 54: // 6
		case 55: // 7
		case 56: // 8
		case 57: // 9
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения((оСобытие.keyCode === 48 ? 58 : оСобытие.keyCode) - 53);
				м_Автоскрытие.Показать();
			}
			break;

		// EDGE 15: PLUS и NUMPAD PLUS увеличивают скорость воспроизведения.
		case 61:  // PLUS
		case 107: // NUMPAD PLUS
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения(Infinity);
				м_Автоскрытие.Показать();
			}
			break;

		// EDGE 15: MINUS и NUMPAD MINUS уменьшают скорость воспроизведения.
		case 173: // MINUS
		case 109: // NUMPAD MINUS
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				ЗадатьСкоростьВоспроизведения(-Infinity);
				м_Автоскрытие.Показать();
			}
			break;

		case 90: // Z
		case 12: // NUMPAD 5
			if (лНажатие1 && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Проигрыватель.ПереключитьПаузу();
				м_Автоскрытие.Показать();
			}
			break;

		case 37: // LEFT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на -${ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА}с`);
				м_Проигрыватель.ПеремотатьПовторНа(false, -ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА);
				м_Автоскрытие.Показать();
			}
			break;

		case 39: // RIGHT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на +${ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА}с`);
				м_Проигрыватель.ПеремотатьПовторНа(false, ПЕРЕМАТЫВАТЬ_СТРЕЛКАМИ_НА);
				м_Автоскрытие.Показать();
			}
			break;

		case 37 + SHIFT_KEY: // SHIFT + LEFT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на -${ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА} кадров`);
				м_Проигрыватель.ПеремотатьПовторНа(true, -ПЕРЕМАТЫВАТЬ_ПО_КАДРАМ_НА);
				м_Автоскрытие.Показать();
			}
			break;

		case 39 + SHIFT_KEY: // SHIFT + RIGHT
			if (лНажатие && _чСостояние === СОСТОЯНИЕ_ПОВТОР)
			{
				м_Журнал.Окак(`[Управление] Перематываю на +1 кадр`);
				м_Проигрыватель.ПеремотатьПовторНа(true, 1);
				м_Автоскрытие.Показать();
			}
			break;

		case 38: // UP
			if (лНажатие)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.min(м_Настройки.Получить('чГромкость2') + ШАГ_ПОВЫШЕНИЯ_ГРОМКОСТИ_КЛАВОЙ, МАКСИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			break;

		case 40: // DOWN
			if (лНажатие)
			{
				СохранитьИПрименитьНастройкиЗвука(false, Math.max(м_Настройки.Получить('чГромкость2') - ШАГ_ПОНИЖЕНИЯ_ГРОМКОСТИ_КЛАВОЙ, МИНИМАЛЬНАЯ_ГРОМКОСТЬ));
			}
			break;

		case 33: // PAGE UP
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(false);
			}
			break;

		case 34: // PAGE DOWN
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(true);
			}
			break;

		case 77: // M
			if (лНажатие1)
			{
				СохранитьИПрименитьНастройкиЗвука(!м_Настройки.Получить('лПриглушить'));
			}
			break;

		case 82 + SHIFT_KEY: // SHIFT + R
			if (лНажатие1)
			{
				const лМасштабироватьИзображение = м_Настройки.Получить('лМасштабироватьИзображение');
				м_Настройки.Изменить('лМасштабироватьИзображение', !лМасштабироватьИзображение);
				ОбновитьОкноНастроек();
				ПрименитьМасштабированиеИзображения();
				м_Уведомление.Показать(`svg-fullscreen-${лМасштабироватьИзображение}`, false);
			}
			break;


		case 88 + ALT_KEY: // ALT + X
			if (лНажатие1)
			{
				м_Twitch.СоздатьКлип();
			}
			break;


		default: return;
		}

		оСобытие.preventDefault();
	});

	function ОбновитьОкноНастроек()
	{
		document.querySelector(`input[name="одновременныхзагрузок"][value="${м_Настройки.Получить('кОдновременныхЗагрузок')}"]`).checked = true;
		document.querySelector(`input[name="состояниезакрытогочата"][value="${м_Настройки.Получить('чСостояниеЗакрытогоЧата')}"]`).checked = true;
		Узел('адресчата').selectedIndex = м_Настройки.Получить('лПолноценныйЧат') ? 0 : м_Настройки.Получить('лЗатемнитьЧат') ? 2 : 1;
		Узел('масштабироватьизображение').checked = м_Настройки.Получить('лМасштабироватьИзображение');
		Узел('анимацияинтерфейса').checked = м_Настройки.Получить('лАнимацияИнтерфейса');
		Узел('менятьгромкостьколесом').selectedIndex = м_Настройки.Получить('лМенятьГромкостьКолесом') ? м_Настройки.Получить('чШагИзмененияГромкостиКолесом') : 0;

		const лАвтоПоложение = м_Настройки.Получить('лАвтоПоложениеЧата');
		Узел('автоположениечата').checked = лАвтоПоложение;
		const сузСтороны = document.querySelectorAll('.положениечата input');
		if (лАвтоПоложение)
		{
			const чГоризонтальноеПоложение = м_Настройки.Получить('чГоризонтальноеПоложениеЧата');
			const чВертикальноеПоложение = м_Настройки.Получить('чВертикальноеПоложениеЧата');
			let узГоризонтальноеПоложение, узВертикальноеПоложение;
			for (let узСторона of сузСтороны)
			{
				const чСторона = Number.parseInt(узСторона.value, 10);
				if (чГоризонтальноеПоложение === чСторона)
				{
					узГоризонтальноеПоложение = узСторона;
				}
				if (чВертикальноеПоложение === чСторона)
				{
					узВертикальноеПоложение = узСторона;
				}
				узСторона.name = чСторона === ПРАВАЯ_СТОРОНА || чСторона === ЛЕВАЯ_СТОРОНА ? 'горизонтальноеположениечата' : 'вертикальноеположениечата';
			}
			узГоризонтальноеПоложение.checked = узВертикальноеПоложение.checked = true;
		}
		else
		{
			const чПоложение = м_Настройки.Получить('чПоложениеПанелиЧата');
			let узПоложение;
			for (let узСторона of сузСтороны)
			{
				if (чПоложение === Number.parseInt(узСторона.value, 10))
				{
					узПоложение = узСторона;
				}
				узСторона.name = 'положениечата';
			}
			узПоложение.checked = true;
		}

		if (_оНачалоВоспроизведения)
		{
			_оНачалоВоспроизведения.Обновить();
			_оРазмерБуфера.Обновить();
			_оРастягиваниеБуфера.Обновить();
			_оИнтервалОбновленияСписков.Обновить();
			_оДлительностьПовтора.Обновить();
			_оРазмерИнтерфейса.Обновить();
			_оИнтервалАвтоскрытия.Обновить();
		}
		else
		{
			_оНачалоВоспроизведения     = new ВводЧисла('чНачалоВоспроизведения', 0.5, 1, 'началовоспроизведения');
			_оРазмерБуфера              = new ВводЧисла('чРазмерБуфера',          0.5, 1, 'размербуфера');
			_оРастягиваниеБуфера        = new ВводЧисла('чРастягиваниеБуфера',    0.5, 1, 'растягиваниебуфера');
			_оИнтервалОбновленияСписков = new ВводЧисла('чИнтервалОпроса',          5, 0, 'интервалопроса');
			_оДлительностьПовтора       = new ВводЧисла('чДлительностьПовтора2',   30, 0, 'длительностьповтора');
			_оНачалоВоспроизведения.ПослеИзменения = _оРазмерБуфера.ПослеИзменения = _оРастягиваниеБуфера.ПослеИзменения = _оИнтервалОбновленияСписков.ПослеИзменения = м_Статистика.ОчиститьИсторию;

			_оРазмерИнтерфейса = new ВводЧисла('чРазмерИнтерфейса', 1, 0, 'размеринтерфейса');
			_оРазмерИнтерфейса.ПослеИзменения = ПрименитьРазмерИнтерфейса;

			_оИнтервалАвтоскрытия = new ВводЧисла('чИнтервалАвтоскрытия', 0.5, 1, 'интервалавтоскрытия');
		}
	}

	function ОбработатьОткрытиеГлавногоМеню()
	{
		Узел('копироватьадресзаписи').tabIndex = м_Twitch.ПолучитьАдресЗаписиДляТекущейПозиции() ? 0 : -1;
	}

	function ОбработатьПаузу(лПауза)
	{
		ИзменитьКнопку('переключитьпаузу', лПауза);
	}

	function ОбработатьИзменениеПредустановкиБуферизации()
	{
		ОбновитьОкноНастроек();
		м_Статистика.ОчиститьИсторию();
	}

	function ПолучитьСкоростьВоспроизведения()
	{
		const узСкорость = Узел('скорость');
		м_Журнал.Окак(`[Управление] Выбрана скорость ${узСкорость.value}`);
		const чСкорость = Number.parseFloat(узСкорость.value);
		// Firefox 47, Chrome 52: Отрицательный playbackRate не поддерживается.
		// Firefox 47: Минимальная скорость 0.25.
		// Chrome 52:  Минимальная скорость 0.06.
		// Chrome 59:  NVIDIA GTX770 не вытягивает скорость 4x.
		Проверить(Number.isFinite(чСкорость) && чСкорость >= 0);
		return чСкорость;
	}

	function ЗадатьСкоростьВоспроизведения(чСкорость)
	// -Infinity - замедлить на 1 шаг
	// +Infinity - ускорить  на 1 шаг
	// < 0       - пониженная скорость
	// = 0       - нормальная скорость
	// > 0       - повышенная скорость
	{
		Проверить(ЭтоЧисло(чСкорость));
		const узСкорость = Узел('скорость');
		Проверить(узСкорость.selectedIndex >= 0);
		let чИндекс;
		if (чСкорость === -Infinity || чСкорость === Infinity)
		{
			чИндекс = узСкорость.selectedIndex - Math.sign(чСкорость);
		}
		else
		{
			чИндекс = узСкорость.querySelector('option[value="1.00"]').index - чСкорость;
		}
		if (чИндекс >= 0 && чИндекс < узСкорость.length && чИндекс !== узСкорость.selectedIndex)
		{
			узСкорость.selectedIndex = чИндекс;
			м_Проигрыватель.ЗадатьСкоростьПовтора(ПолучитьСкоростьВоспроизведения());
		}
	}

	const ОбработатьИзменениеСкоростиВоспроизведения = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (_чСостояние === СОСТОЯНИЕ_ПОВТОР)
		{
			м_Проигрыватель.ЗадатьСкоростьПовтора(ПолучитьСкоростьВоспроизведения());
		}
	});

	const ОбработатьИзменениеВариантаТрансляции = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Окак(`[Управление] Выбран вариант ${оСобытие.target.value}`);
		Проверить(оСобытие.target.value);
		м_Настройки.Изменить('сНазваниеВарианта', оСобытие.target.value);
		м_Список.ИзменитьВариантТрансляции();
	});

	const ОбработатьИзменениеГромкостиКолесом = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.selectedIndex === 0)
		{
			м_Настройки.Изменить('лМенятьГромкостьКолесом', false);
		}
		else
		{
			м_Настройки.Изменить('лМенятьГромкостьКолесом', true);
			м_Настройки.Изменить('чШагИзмененияГромкостиКолесом', оСобытие.target.selectedIndex);
		}
		ЗапуститьИзменениеГромкостиКолесом();
	});

	const ОбработатьИзменениеАдресаЧата = ДобавитьОбработчикИсключений(оСобытие =>
	{
		м_Журнал.Окак(`[Управление] Выбран адрес чата ${оСобытие.target.selectedIndex}`);
		switch (оСобытие.target.selectedIndex)
		{
		case 0:
			м_Настройки.Изменить('лПолноценныйЧат', true);
			break;

		case 1:
			м_Настройки.Изменить('лПолноценныйЧат', false);
			м_Настройки.Изменить('лЗатемнитьЧат', false);
			break;

		case 2:
			м_Настройки.Изменить('лПолноценныйЧат', false);
			м_Настройки.Изменить('лЗатемнитьЧат', true);
			break;

		default:
			Проверить(false);
		}
		м_Чат.ПрименитьАдрес();
	});

	const ОбработатьВыборФайлаДляИмпортаНастроек = ДобавитьОбработчикИсключений(оСобытие =>
	{
		if (оСобытие.target.files.length === 1)
		{
			м_Настройки.Импорт(оСобытие.target.files[0]);
		}
	});

	function ОбновитьСписокВариантовТрансляции([моСписокВариантов, чВыбранныйВариант])
	{
		const узСписок = Узел('варианттрансляции');
		узСписок.length = 0;
		if (моСписокВариантов)
		{
			for (let ы = 0; ы < моСписокВариантов.length; ++ы)
			{
				let сНазвание = моСписокВариантов[ы].сНазвание;
				if (сНазвание === 'audio_only')
				{
					сНазвание = Текст('J0144');
				}
				else if (сНазвание.endsWith('(source)'))
				{
					сНазвание = сНазвание.slice(0, -8) + Текст('J0139');
				}
				узСписок.add(new Option(сНазвание, моСписокВариантов[ы].сИдентификатор, ы === чВыбранныйВариант, ы === чВыбранныйВариант));
			}
		}
		узСписок.disabled = узСписок.length < 2;
	}

	function ПоказатьПропускВидео()
	{
		м_Уведомление.Показать('svg-cut', true);
	}

	function Запустить()
	{
		Проверить(_чСостояние === undefined);

		Узел('названиетрансляции').lastElementChild.href = м_Twitch.ПолучитьАдресКанала(true);

		let уз = document.getElementById('громкость');
		уз.min = МИНИМАЛЬНАЯ_ГРОМКОСТЬ;
		уз.max = МАКСИМАЛЬНАЯ_ГРОМКОСТЬ;
		уз.step = ШАГ_ИЗМЕНЕНИЯ_ГРОМКОСТИ_МЫШЬЮ;
		уз.addEventListener('input', ОбработатьИзменениеГромкости);

		for (уз of document.getElementById('скорость').children)
		{
			уз.text = уз.value === '1.00' ? '1x' : м_i18n.ФорматироватьЧисло(уз.value, 2);
		}

		ОбновитьНастройкиЗвука();
		ОбновитьОкноНастроек();
		м_Настройки.НастроитьСпискиПредустановок();
		м_Автоскрытие.Запустить();
		м_Автоскрытие.Показать();
		м_Новости.Запустить();
		м_Чат.Восстановить();

		м_События.ДобавитьОбработчик('меню-открыто-главноеменю', ОбработатьОткрытиеГлавногоМеню);
		м_События.ДобавитьОбработчик('список-выбранварианттрансляции', ОбновитьСписокВариантовТрансляции);
		м_События.ДобавитьОбработчик('проигрыватель-переполненбуфер', ПоказатьПропускВидео);
		м_События.ДобавитьОбработчик('проигрыватель-пауза', ОбработатьПаузу);
		м_События.ДобавитьОбработчик('настройки-измениласьпредустановка-буферизация', ОбработатьИзменениеПредустановкиБуферизации);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныеканала', ПоказатьМетаданныеКанала);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныезрителя', ПоказатьМетаданныеЗрителя);
		м_События.ДобавитьОбработчик('twitch-полученыметаданныетрансляции', ПоказатьМетаданныеТрансляции);

		// Firefox 60 после перетаскивания элементов за пределы окна посылает оСобытие.target == document.
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1445959
		document.documentElement.addEventListener('click', ОбработатьЛевыйЩелчок);
		document.addEventListener('keydown', ОбработатьНажатиеИОтпусканиеКлавы);
		document.addEventListener('keyup', ОбработатьНажатиеИОтпусканиеКлавы);
		Узел('скорость').addEventListener('change', ОбработатьИзменениеСкоростиВоспроизведения);
		Узел('варианттрансляции').addEventListener('change', ОбработатьИзменениеВариантаТрансляции);
		Узел('менятьгромкостьколесом').addEventListener('change', ОбработатьИзменениеГромкостиКолесом);
		Узел('адресчата').addEventListener('change', ОбработатьИзменениеАдресаЧата);
		Узел('выборфайладляимпортанастроек').addEventListener('change', ОбработатьВыборФайлаДляИмпортаНастроек);
		ЗапуститьИзменениеГромкостиКолесом();

		ИзменитьСостояние(СОСТОЯНИЕ_ЗАПУСК);
		ПрименитьМасштабированиеИзображения();
		ПрименитьРазмерИнтерфейса();
		ПрименитьАнимациюИнтерфейса();
		// Показать проигрыватель.
		м_Оформление.Запустить();
	}

	function ИзменитьСостояние(чНовоеСостояние)
	{
		Проверить(Number.isInteger(чНовоеСостояние));
		if (_чСостояние === чНовоеСостояние)
		{
			return;
		}
		м_Журнал.Вот(`[Управление] Состояние трансляции изменилось с ${_чСостояние} на ${чНовоеСостояние}`);
		_чСостояние = чНовоеСостояние;
		document.body.setAttribute('data-состояние', чНовоеСостояние);
		ИзменитьКнопку('переключитьтрансляцию', чНовоеСостояние === СОСТОЯНИЕ_ОСТАНОВКА || чНовоеСостояние === СОСТОЯНИЕ_ПОВТОР);
		м_События.ПослатьСобытие('управление-изменилосьсостояние', чНовоеСостояние);

		switch (чНовоеСостояние)
		{
		case СОСТОЯНИЕ_ЗАПУСК:
			ПоказатьМетаданныеТрансляции(
			{
				лЗапись:                 null,
				сАдресЗаписи:            '',
				сНазваниеТрансляции:     НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО,
				сНазваниеИгры:           null,
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			// После снятия с паузы.
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(true);
			break;

		case СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ:
			ПоказатьМетаданныеТрансляции(
			{
				лЗапись:                 null,
				сАдресЗаписи:            '',
				сНазваниеТрансляции:     НАЗВАНИЕ_ТРАНСЛЯЦИИ_НЕИЗВЕСТНО,
				сНазваниеИгры:           null,
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			м_Twitch.НачатьСборМетаданныхТрансляции();
			break;

		case СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ:
			ПоказатьМетаданныеТрансляции(
			{
				лЗапись:                 null,
				сАдресЗаписи:            '',
				сНазваниеТрансляции:     Текст('J0100'),
				сАдресИгры:              null,
				кЗрителей:               null,
				чДлительностьТрансляции: null
			});
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(true);
			Узел('статистика-задержкатрансляции').textContent = '';
			break;

		case СОСТОЯНИЕ_ЗАГРУЗКА:
		case СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ:
		case СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ:
			break;

		case СОСТОЯНИЕ_ОСТАНОВКА:
		case СОСТОЯНИЕ_ПОВТОР:
			ПоказатьМетаданныеТрансляции(
			{
				кЗрителей: null
			});
			м_Twitch.ЗавершитьСборМетаданныхТрансляции(false);
			Узел('статистика-задержкатрансляции').textContent = '';
			break;
				
		default:
			Проверить(false);
		}
	}

	function ПолучитьСостояние()
	{
		Проверить(_чСостояние !== undefined);
		return _чСостояние;
	}

	function ПоказатьМетаданныеКанала(оМетаданные)
	{
		if (оМетаданные.сИмя !== undefined)
		{
			ИзменитьЗаголовокДокумента(`${оМетаданные.сИмя} - Alternate Player for Twitch.tv`);
			Узел('канал-имя').textContent = оМетаданные.сИмя;
		}

		if (оМетаданные.сАватар !== undefined)
		{
			Проверить(оМетаданные.сАватар);
			Узел('канал-аватар').src = оМетаданные.сАватар;
		}

		if (оМетаданные.сОписание !== undefined)
		{
			Узел('канал-описание').textContent = оМетаданные.сОписание || '';
		}

		if (оМетаданные.сКодЯзыка !== undefined)
		{
			const уз = Узел('канал-язык');
			if (оМетаданные.сКодЯзыка)
			{
				уз.textContent = м_i18n.ПолучитьНазваниеЯзыка(оМетаданные.сКодЯзыка);
				ПоказатьЭлемент(уз.parentNode, true);
			}
			else
			{
				ПоказатьЭлемент(уз.parentNode, false);
			}
		}

		if (оМетаданные.кПодписчиков !== undefined)
		{
			Узел('канал-подписчиков').textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кПодписчиков);
		}

		if (оМетаданные.кПросмотров !== undefined)
		{
			Узел('канал-просмотров').textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кПросмотров);
		}

		if (оМетаданные.чКаналСоздан !== undefined)
		{
			Узел('канал-создан').textContent = м_i18n.ФорматироватьДату(оМетаданные.чКаналСоздан);
		}

		ПоказатьМассивСсылок(оМетаданные.моСообщества, 'канал-сообщества');
		ПоказатьМассивСсылок(оМетаданные.моКоманды, 'канал-команды');
	}

	function ПоказатьМассивСсылок(моСсылки, пВставить)
	{
		if (моСсылки === undefined)
		{
			return;
		}
		const узВставить = Узел(пВставить);
		if (моСсылки.length === 0)
		{
			ПоказатьЭлемент(узВставить.parentNode, false);
		}
		else
		{
			const оФрагмент = document.createDocumentFragment();
			for (let ы = 0, оСсылка; оСсылка = моСсылки[ы]; ++ы)
			{
				if (ы !== 0)
				{
					оФрагмент.appendChild(document.createTextNode(',\u2002'));
				}
				Проверить(ЭтоНепустаяСтрока(оСсылка.сАдрес) && ЭтоНепустаяСтрока(оСсылка.сИмя));
				const узСсылка = document.createElement('a');
				узСсылка.href = оСсылка.сАдрес;
				узСсылка.rel = 'noopener noreferrer';
				узСсылка.target = '_blank';
				if (оСсылка.сОписание)
				{
					узСсылка.className = 'канал-ссылка';
					узСсылка.title = оСсылка.сОписание;
				}
				узСсылка.textContent = оСсылка.сИмя;
				оФрагмент.appendChild(узСсылка);
			}
			узВставить.textContent = '';
			узВставить.appendChild(оФрагмент);
			ПоказатьЭлемент(узВставить.parentNode, true);
		}
	}

	function ПоказатьМетаданныеЗрителя(оМетаданные)
	{
		if (оМетаданные.сИмя !== undefined)
		{
			if (оМетаданные.сИмя !== '')
			{
				Узел('зритель-имя').textContent = оМетаданные.сИмя;
			}
			else
			{
				м_i18n.InsertAdjacentHtmlMessage('зритель-имя', 'content', 'F0590');
			}
		}

		if (оМетаданные.чПодписка !== undefined)
		{
			const уз = Узел('зритель-подписка');
			if (оМетаданные.чПодписка === ПОДПИСКА_ОБНОВЛЯЕТСЯ)
			{
				уз.classList.add('обновляется');
			}
			else
			{
				уз.classList.remove('обновляется');
				уз.setAttribute('data-подписка', оМетаданные.чПодписка);
				Узел('зритель-уведомлять').checked = оМетаданные.чПодписка === ПОДПИСКА_УВЕДОМЛЯТЬ;
			}
		}
	}

	function ПоказатьМетаданныеТрансляции(оМетаданные)
	// undefined - не менять, null - скрыть.
	{
		if (оМетаданные.лЗапись !== undefined)
		{
			const уз = Узел('типтрансляции');
			if (оМетаданные.лЗапись === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				ИзменитьКнопку(уз, оМетаданные.лЗапись);
				if (оМетаданные.сАдресЗаписи)
				{
					уз.setAttribute('data-адрес', оМетаданные.сАдресЗаписи);
					уз.disabled = false;
				}
				else
				{
					уз.disabled = true;
				}
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.сНазваниеТрансляции !== undefined)
		{
			const уз = Узел('названиетрансляции');
			if (оМетаданные.сНазваниеТрансляции === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.title = оМетаданные.сНазваниеТрансляции + Текст('J0101');
				уз.lastElementChild.textContent = оМетаданные.сНазваниеТрансляции;
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.сНазваниеИгры !== undefined)
		{
			const уз = Узел('названиеигры');
			if (оМетаданные.сНазваниеИгры === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.href = оМетаданные.сАдресИгры;
				уз.lastElementChild.title = оМетаданные.сНазваниеИгры + Текст('J0102');
				уз.lastElementChild.textContent = оМетаданные.сНазваниеИгры;
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.кЗрителей !== undefined)
		{
			const уз = Узел('количествозрителей');
			if (оМетаданные.кЗрителей === null)
			{
				ПоказатьЭлемент(уз, false);
			}
			else
			{
				уз.lastElementChild.textContent = м_i18n.ФорматироватьЧисло(оМетаданные.кЗрителей);
				ПоказатьЭлемент(уз, true);
			}
		}

		if (оМетаданные.чДлительностьТрансляции !== undefined)
		{
			Узел('позиция-текст').textContent = оМетаданные.чДлительностьТрансляции === null
				 ? '' : м_i18n.ПеревестиСекундыВСтроку(оМетаданные.чДлительностьТрансляции / 1000, false);
		}
	}

	return {
		Запустить,
		ПолучитьСостояние, ИзменитьСостояние,
		ПолучитьСкоростьВоспроизведения,
		ОбновитьНастройкиЗвука,
		ОбновитьКоличествоДорожек,
		ОстановитьПросмотрТрансляции
	};
})();


const м_Проигрыватель = (() =>
{
	// Нет необходимости нагибать процессор слишком часто.
	//
	// Firefox 48: Если CTS кадров перепутаны, то после удаления или добавления видео, ямы в buffered перестают быть
	// видны, поэтому в них можно "провалиться": воспроизвдение в этом месте остановится. Такое происходит редко. Чтобы
	// уменьшить вероятность провала, не стоит уменьшать ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО слишком сильно.
	const ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО = 10; // Секунды.


	// Firefox 54 + Windows: Остановка воспроизведения происходит в начале последнего кадра HTMLMediaElement.buffered.
	const ИСЧЕРПАНИЕ_БУФЕРА = 0.100; // Секунды.

	const ПОВТОР_НЕДОСТУПЕН_ЕСЛИ_ПРОСМОТРЕНО_МЕНЬШЕ_ЧЕМ = 1.0; // Секунды > ИСЧЕРПАНИЕ_БУФЕРА.

	const ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА            = -1;
	const ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ         = -2;
	const ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ                = -3;
	const ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ      = -4;

	const ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО               = 0;
	const ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО                 = 1;
	const ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ = 2;

	let _oMediaElement;
	let _oMediaSource;
	let _oMediaSourceBuffer = null;
	// 0: начальное значение.
	// 1: _oMediaSource открывался.
	// 2: воспроизведение начиналось.
	let _чВоспроизведениеНачиналось = 0;
	let _лАсинхроннаяОперация = false;
	let _сРазмерБуфера = 'чНачалоВоспроизведения';
	let _лЖдатьЗаполненияБуфера = true;
	let _чСмещениеТрансляции = NaN;
	let _лПропуститьWaiting;


	const _оПрямаяТрансляция =
	{
		ОбработатьSourceOpen()
		{
			Проверить(_oMediaElement.paused);
			_чВоспроизведениеНачиналось = Math.max(_чВоспроизведениеНачиналось, 1);
			ДобавитьСледующийСегмент();
		},

		ОбработатьProgress()
		// Обработка этого события добавлена на всякий случай: после завершения appendBuffer(),
		// содержимое _oMediaSourceBuffer могло не успеть добраться до _oMediaElement.
		{
			if (!_лАсинхроннаяОперация)
			{
				НачатьВоспроизведение(ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА));
			}
		},

		ОбработатьWaiting()
		// Воспроизведение могло остановиться перед ямой. Обработчик timeupdate не проверяет
		// наличие ям, потому что браузер небольшие ямы может перепрыгнуть без посторонней помощи.
		{
			Проверить(_лПропуститьWaiting !== undefined);
			if (_лПропуститьWaiting)
			{
				_лПропуститьWaiting = false;
				return;
			}
			// Firefox 61: Событие посылается непосредственно перед событием pause и ended, когда paused == ended == true.
			if (!_oMediaElement.seeking && !_oMediaElement.paused && !_oMediaElement.ended)
			{
				switch (ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ))
				{
				case ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО:
					// Добавление сегмента могло быть отложено в ДобавитьСледующийСегмент().
					ДобавитьСледующийСегмент();
					break;
				case ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО:
					// Firefox 54: Исчерпание буфера могло произойти непосредственно перед endOfStream() во время appendBuffer():
					// appendBuffer() ▪ readyState=HAVE_CURRENT_DATA ▪ endOfStream() ▪ durationchange ▪ timeupdate ▪ waiting
					// report://05754144915625_14780215813
					//
					// Firefox 52: "Лишний" waiting посылается, если проигрыватель находится в неактивной вкладке и браузер
					// полностью загружен работой, например разбирает ооооооочень большую страницу.
					// play() ▪ timeupdate readyState=HAVE_ENOUGH_DATA ▪ playing ▪ timeupdate readyState=HAVE_METADATA ▪ waiting ▪ canplaythrough ▪ timeupdate
					// report://05598314281598_14802114309
					Проверить(_oMediaSource.readyState === 'ended');
					м_Журнал.Ой('Лишний waiting после endOfStream()');
					break;
				}
			}
		},

		ОбработатьPlaying()
		{
			if (м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ && !_oMediaElement.paused)
			{
				м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ВОСПРОИЗВЕДЕНИЕ);
			}
		},

		ОбработатьSeeking: ЗАГЛУШКА,
		ОбработатьSeeked: НачатьВоспроизведение,

		ОбработатьEnded()
		{
			ПерезагрузитьПроигрыватель(СОСТОЯНИЕ_ЗАГРУЗКА);
		},

		ОбработатьTimeUpdate()
		{
		}
	};

	const _оПовтор =
	{
		лПауза: true,

		ОбработатьSourceOpen()
		// Может прийти, если начать и сразу остановить просмотр трансляции.
		{
			Проверить(_oMediaElement.paused);
			_чВоспроизведениеНачиналось = Math.max(_чВоспроизведениеНачиналось, 1);
		},

		ОбработатьProgress: ЗАГЛУШКА,
		ОбработатьWaiting: ЗАГЛУШКА,
		ОбработатьPlaying: ЗАГЛУШКА,
		ОбработатьSeeked: ЗАГЛУШКА,

		ОбработатьSeeking()
		// Если изменить _oMediaElement.currentTime до окончания перемотки, то событие timeupdate не придет.
		{
			м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		},

		ОбработатьEnded()
		{
			if (!this.лПауза)
			{
				// Сначала приходит timeupdate и происходит перемотка на начало. Потом приходит ended и воспроизведение возобновляется.
				_oMediaElement.play();
			}
		},

		ОбработатьTimeUpdate()
		{
			// Нельзя определить режим работы по _oMediaElement.paused. _oMediaElement.paused = true после события ended.
			// Каким был _oMediaElement.paused до прихода ended узнать по состоянию _oMediaElement нельзя.
			if (!this.лПауза && !_oMediaElement.seeking)
			{
				this.ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ);
			}
			м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		},

		ПроверитьПозициюВоспроизведения(чВремя)
		{
			Проверить(Number.isFinite(чВремя));
			Проверить(чВремя === ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ || чВремя === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ || чВремя >= 0);
			
			const оБуфер = _oMediaElement.buffered;
			const чПоследняяОбласть = оБуфер.length - 1;
			// Chrome 47: currentTime может быть на 0.000001 секунды меньше присвоенной величины.
			// Если это не учесть, то получим бесконечную перемотку на начало области.
			const чТекущееВремя = _oMediaElement.currentTime + 0.0001;
			let чПеремотатьДо = чВремя >= 0 ? чВремя : чТекущееВремя;
			let сПричинаПеремотки = '';

			for (let лНачатьСначала = false;;)
			{
				// TODO Firefox 48: Видео без звука перепрыгивает сам. Звук без видео перепрыгивает сам, возможно
				// не всегда. Отсутствие обоих потоков не встречалось и поэтому не тестировалось.
				// BUG Firefox 48: После самостоятельного перепрыгивания видео без звука, звук пропадает до перемотки.

				if (this.лПауза || чПеремотатьДо < м_Шкала.ПолучитьКонец())
				{
					break;
				}
				if (лНачатьСначала)
				{
					ПоказатьСостояние('Ой', `Бесконечная перемотка Время=${чВремя}`);
					return;
				}
				чПеремотатьДо = м_Шкала.ПолучитьНачало();
				сПричинаПеремотки += 'Начинаю сначала. ';
				лНачатьСначала = true;
			}

			if (чПеремотатьДо !== чТекущееВремя)
			{
				ПоказатьСостояние('Окак', `${сПричинаПеремотки}Перематываю до ${чПеремотатьДо}`);
				_oMediaElement.currentTime = чПеремотатьДо;
			}
		}
	};

	// _оПрямаяТрансляция или _оПовтор.
	let _оПоведение = _оПрямаяТрансляция;

	function ПоказатьСостояние(сВажность, сЗапись)
	{
		const оБуфер = _oMediaSource.sourceBuffers.length !== 0 ? _oMediaSource.sourceBuffers[0] : null;
		const сОбластиБуфера = ПеревестиОбластиВСтроку(оБуфер ? оБуфер.buffered : null);
		const сОбласти = ПеревестиОбластиВСтроку(_oMediaElement.buffered)
		const лОбластиРавны = сОбластиБуфера === сОбласти;
		if (сВажность === 'Вот' && ((оБуфер && оБуфер.buffered.length > 1) || _oMediaElement.buffered.length > 1))
		{
			сВажность = 'Окак';
		}
		if (_oMediaElement.error || !лОбластиРавны)
		{
			сВажность = 'Ой';
		}
		м_Журнал[сВажность](
			`${сЗапись.charAt(0) === '[' ? '' : '[Проигрыватель] '}${сЗапись} •••`
			+ (оБуфер && оБуфер.updating ? ' [U]' : '')
			+ (_oMediaElement.paused     ? ' [P]' : '')
			+ (_oMediaElement.seeking    ? ' [S]' : '')
			+ (_oMediaElement.ended      ? ' [E]' : '')
			+ (_oMediaElement.error ? ` error=${_oMediaElement.error.code}` : '')
			+ (_oMediaElement.src.startsWith('blob:') || _oMediaElement.src.startsWith('mediasource:') ? '' : ` src=${_oMediaElement.src}`)
			+ (_oMediaSource.readyState === 'open' ? '' : ` MSE.readyState=${_oMediaSource.readyState}`)
			+ (_oMediaSource.sourceBuffers.length === 1 ? '' : ` MSE.buffers=${_oMediaSource.sourceBuffers.length}`)
			+ (_oMediaElement.networkState === HTMLMediaElement.NETWORK_LOADING ? '' : ` networkState=${_oMediaElement.networkState}`)
			+ ` readyState=${_oMediaElement.readyState}`
			+ ` currentTime=${_oMediaElement.currentTime}`
			+ (лОбластиРавны ? ` buffered=${сОбласти}` : ` MSE.buffered=${сОбластиБуфера} buffered=${сОбласти}`)
			+ (_oMediaElement.duration === Infinity ? '' : ` duration=${_oMediaElement.duration}`)
			+ ` seekable=${ПеревестиОбластиВСтроку(_oMediaElement.seekable)}`
			+ ` played=${ПеревестиОбластиВСтроку(_oMediaElement.played)}`
		);
	}

	function ПеревестиОбластиВСтроку(оОбласти)
	{
		let сРезультат = '';
		if (оОбласти && оОбласти.length !== 0)
		{
			let чОбласть = Math.max(оОбласти.length - 20, 0);
			if (чОбласть !== 0)
			{
				сРезультат = `[${чОбласть}]`;
			}
			for (; чОбласть < оОбласти.length; ++чОбласть)
			{
				if (чОбласть !== 0)
				{
					сРезультат += `(${(оОбласти.start(чОбласть) - оОбласти.end(чОбласть - 1)).toFixed(3)})`;
				}
				сРезультат += `${оОбласти.start(чОбласть)}-${оОбласти.end(чОбласть)}`;
			}
		}
		return сРезультат;
	}

	function ПолучитьЗаполненностьБуфера(оБуфер = _oMediaElement.buffered)
	// Возвращает
	// {
	//   чПросмотрено:   длительность   просмотренного видео >= 0 с
	//   чНеПросмотрено: длительность непросмотренного видео >= 0 с
	// }
	// Ямы не учитываются.
	{
		let чПросмотрено = 0;
		let чНеПросмотрено = 0;
		if (оБуфер.length !== 0)
		{
			const чНачало = оБуфер.start(0);
			const чКонец = оБуфер.end(оБуфер.length - 1);
			const чТекущееВремя = Ограничить(_oMediaElement.currentTime, чНачало, чКонец);
			чПросмотрено = чТекущееВремя - чНачало;
			чНеПросмотрено = чКонец - чТекущееВремя;
		}
		return {чПросмотрено, чНеПросмотрено};
	}

	function ПолучитьКоличествоПропущенныхКадров()
	{
		return _oMediaElement.getVideoPlaybackQuality ? _oMediaElement.getVideoPlaybackQuality() :
		{
			totalVideoFrames:   _oMediaElement.webkitDecodedFrameCount,
			droppedVideoFrames: _oMediaElement.webkitDroppedFrameCount
		};
	}

	function ПолучитьПозициюВоспроизведенияТрансляции(лДляКлипа)
	// Возвращает -1 если позиция неизвестна.
	{
		if (Number.isNaN(_чСмещениеТрансляции))
		{
			return -1;
		}
		let чПозиция = _oMediaElement.currentTime;
		// Во время повтора сегменты ближе к началу шкалы уже недоступны на сервере Twitch.
		if (лДляКлипа && м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР)
		{
			чПозиция = м_Шкала.ПолучитьКонец();
		}
		// После ПерезагрузитьПроигрыватель() воспроизведение не начиналось. Не ждать
		// заполнения буфера, которое может длиться несколько десятков секунд.
		if (!лДляКлипа && чПозиция === 0 && _oMediaSourceBuffer !== null)
		{
			const оБуфер = _oMediaSourceBuffer.buffered;
			if (оБуфер.length !== 0)
			{
				чПозиция = оБуфер.start(0);
			}
		}
		return чПозиция === 0 ? -1 : Math.max(чПозиция + _чСмещениеТрансляции, 0);
	}

	function РасчитатьСмещениеТрансляции(оСегмент)
	// Изменяет _чСмещениеТрансляции.
	// Если трансляция длится дольше ≈ 0x1FFFFFFFF / 90000 секунд, то позиция кодирования
	// добавляется к смещению (которое становится положительным числом) и затем обнуляется.
	// Бывают и другие комбинации, например чПозицияКодирования = 10000 и чСмещениеТрансляции = 5000.
	{
		if (Number.isFinite(оСегмент.пДанные.чПозицияКодирования)
		&&  Number.isFinite(оСегмент.пДанные.чПозицияТрансляции))
		{
			// ВД как правило лишь на несколько миллисекунд отличается от ВП, поэтому годится для расчета смещения.
			// Большой точности для смещения не требуется.
			const чСмещениеТрансляции = оСегмент.пДанные.чПозицияТрансляции - оСегмент.пДанные.чПозицияКодирования;
			м_Журнал[Math.abs(чСмещениеТрансляции - _чСмещениеТрансляции) > 2 ? 'Ой' : 'Вот']
				(`[Проигрыватель] Смещение трансляции: ${м_Журнал.F1(чСмещениеТрансляции)}с`);
			_чСмещениеТрансляции = чСмещениеТрансляции;
		}
	}
	
	function ПоказатьЗадержкуТрансляции(оСегмент)
	{
		if (м_Статистика.ОкноПоказано()
		&& Number.isFinite(оСегмент.пДанные.чПозицияКодирования)
		&& Number.isFinite(оСегмент.пДанные.чВремяКодирования)
		&& _oMediaElement.currentTime !== 0)
		{
			const чПолучение = (performance.now() + г_чТочноеВремя - оСегмент.пДанные.чВремяКодирования) / 1000;
			const чВоспроизведение = оСегмент.пДанные.чПозицияКодирования - _oMediaElement.currentTime;
			const сЗадержка = `${чПолучение.toFixed(1)} + ${чВоспроизведение.toFixed(1)} = ${(чПолучение + чВоспроизведение).toFixed(1)}`;
			м_Журнал[чПолучение > 0 && чВоспроизведение > -0.1 ? 'Вот' : 'Ой'](`[Проигрыватель] Задержка трансляции: ${сЗадержка}с`);
			Узел('статистика-задержкатрансляции').textContent = сЗадержка;
		}
	}

	function ПрименитьНастройкиЗвука()
	{
		_oMediaElement.volume = м_Настройки.Получить('чГромкость2') / МАКСИМАЛЬНАЯ_ГРОМКОСТЬ;
		_oMediaElement.muted = м_Настройки.Получить('лПриглушить');
	}

	function ПерезагрузитьИЖдатьЗаполненияБуфера(чНовоеСостояние)
	{
		_лЖдатьЗаполненияБуфера = true;
		ПерезагрузитьПроигрыватель(чНовоеСостояние);
	}

	function ПерезагрузитьПроигрыватель(чНовоеСостояние)
	// Вызвавший эту функцию во время асинхронной операции должен сам удалить не добавленный сегмент из очереди.
	{
		ПоказатьСостояние('Окак', 'Перезагрузка проигрывателя');
		м_Управление.ИзменитьСостояние(чНовоеСостояние);
		_оПоведение = _оПрямаяТрансляция;
		_oMediaSourceBuffer = null;
		// - _oMediaElement.pause().
		// - _oMediaElement.currentTime = 0.
		// - _oMediaElement.playbackRate = 1.
		// - Посылает асинхронно abort в _oMediaSourceBuffer если нужно.
		// - Отсоединяет _oMediaSourceBuffer от _oMediaSource.
		// - Закрывает _oMediaSource.
		// - Открывает _oMediaSource.
		_oMediaElement.load();
		// Ждем вызова ОбработатьSourceOpen().
	}

	function СледитьЗаОшибками()
	{
		if (_oMediaElement.error)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0206');
		}
	}

	const СледитьЗаСобытиямиMediaSource = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СледитьЗаОшибками();
		const сЗапись = `[MediaSource] ${оСобытие.type}`;
		switch (оСобытие.type)
		{
		case 'sourceopen':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSourceOpen();
			break;

		case 'sourceended':
		case 'sourceclose':
			ПоказатьСостояние('Вот', сЗапись);
			break;
	
		default:
			м_Журнал.Вот(сЗапись);
		}
	});

	const СледитьЗаСобытиямиMediaElement = ДобавитьОбработчикИсключений(оСобытие =>
	{
		СледитьЗаОшибками();
		const сЗапись = `[MediaElement] ${оСобытие.type}`;
		switch (оСобытие.type)
		{
		case 'loadstart':
			ПоказатьСостояние('Вот', `${сЗапись} src=${_oMediaElement.src} currentSrc=${_oMediaElement.currentSrc}`);
			break;

		case 'progress':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьProgress();
			break;

		case 'abort':
			ПоказатьСостояние('Вот', сЗапись);
			break;

		case 'waiting':
			ПоказатьСостояние('Окак', сЗапись);
			_оПоведение.ОбработатьWaiting();
			break;

		case 'playing':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьPlaying();
			break;

		case 'seeking':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSeeking();
			break;

		case 'seeked':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьSeeked();
			break;

		case 'ended':
			ПоказатьСостояние('Вот', сЗапись);
			_оПоведение.ОбработатьEnded();
			break;

		case 'timeupdate':
			м_Журнал.Вот(`${сЗапись} readyState=${_oMediaElement.readyState} currentTime=${_oMediaElement.currentTime} НеПросмотрено=${м_Журнал.F2(ПолучитьЗаполненностьБуфера().чНеПросмотрено)}`);
			_оПоведение.ОбработатьTimeUpdate();
			break;

		case 'volumechange':
			м_Журнал.Вот(`${сЗапись} volume=${_oMediaElement.volume} muted=${_oMediaElement.muted}`);
			break;

		default:
			м_Журнал.Вот(сЗапись);
		}
	});

	function ПроверитьПозициюВоспроизведения(чИсточникПроверки, чБудетДобавлено = 0)
	// Это единственная функция, которая во время прямой трансляции изменяет _oMediaElement.currentTime.
	// ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА:
	// - Переносит вперед _oMediaElement.currentTime чтобы предотвратить переполнение буфера.
	// - Ничего не возвращает.
	// ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ, ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ, ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ:
	// - Переносит вперед _oMediaElement.currentTime если найдена область >= МИН_РАЗМЕР_БУФЕРА.
	// - Вызывает БуферИсчерпан() если область не найдена и идет воспроизведение.
	// Возвращает:
	// - ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО если область не найдена.
	// - ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО если область найдена.
	// - ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ если область найдена и запущена перемотка.
	{
		const оБуфер = _oMediaElement.buffered;
		const чПоследняяОбласть = оБуфер.length - 1;
		if (чПоследняяОбласть === -1)
		{
			return false;
		}
		// Chrome 47: currentTime может быть на 0.000001 секунды меньше присвоенной величины.
		// Если это не учесть, то получим бесконечную перемотку на начало области.
		const чТекущееВремя = _oMediaElement.currentTime + 0.0001;
		let чПеремотатьДо = Math.max(чТекущееВремя, оБуфер.start(0));
		let сПричинаПеремотки = '';
		const чНеПросмотрено = оБуфер.end(чПоследняяОбласть) - чПеремотатьДо;

		// Пропустить часть видео, чтобы не увеличивать задержку трансляции и чтобы _oMediaSource и
		// УдалитьПросмотренноеВидео() начали удалять просмотренное видео, предотвращая переполнение
		// _oMediaSourceBuffer. _oMediaSource при удалении (coded frame eviction) учитывает currentTime
		// и не учитывает played и paused.
		// Причины переполнения:
		// - _oMediaSource был закрыт до первого перехода на вкладку.
		// - Разделять по ключевым кадрам и очень длинный GOP.
		// - Окончание трансляции (часть которой застряла на сервере?) и сразу начало новой (заранее записанной?).
		// - Серьезный затык в сети или на сервере.
		// - Изменение настроек.
		// - Очень большое количество разрывов.
		// - Выход из спячки.
		// - Edge 15: Выход из WIN + L.
		// - Зависание перемотки или воспроизведения.
		if (чИсточникПроверки === ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА)
		{
			const чРазмерБуфера = м_Настройки.Получить('чМаксРазмерБуфера');
			const чПереполнение = чРазмерБуфера + м_Настройки.Получить('чРастягиваниеБуфера');
			if (чНеПросмотрено <= чПереполнение)
			{
				return; // Возвращаемое значение не используется.
			}
			// Не показывать переполнение если оно произошло из-за позднего перехода на вкладку.
			if (_чВоспроизведениеНачиналось === 2)
			{
				м_События.ПослатьСобытие('проигрыватель-переполненбуфер', чНеПросмотрено - чРазмерБуфера);
			}
			сПричинаПеремотки += `Переполнен буфер проигрывателя ${чНеПросмотрено.toFixed(2)}с > ${чПереполнение}с. `;
			// Немного добавить, чтобы непросмотренного точно хватило для начала воспроизведения.
			чПеремотатьДо = оБуфер.end(чПоследняяОбласть) - чРазмерБуфера - 0.1;
		}

		// После перехода на вкладку начальная задержка трансляции может оказаться слишком большой (см. ПредотвратитьПереполнениеОчереди).
		// Если переход выполнен поздно, то в процессе добавления сегментов и начала воспроизведения может несколько раз сработать защита
		// от переполнения буфера и один раз эта защита от превышения задержки трансляции.
		if (чИсточникПроверки === ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ && _чВоспроизведениеНачиналось !== 2)
		{
			_чВоспроизведениеНачиналось = 2;
			// Длительность сегментов не всегда кратна размеру буфера.
			// Также нужно немного добавить, чтобы непросмотренного точно хватило для начала воспроизведения.
			const чПереполнение = м_Настройки.Получить('чМаксРазмерБуфера') + м_Статистика.ПолучитьTargetDuration() / 2;
			if (чНеПросмотрено > чПереполнение)
			{
				сПричинаПеремотки += `Превышена задержка трансляции ${чНеПросмотрено.toFixed(2)}с > ${чПереполнение}с. `;
				чПеремотатьДо = оБуфер.end(чПоследняяОбласть) - чПереполнение;
			}
		}

		// Chrome 48, Firefox 48: Иногда currentTime вылезает за пределы области.
		//
		// Chrome 59 + Windows + аппаратное декодирование: Перемотка не завершится пока после точки перемотки не появится достаточно кадров
		// для начала воспроизведения. Пример: В буфере 1.0-5.1 с. После перемотки до 5.0 с, 100 мс (3 кадра) недостаточно для воспроизведения.
		// Добавлены кадры, часть которых утеряна, в буфере 1.0-5.1 6.0-10.0. Перемотка никогда не завершится. Чтобы этого не произошло,
		// запрещаем перемотку и воспроизведение если данных недостаточно. Исключение сделано для переполнения буфера.
		Проверить(ИСЧЕРПАНИЕ_БУФЕРА < МИН_РАЗМЕР_БУФЕРА);
		let чНужноДляВоспроизведения = чИсточникПроверки === ПРОВЕРИТЬ_ВОСПРОИЗВЕДЕНИЕ ? ИСЧЕРПАНИЕ_БУФЕРА
		                             : чИсточникПроверки === ПРОВЕРИТЬ_ОСТАНОВКА_ВОСПРОИЗВЕДЕНИЯ ? Infinity
		                             : МИН_РАЗМЕР_БУФЕРА;
		let лВоспроизведениеВозможно = _oMediaSource.readyState === 'ended';
		let чДоКонцаОбласти;
		for (let чОбласть = 0; чОбласть <= чПоследняяОбласть; ++чОбласть)
		{
			if (чПеремотатьДо < оБуфер.start(чОбласть))
			{
				чНужноДляВоспроизведения = МИН_РАЗМЕР_БУФЕРА;
				сПричинаПеремотки += 'Перепрыгиваю яму. ';
				чПеремотатьДо = оБуфер.start(чОбласть);
			}
			чДоКонцаОбласти = оБуфер.end(чОбласть) - чПеремотатьДо;
			if (чДоКонцаОбласти >= чНужноДляВоспроизведения)
			{
				лВоспроизведениеВозможно = true;
				break;
			}
		}

		if (!лВоспроизведениеВозможно && !_oMediaElement.paused)
		{
			// Остановить воспроизведение если нужно.
			БуферИсчерпан(чДоКонцаОбласти, чНеПросмотрено, чБудетДобавлено);
		}
		
		if ((лВоспроизведениеВозможно || чИсточникПроверки === ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА) &&  чПеремотатьДо !== чТекущееВремя)
		{
			ПоказатьСостояние(сПричинаПеремотки ? 'Ой' : 'Окак', `${сПричинаПеремотки}Перематываю до ${чПеремотатьДо}`)
			_лПропуститьWaiting = !_oMediaElement.paused && _oMediaElement.readyState >= HTMLMediaElement.HAVE_FUTURE_DATA;
			_oMediaElement.currentTime = чПеремотатьДо;
			// Edge 15 и Chrome 59: _oMediaElement.seeking возвращает false после изменения _oMediaElement.currentTime.
			// В Chrome 59 бывает редко. https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12581492/
			return ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ;
		}

		return лВоспроизведениеВозможно ? ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО : ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО;
	}

	function НачатьВоспроизведение(чПроверка /* необязательный */)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaElement.play().
	//
	// Firefox 45: После окончания перемотки, _oMediaElement.readyState может остаться равным HAVE_CURRENT_DATA. Возможно
	// потому что после _oMediaElement.currentTime доступно < 25 кадров. Для увеличения _oMediaElement.readyState
	// нужно вызвать _oMediaElement.play().
	//
	// Firefox 45: Если УдалитьПросмотренноеВидео() удалит из буфера всё видео, но оставит часть звука, то возможно состояние:
	// _oMediaElement.readyState == HAVE_CURRENT_DATA и _oMediaElement.buffered.length == 0.
	{
		if ((_oMediaElement.seeking || чПроверка === ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО_ПОСЛЕ_ПЕРЕМОТКИ) || !_oMediaElement.paused || _oMediaElement.ended)
		{
			return;
		}

		if (_лЖдатьЗаполненияБуфера && _oMediaSource.readyState !== 'ended')
		{
			const {чНеПросмотрено} = ПолучитьЗаполненностьБуфера();
			const чРазмерБуфера = м_Настройки.Получить(_сРазмерБуфера);
			if (чНеПросмотрено < чРазмерБуфера)
			{
				м_Журнал.Вот(`[Проигрыватель] В буфере не просмотрено ${м_Журнал.F3(чНеПросмотрено)}с < ${чРазмерБуфера}с`);
				return;
			}
			м_Журнал.Окак(`[Проигрыватель] В буфере не просмотрено ${м_Журнал.F3(чНеПросмотрено)}с >= ${чРазмерБуфера}с`);
		}
		else
		{
			м_Журнал.Окак('[Проигрыватель] Не нужно ждать заполнения буфера');
		}

		switch (ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ))
		{
		case ВОСПРОИЗВЕДЕНИЕ_НЕВОЗМОЖНО:
			ПоказатьСостояние('Ой', `Не найдена область >= ${МИН_РАЗМЕР_БУФЕРА}с для начала воспроизведения`);
			_лЖдатьЗаполненияБуфера = true;
			break;

		// Не начинаем воспроизведение во время перемотки, потому что ПроверитьПозициюВоспроизведения() могла перескочить
		// яму, из-за чего длительность непросмотренного видео могла упасть ниже _сРазмерБуфера. Нужно проверить
		// заполненность буфера еще раз.
		case ВОСПРОИЗВЕДЕНИЕ_ВОЗМОЖНО:
			ПоказатьСостояние('Окак', 'Начало воспроизведения');
			_лЖдатьЗаполненияБуфера = true;
			_лПропуститьWaiting = _oMediaElement.readyState < HTMLMediaElement.HAVE_FUTURE_DATA;
			_oMediaElement.play();
			// Chrome 67, Firefox 60 Android, Edge 17: В этот момент даже без блокировок возможно _oMediaElement.paused == true.
			//
			// Может пройти больше секунды, прежде чем начало видео будет декодировано и показано.
			// Ждем события playing для смены состояния.
			//
			// Firefox 45: Иногда, скорее всего из-за ошибки лисы, после события seeked и вызова play(),
			// readyState остается равно HAVE_METADATA и не прилетают loadeddata, canplay, canplaythrough
			// и playing. Воспроизведение идет нормально (не знаю насколько долго).
			м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ);
			break;
		}
	}

	function ОстановитьВоспроизведение(чНовоеСостояние)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaElement.pause().
	{
		if (чНовоеСостояние !== undefined)
		{
			м_Управление.ИзменитьСостояние(чНовоеСостояние);
		}
		_oMediaElement.pause();
	}

	function БуферИсчерпан(чДоКонцаПоследнейОбласти, чНеПросмотрено, чБудетДобавлено)
	{
		Проверить(_oMediaSource.readyState !== 'ended');
		const лДосрочно = чНеПросмотрено > 1.0;
		м_Статистика.ИсчерпанБуферПроигрывателя(лДосрочно);
		_сРазмерБуфера = 'чМаксРазмерБуфера';
		const чРазмерБуфера = м_Настройки.Получить(_сРазмерБуфера);
		if (чДоКонцаПоследнейОбласти + чБудетДобавлено >= МИН_РАЗМЕР_БУФЕРА && чНеПросмотрено + чБудетДобавлено >= чРазмерБуфера)
		{
			// Это может произойти с нулевым чБудетДобавлено:
			// - Firefox 54 и ИСПОЛЬЗОВАТЬ_WAITING: Исчерпание буфера произошло во время appendBuffer():
			//   readyState=HAVE_ENOUGH_DATA ▪ appendBuffer() ▪ readyState=HAVE_CURRENT_DATA ▪ timeupdate ▪ waiting
			// - Firefox 48 и ИСПОЛЬЗОВАТЬ_WAITING: Остановка перед невидимой ямой, которая появилась из-за перепутаных CTS кадров.
			ПоказатьСостояние(лДосрочно ? 'Ой' : 'Окак', `Буфер исчерпан, остановка не нужна БудетДобавлено=${м_Журнал.F3(чБудетДобавлено)}с ДоКонцаПоследнейОбласти=${м_Журнал.F3(чДоКонцаПоследнейОбласти)}с НеПросмотрено=${м_Журнал.F3(чНеПросмотрено)}с РазмерБуфера=${чРазмерБуфера}с`);
		}
		else
		{
			ПоказатьСостояние(лДосрочно ? 'Ой' : 'Окак', `Приостанавливаю воспроизведение для заполнения буфера ДоКонцаПоследнейОбласти=${м_Журнал.F3(чДоКонцаПоследнейОбласти)}с НеПросмотрено=${м_Журнал.F3(чНеПросмотрено)}с РазмерБуфера=${чРазмерБуфера}с`);
			// Вместо pause() можно обнулить playbackRate.
			ОстановитьВоспроизведение(СОСТОЯНИЕ_ЗАГРУЗКА);
		}
	}

	function ЗавершитьПоток(оСегмент)
	// Это единственная функция, которая во время прямой трансляции вызывает _oMediaSource.endOfStream().
	// Chrome 50: До endOfStream() _oMediaElement.duration может быть еще = NaN.
	// Chrome 49: Если не было appendBuffer(), то после endOfStream() _oMediaElement.duration = Infinity.
	// https://bugs.chromium.org/p/chromium/issues/detail?id=604353
	{
		ПоказатьСостояние('Окак', `Сегмент ${оСегмент.чНомер} вызвал окончание потока`);
		// После endOfStream() в _oMediaElement.buffered могут появиться области без звука или видео. Firefox 48, согласно текущей
		// версии стандарта, на такие места не перематывает. Chrome 52 перематывает и воспроизводит. Чтобы в Firefox воспроизведение
		// не зависло, проверяем _oMediaElement.buffered ДО вызова endOfStream(). https://bugzilla.mozilla.org/show_bug.cgi?id=1294412
		if (_oMediaElement.buffered.length === 0
		// Часто перед окончанием потока в буфере остается ИСЧЕРПАНИЕ_БУФЕРА (если не ИСПОЛЬЗОВАТЬ_WAITING) и несколько кадров,
		// застревающих в рабочем потоке: Пауза ▪ Воспроизведение нескольких кадров ▪ Пауза ▪ Воспроизведение другого видео.
		// Смотрить на это не слишком приятно, поэтому не начинаем воспроизведение ради нескольких кадров.
		|| (_oMediaElement.paused && ПолучитьЗаполненностьБуфера().чНеПросмотрено < ИСЧЕРПАНИЕ_БУФЕРА + 0.1))
		{
			ПерезагрузитьИЖдатьЗаполненияБуфера(СОСТОЯНИЕ_ЗАГРУЗКА);
		}
		else
		{
			// Перемотка во время прямой трансляции означает, что в буфере достаточно данных для воспроизведения.
			_лЖдатьЗаполненияБуфера = typeof оСегмент.пДанные === 'number' || (!_oMediaElement.seeking && _oMediaElement.paused);
			_oMediaSource.endOfStream();
			НачатьВоспроизведение();
		}
	}

	function УдалитьПросмотренноеВидео(оСегмент)
	{
		const чДлительностьПовтора = м_Настройки.Получить('чДлительностьПовтора2');
		if (чДлительностьПовтора === АВТОНАСТРОЙКА)
		{
			return Promise.resolve(оСегмент);
		}
		const {чПросмотрено, чНеПросмотрено} = ПолучитьЗаполненностьБуфера(_oMediaSourceBuffer.buffered);
		let чУдалитьДо;
		{
			if (чПросмотрено < чДлительностьПовтора + ИНТЕРВАЛ_УДАЛЕНИЯ_ВИДЕО)
			{
				return Promise.resolve(оСегмент);
			}
			чУдалитьДо = _oMediaElement.currentTime - чДлительностьПовтора;
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			ПоказатьСостояние('Вот', `Удаляю просмотренное видео Просмотрено=${м_Журнал.F3(чПросмотрено)}с УдалитьДо=${м_Журнал.F3(чУдалитьДо)}с`);
			_oMediaSourceBuffer.addEventListener('updateend', Удалено);
			let чПрошлоВремени = -performance.now();
			_oMediaSourceBuffer.remove(0, чУдалитьДо);

			function Удалено()
			{
				try
				{
					// Удаление прервано в ПерезагрузитьПроигрыватель()? Обрабатывать событие abort не нужно.
					if (_oMediaSourceBuffer === null)
					{
						фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
					}
					else
					{
						чПрошлоВремени += performance.now();
						_oMediaSourceBuffer.removeEventListener('updateend', Удалено);
						const {чПросмотрено} = ПолучитьЗаполненностьБуфера(_oMediaSourceBuffer.buffered);
						ПоказатьСостояние(чПрошлоВремени > 100 || чПросмотрено < МИН_РАЗМЕР_БУФЕРА ? 'Ой' : 'Вот',
							`Просмотренное видео удалено за ${м_Журнал.F0(чПрошлоВремени)}мс Просмотрено=${м_Журнал.F0(чПросмотрено)}с`);
						фВыполнить(оСегмент);
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			}
		});
	}

	function ДобавитьСегментИнициализации(оСегмент)
	{
		return ДобавитьСегмент(оСегмент, оСегмент.пДанные.мбСегментИнициализации, 'сегмент инициализации');
	}

	function ДобавитьМедиасегмент(оСегмент)
	{
		return ДобавитьСегмент(оСегмент, оСегмент.пДанные.мбМедиасегмент, 'медиасегмент');
	}

	function ДобавитьСегмент(оСегмент, мбДобавить, сДобавить)
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			ПоказатьСостояние('Вот', `Добавляю ${сДобавить} ${оСегмент.чНомер}`);
			_oMediaSourceBuffer.addEventListener('updateend', Добавлено);
			let чПрошлоВремени = -performance.now();
			_oMediaSourceBuffer.appendBuffer(мбДобавить);
		
			function Добавлено()
			{
				try
				{
					// Добавление прервано в ПерезагрузитьПроигрыватель()? Обрабатывать событие abort не нужно.
					if (_oMediaSourceBuffer === null)
					{
						фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
					}
					else
					{
						чПрошлоВремени += performance.now();
						_oMediaSourceBuffer.removeEventListener('updateend', Добавлено);
						ПоказатьСостояние(чПрошлоВремени > 100 ? 'Ой' : 'Вот',
							`Добавлен ${сДобавить} ${оСегмент.чНомер} за ${м_Журнал.F0(чПрошлоВремени)}мс`);
						// HACK Firefox 63: В потоке есть только аудиодорожка. Буфер проигрывателя заполнен. Если в обработчике
						// updateend выполнить обещание и в следующем обработчике цепочки обещаний выполнить appendBuffer(), то браузер
						// не сможет освободить часть буфера для добавления новых данных и кинет исключение QuotaExceededError.
						// Даем время браузеру оклематься после добавления. При необходимости задержку можно увеличить.
						setTimeout(() => {фВыполнить(оСегмент)}, 0);
					}
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			}
		});
	}

	function ПроверитьИсчерпаниеБуфера(оСегмент)
	{
		// Firefox 54 + WMF: Предполагаемая схема работы декодера видео: На вход подается группа из ≈25 кадров. Декодированные кадры
		// можно получить подав на вход новую группу или сбросив состояние декодера. В последнем случае для декодирования следующей
		// группы необходимо начинать декодирование от ближайшего ключевого кадра.
		//
		// Добавление сегмента, когда в буфере меньше ≈25 кадров непросмотренного видео: Состояние декодера сброшено, новый сегмент
		// декодируется начиная с ключевого кадра предыдущего сегмента (BUG ПОЧЕМУ ПРЕДЫДУЩЕГО?). Как правило ключевой кадр находится
		// в начале сегмента, на декодирование полного сегмента может быть потрачено больше секунды. За это время закончатся
		// декодированные кадры в буфере проигрывателя и изображение на экране перестанет обновляться, счетчик пропущенных кадров
		// станет расти.
		//
		// Чтобы избежать пропуск кадров, если перед добавлением сегмента слишком мало непросмотренного видео, то откладываем
		// добавление до исчерпания буфера. В этом случае Firefox начнет воспроизведение только после окончания декодирования.
		//
		// TODO Оставить эту проверку только для винды?
		// UNDONE УМЕНЬШАТЬ_РЫВКИ все еще актуальна?
		if (!_oMediaElement.seeking && !_oMediaElement.paused && !_oMediaElement.ended && _oMediaElement.readyState >= HTMLMediaElement.HAVE_FUTURE_DATA)
		{
			const {чНеПросмотрено} = ПолучитьЗаполненностьБуфера();
			const чПорог = м_Статистика.ПолучитьДлительностьКадраВСекундах().чМаксимальная * 25 + 0.050;
			if (чНеПросмотрено < чПорог)
			{
				м_Журнал.Ой(`[Проигрыватель] Перед добавлением сегмента не просмотрено ${м_Журнал.F3(чНеПросмотрено)}с < ${м_Журнал.F3(чПорог)}с. Добавление отложено.`);
				throw 'ДОБАВЛЕНИЕ СЕГМЕНТА ОТЛОЖЕНО';
			}
		}
		return оСегмент;
	}

	function СегментБылДобавлен(оСегмент)
	{
		_лАсинхроннаяОперация = false;
		г_моОчередь.Удалить(оСегмент);
		РасчитатьСмещениеТрансляции(оСегмент);
		// Нет смысла начинать воспроизведение если запрошен повтор.
		if (!(г_моОчередь[0] && г_моОчередь[0].пДанные === СОСТОЯНИЕ_ПОВТОР))
		{
			// Предотвратить переполнение буфера проигрывателя.
			const чПроверка = ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_ДОБАВЛЕНИЕ_СЕГМЕНТА);
			// Начать воспроизведение только после добавления всех накопившихся в очереди преобразованных сегментов.
			// Во время добавления части добавленного потока могут многократно удаляться из-за переполнения буфера.
			// Похожая проверка есть в ОбработатьProgress().
			if (!(г_моОчередь[0] && г_моОчередь[0].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН))
			{
				НачатьВоспроизведение(чПроверка);
				// Желательно вызвать после изменения currentTime в НачатьВоспроизведение().
				ПоказатьЗадержкуТрансляции(оСегмент);
			}
		}
		ДобавитьСледующийСегмент();
	}

	const СегментНеБылДобавлен = ДобавитьОбработчикИсключений(пПричина =>
	{
		_лАсинхроннаяОперация = false;
		if (пПричина === 'ДОБАВЛЕНИЕ СЕГМЕНТА ОТЛОЖЕНО')
		{
			return;
		}
		// ПерезагрузитьПроигрыватель() прервала выполнение УдалитьПросмотренноеВидео() или ДобавитьСегмент()?
		// Вызвавший во время асинхронной операции ПерезагрузитьПроигрыватель() должен сам удалить не добавленный сегмент из очереди.
		if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
		{
			м_Журнал.Вот('[Проигрыватель] Отменено добавление сегмента');
		}
		else
		{
			throw пПричина;
		}
	});

	function ПредотвратитьПереполнениеОчереди()
	// Chrome 49: _oMediaSource закрыт до первого перехода на вкладку. Если пользователь забудет перейти, то получим переполнение
	// очереди. Немного ждем и останавливаем работу, чтобы избежать переполнения и не нагружать напрасно железо.
	// TODO Если в очереди есть разрывы, то теоретически задержка трансляции может превышать указанную в настройках проигрывателя.
	{
		// Нет смысла накапливать больше ПЕРЕПОЛНЕНИЕ_БУФЕРА, потому что этот излишек будет пропущен. Останавливать просмотр трансляции
		// по достижении чРазмерБуфера или даже чРазмерБуфера + чРастягиваниеБуфера слишком рано, потому что пользователь с широким каналом
		// не успеет переключиться на вкладку.
		const {чДлительность} = г_моОчередь.ПодсчитатьПреобразованныеСегменты();
		if (чДлительность >= ПЕРЕПОЛНЕНИЕ_БУФЕРА)
		{
			м_Журнал.Ой(`[Проигрыватель] MediaSource закрыт слишком долго ${чДлительность}с >= ${ПЕРЕПОЛНЕНИЕ_БУФЕРА}с`);
			Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ЗАПУСК || м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ);
			м_Управление.ОстановитьПросмотрТрансляции();
		}
	}

	function НайтиИОбработатьСменуВариантаТрансляции()
	{
		for (let ы = г_моОчередь.length; --ы >= 0;)
		{
			if (г_моОчередь[ы].пДанные === СОСТОЯНИЕ_СМЕНА_ВАРИАНТА && г_моОчередь[ы].чОбработка === ОБРАБОТКА_ПРЕОБРАЗОВАН)
			{
				г_моОчередь.ПоказатьСостояние();
				do
				{
					if (г_моОчередь[ы].пДанные === СОСТОЯНИЕ_СМЕНА_ВАРИАНТА || typeof г_моОчередь[ы].пДанные !== 'number')
					{
						г_моОчередь.Удалить(ы);
					}
				}
				while (--ы >= 0);
				г_моОчередь.ПоказатьСостояние();

				ПерезагрузитьИЖдатьЗаполненияБуфера(СОСТОЯНИЕ_ЗАГРУЗКА);
				break;
			}
		}
	}

	function ДобавитьСледующийСегмент()
	{
		Проверить(_oMediaElement);

		НайтиИОбработатьСменуВариантаТрансляции();
		const оСегмент = г_моОчередь[0];
		if (!оСегмент || оСегмент.чОбработка !== ОБРАБОТКА_ПРЕОБРАЗОВАН)
		{
			return;
		}
		Проверить(_оПоведение === _оПрямаяТрансляция);

		if (оСегмент.пДанные === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
		{
			Проверить(_oMediaSource.sourceBuffers.length === 0);
			_чСмещениеТрансляции = NaN;
			м_Управление.ИзменитьСостояние(оСегмент.пДанные);
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		if (_лАсинхроннаяОперация)
		{
			return;
		}

		if (оСегмент.пДанные === СОСТОЯНИЕ_ПОВТОР)
		{
			Проверить(м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ОСТАНОВКА && м_Управление.ПолучитьСостояние() !== СОСТОЯНИЕ_ПОВТОР);
			ЗапуститьПовтор();
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		const сГотовность = _oMediaSource.readyState;
		if (сГотовность !== 'open')
		{
			м_Журнал.Вот(`[Проигрыватель] Добавление сегмента ${оСегмент.чНомер} отложено MediaSource.readyState=${сГотовность} MediaElement.src=${_oMediaElement.src}`);
			if (сГотовность === 'closed' && _чВоспроизведениеНачиналось === 0)
			{
				ПредотвратитьПереполнениеОчереди();
			}
			return;
		}

		if (оСегмент.лРазрыв && _oMediaSource.sourceBuffers.length !== 0)
		{
			ЗавершитьПоток(оСегмент);
			return;
		}

		if (оСегмент.пДанные === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ)
		{
			Проверить(оСегмент.лРазрыв && _oMediaSource.sourceBuffers.length === 0);
			м_Управление.ИзменитьСостояние(оСегмент.пДанные);
			г_моОчередь.Удалить(0);
			ДобавитьСледующийСегмент();
			return;
		}

		if (_oMediaSource.sourceBuffers.length === 0)
		{
			ДобавитьБуферы(оСегмент);
			м_Управление.ОбновитьКоличествоДорожек(оСегмент.пДанные.лЕстьВидео, оСегмент.пДанные.лЕстьЗвук);
		}

		_лАсинхроннаяОперация = true;
		let оОбещание = УдалитьПросмотренноеВидео(оСегмент)
		.then(ПроверитьИсчерпаниеБуфера);
		if (оСегмент.пДанные.мбСегментИнициализации)
		{
			оОбещание = оОбещание.then(ДобавитьСегментИнициализации);
		}
		оОбещание.then(ДобавитьМедиасегмент)
		.then(СегментБылДобавлен)
		.catch(СегментНеБылДобавлен);
	}

	function ПеремотатьПовторДо(чПеремотатьДо)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		_оПовтор.ПроверитьПозициюВоспроизведения(чПеремотатьДо);
	}

	function ПеремотатьПовторНа(лКадры, чПеремотатьНа)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		Проверить(Number.isFinite(чПеремотатьНа));
		if (лКадры)
		{
			чПеремотатьНа *= м_Статистика.ПолучитьДлительностьКадраВСекундах().чМинимальная;
		}
		if (чПеремотатьНа !== 0)
		{
			ПеремотатьПовторДо(Ограничить(_oMediaElement.currentTime + чПеремотатьНа, м_Шкала.ПолучитьНачало(), м_Шкала.ПолучитьКонец()));
		}
	}

	function ПереключитьПаузу()
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		if (_оПовтор.лПауза = !_оПовтор.лПауза)
		{
			м_Журнал.Окак('[Проигрыватель] Ставлю повтор на паузу');
			_oMediaElement.pause();
		}
		else
		{
			м_Журнал.Окак('[Проигрыватель] Снимаю повтор с паузы');
			_оПовтор.ПроверитьПозициюВоспроизведения(ПРОВЕРИТЬ_НАЧАЛО_ВОСПРОИЗВЕДЕНИЯ);
			_oMediaElement.play();
		}
		м_События.ПослатьСобытие('проигрыватель-пауза', _оПовтор.лПауза);
	}

	function ЗадатьСкоростьПовтора(чСкорость)
	{
		Проверить(м_Управление.ПолучитьСостояние() === СОСТОЯНИЕ_ПОВТОР);
		_oMediaElement.playbackRate = чСкорость;
	}

	function ЗапуститьПовтор()
	{
		_оПовтор.лПауза = true;
		_оПоведение = _оПовтор;
		ОстановитьВоспроизведение();
		// Chrome 52: Если вызвать endOfStream() до addSourceBuffer(), то _oMediaElement.error.code = MEDIA_ERR_SRC_NOT_SUPPORTED.
		if (_oMediaSource.sourceBuffers.length !== 0 && _oMediaSource.readyState === 'open')
		{
			_oMediaSource.endOfStream();
		}

		const {чПросмотрено} = ПолучитьЗаполненностьБуфера();
		// В ПроверитьПозициюВоспроизведения() часть видео может быть промотана еще до начала воспроизведения.
		if (_oMediaElement.played.length === 0 || чПросмотрено < ПОВТОР_НЕДОСТУПЕН_ЕСЛИ_ПРОСМОТРЕНО_МЕНЬШЕ_ЧЕМ)
		{
			ПоказатьСостояние('Окак', 'Повторять нечего');
			м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ОСТАНОВКА);
			return;
		}

		ПоказатьСостояние('Окак', 'Запуск повтора');
		_oMediaElement.playbackRate = м_Управление.ПолучитьСкоростьВоспроизведения();
		м_События.ПослатьСобытие('проигрыватель-пауза', _оПовтор.лПауза);
		// Chrome 48: Иногда currentTime вылезает за пределы области.
		м_Шкала.ЗадатьНачалоИКонец(_oMediaElement.buffered.start(0), _oMediaElement.buffered.start(0) + чПросмотрено);
		м_Шкала.ЗадатьПросмотрено(_oMediaElement.currentTime);
		м_Управление.ИзменитьСостояние(СОСТОЯНИЕ_ПОВТОР);
	}

	function ДобавитьБуферы(оСегмент)
	{
		м_Журнал.Окак(`[Проигрыватель] Добавляю буфер ${оСегмент.пДанные.сКодеки}`);
		Проверить(оСегмент.лРазрыв && оСегмент.пДанные.сКодеки);
		try
		{
			_oMediaSourceBuffer = _oMediaSource.addSourceBuffer(оСегмент.пДанные.сКодеки);
		}
		catch (пИсключение)
		{
			// Edge 15 кидает DOMException, которое не является потомком Error.
			if (ЭтоОбъект(пИсключение) && пИсключение.name === 'NotSupportedError')
			{
				м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0201');
			}
			else
			{
				м_Отладка.ПойманоИсключение(пИсключение);
			}
		}
		_oMediaSourceBuffer.addEventListener('updatestart', СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('update',      СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('updateend',   СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('abort',       СледитьЗаСобытиямиMediaSource);
		_oMediaSourceBuffer.addEventListener('error',       СледитьЗаСобытиямиMediaSource);
	}

	function Запустить()
	{
		Проверить(!_oMediaElement);

		try
		{
			_oMediaSource = new MediaSource();
		}
		catch (_)
		{
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0202');
		}
		_oMediaSource.addEventListener('sourceopen',                       СледитьЗаСобытиямиMediaSource);
		_oMediaSource.addEventListener('sourceended',                      СледитьЗаСобытиямиMediaSource);
		_oMediaSource.addEventListener('sourceclose',                      СледитьЗаСобытиямиMediaSource);
		_oMediaSource.sourceBuffers.addEventListener('addsourcebuffer',    СледитьЗаСобытиямиMediaSource);
		_oMediaSource.sourceBuffers.addEventListener('removesourcebuffer', СледитьЗаСобытиямиMediaSource);

		_oMediaElement = document.getElementById('глаз');
		ПрименитьНастройкиЗвука();
		for (let сСобытие of
		[
			'progress', 'error', 'playing', 'seeking', 'seeked', 'ended', 'timeupdate',
			'waiting',
			'loadstart', 'suspend', 'abort', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata',
			'canplay', 'canplaythrough', 'durationchange', 'play', 'pause', 'ratechange', 'resize'
		])
		{
			_oMediaElement.addEventListener(сСобытие, СледитьЗаСобытиямиMediaElement);
		}
		// Firefox 50+: Браузер блокирует воспроизведение, пока в обработчике действия пользователя не будут
		// вызваны play() или load(). Во время снятия с паузы наш проигрыватель вызывает load().
		// Включение: media.autoplay.enabled = false.
		// https://bugzilla.mozilla.org/show_bug.cgi?id=659285#c113
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1231886#c21
		// Firefox 61=: Эту блокировку невозможно обнаружить нижеприведенным способом.
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1463727
		// Firefox 53+: Браузер откладывает воспроизведение и посылку событий до первого перехода на вкладку.
		// В подобной ситуации Chrome задерживает открытие MediaSourse. Эмулируем действия Chrome, чтобы
		// код и логика проигрывателя были одинаковыми во всех браузерах.
		// Отключение: media.block-autoplay-until-in-foreground = false.
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1308154
		Проверить(_oMediaElement.paused);
		_oMediaElement.play();
		if (!_oMediaElement.paused)
		{
			// Менять src в последнюю очередь, чтобы play() и pause() не влияли на состояние и не посылали ненужных событий.
			_oMediaElement.pause();
			_oMediaElement.src = URL.createObjectURL(_oMediaSource);
			return true;
		}
		if (м_Фокусник.ПолучитьСостояние().лПоказан)
		{
			ПоказатьСостояние('Ой', '[Проигрыватель] media.autoplay.enabled = false');
			_oMediaElement.pause();
			_oMediaElement.src = URL.createObjectURL(_oMediaSource);
			return false;
		}
		// Пока не ясно, какая из двух настроек блокирует воспроизведение.
		ПоказатьСостояние('Окак', '[Проигрыватель] Воспроизведение заблокировано до перехода на вкладку');
		_oMediaElement.pause();
		м_События.ДобавитьОбработчик('фокусник-изменилосьсостояние', function ОбработатьПереходНаВкладку({лПоказан}, сСобытие)
		{
			if (лПоказан)
			{
				м_События.УдалитьОбработчик(сСобытие, ОбработатьПереходНаВкладку);
				Проверить(_oMediaElement.paused);
				_oMediaElement.play();
				if (!_oMediaElement.paused)
				{
					ПоказатьСостояние('Окак', '[Проигрыватель] Воспроизведение разблокировано');
					_oMediaElement.pause();
					_oMediaElement.src = URL.createObjectURL(_oMediaSource);
				}
				else
				{
					ПоказатьСостояние('Ой', '[Проигрыватель] media.autoplay.enabled = false');
					_oMediaElement.pause();
					_oMediaElement.src = URL.createObjectURL(_oMediaSource);
					м_Управление.ОстановитьПросмотрТрансляции();
				}
			}
		});
		return true;
	}

	function Остановить()
	{
		if (_oMediaElement)
		{
			URL.revokeObjectURL(_oMediaElement.src);
			_oMediaElement.removeAttribute('src');
			_oMediaElement.load();
		}
	}

	return {
		Запустить, Остановить,
		ПолучитьЗаполненностьБуфера, ПолучитьКоличествоПропущенныхКадров, ПолучитьПозициюВоспроизведенияТрансляции,
		ПоказатьСостояние,
		Перезагрузить: ПерезагрузитьИЖдатьЗаполненияБуфера,
		ПрименитьНастройкиЗвука,
		ДобавитьСледующийСегмент,
		ПеремотатьПовторДо, ПеремотатьПовторНа, ПереключитьПаузу, ЗадатьСкоростьПовтора
	};
})();

const м_Список = (() =>
{
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_НАЧАЛО      = 3000;  // Миллисекунды.
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_КОНЕЦ       = 30000; // Миллисекунды.
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_ШАГ         = 1000;  // Миллисекунды.

	const ДОБАВИТЬ_К_ИНТЕРВАЛУ_ОБНОВЛЕНИЯ_СПИСКА_СЕГМЕНТОВ = 150;   // Миллисекунды. Длительность сегмента может быть чуть больше чем обычно.
	                                                                // Новый сегмент может быть доступен чуть позже чем обычно.
	const КОЛИЧЕСТВО_СЕГМЕНТОВ_ДЛЯ_РАСЧЕТА_ИНТЕРВАЛА       = 10;    // Количество.

	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ - идет трансляция.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ - трансляция завершена, периодически проверять ее начало.
	// СОСТОЯНИЕ_ОСТАНОВКА - работа полностью остановлена.
	let _чСостояние = СОСТОЯНИЕ_ОСТАНОВКА;
	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ - индекс последнего сегмента в _мчДлительностьСегментов.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ - интервал обновления списка вариантов.
	let _чИнтервалОбновленияСписка;
	// Кольцевой буфер, в котором хранятся длительности последних сегментов.
	// Используется для расчета интервала обновления списка сегментов.
	let _мчДлительностьСегментов = new Array(КОЛИЧЕСТВО_СЕГМЕНТОВ_ДЛЯ_РАСЧЕТА_ИНТЕРВАЛА);
	let _ооОбновлениеСписков = new ОтменаОбещания();
	// Список отсортирован по убыванию nPeakBitrate. Исходный вариант всегда в начале списка.
	// {
	//   nPeakBitrate
	//   сИдентификатор
	//   сНазвание
	//   сАбсолютныйАдресСпискаСегментов
	//   сКодеки
	// }
	let _моСписокВариантов = null;
	// Индекс _моСписокВариантов.
	let _чВыбранныйВариант;
	// {
	//   nTargetDuration,
	//   nMediaSequenceNumber,
	//   лКонецСписка,
	//   моСегменты:
	//   {
	//     сАдрес,
	//     чДлительность,
	//     лРазрыв
	//   }
	// }
	let _оПоследнийСписок = null;

	function РазобратьСписок(лЭтоСписокВариантов, сАбсолютныйАдресСписка, сРазбираемыйСписок)
	{
		// https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-02
		// Версия 8 пока не поддерживается.
		const МАКС_ПОДДЕРЖИВАЕМАЯ_ВЕРСИЯ_HLS = 7;

		// Иногда вместе с кодом 200 вместо списка прилетает HTML произвольного содержания. Например
		// 400 Bad Request (nginx) или сообщение об окончании денег на счете интернет-провайдера. :)
		if (!сРазбираемыйСписок.startsWith('#EXTM3U'))
		{
			throw `Вместо списка загружена какая-то фигня длиною ${сРазбираемыйСписок.length}\n${сРазбираемыйСписок}`;
		}

		let чВерсия = 1;
		let mapRenditionGroups, моСписокВариантов, оНовыйВариант;
		let чДлительностьСписка, nMediaSequenceNumber, nTargetDuration, лКонецСписка, лРазрыв, моСегменты, оНовыйСегмент;
		if (лЭтоСписокВариантов)
		{
			mapRenditionGroups = new Map(); // Порядок элементов не важен.
			моСписокВариантов = [];
			оНовыйВариант = null; // Используется для проверки порядка следования тегов.
		}
		else
		{
			чДлительностьСписка = 0; // Статистика.
			nMediaSequenceNumber = 0;
			лРазрыв = false;
			моСегменты = [];
			оНовыйСегмент = null; // Используется для проверки порядка следования тегов.
		}

		const рвТегИлиАдрес = /^#([A-Z0-9\-]+)(?::(.+))?$|^[^#\r\n].*$/mg;
		// Пропускаем #EXTM3U.
		рвТегИлиАдрес.lastIndex = 7;
		for (let мсТегИлиАдрес; мсТегИлиАдрес = рвТегИлиАдрес.exec(сРазбираемыйСписок);)
		{
			let [сАдрес, сНазваниеТега, сЗначениеТега] = мсТегИлиАдрес;

			if (сАдрес.charAt(0) !== '#')
			{
				сАдрес = ResolveRelativeUrl(сАдрес, сАбсолютныйАдресСписка);
				if (лЭтоСписокВариантов)
				{
					Проверить(оНовыйВариант);
					оНовыйВариант.сАбсолютныйАдресСпискаСегментов = сАдрес;
					моСписокВариантов.push(оНовыйВариант);
					оНовыйВариант = null;
				}
				else
				{
					Проверить(оНовыйСегмент);
					Проверить(!лКонецСписка);
					оНовыйСегмент.лРазрыв = лРазрыв;
					оНовыйСегмент.сАдрес = сАдрес;
					моСегменты.push(оНовыйСегмент);
					чДлительностьСписка += оНовыйСегмент.чДлительность;
					лРазрыв = false;
					оНовыйСегмент = null;
				}
				continue;
			}

			switch (сНазваниеТега)
			{
			//
			// Теги общие для обоих типов списка.
			// #EXT-X-INDEPENDENT-SEGMENTS не используется.
			//
			case 'EXTM3U':
				Проверить(false);
				break;

			case 'EXT-X-VERSION':
				Проверить(чВерсия === 1);
				чВерсия = РазобратьЦелоеПоложительноеЧисло(сЗначениеТега);
				Проверить(чВерсия >= 2 && чВерсия <= МАКС_ПОДДЕРЖИВАЕМАЯ_ВЕРСИЯ_HLS);
				break;

			case 'EXT-X-START':
			case 'EXT-X-DEFINE':
				Проверить(false);
				break;

			//
			// Теги списка вариантов.
			//
			case 'EXT-X-MEDIA':
			{
				Проверить(лЭтоСписокВариантов);
				const амАтрибуты = РазобратьСписокАтрибутов(сЗначениеТега);
				const сТип = амАтрибуты.get('TYPE');
				Проверить(сТип);
				// Видео и звук должны находиться в одном файле.
				Проверить((сТип !== 'VIDEO' && сТип !== 'AUDIO') || !амАтрибуты.has('URI'));
				if (сТип !== 'VIDEO')
				{
					м_Журнал.Ой(`[Список] Найден #EXT-X-MEDIA TYPE=${сТип}`);
				}
				else
				{
					const сГруппа = РазобратьСтроку(амАтрибуты.get('GROUP-ID'));
					Проверить(!mapRenditionGroups.has(сГруппа));
					mapRenditionGroups.set(сГруппа, РазобратьСтроку(амАтрибуты.get('NAME')));
				}
				break;
			}

			case 'EXT-X-STREAM-INF':
			{
				Проверить(лЭтоСписокВариантов);
				// Пропущен адрес?
				Проверить(!оНовыйВариант);
				оНовыйВариант = Object.create(null);
				const амАтрибуты = РазобратьСписокАтрибутов(сЗначениеТега);
				// Иногда после завершения трансляции BANDWIDTH=0.
				оНовыйВариант.nPeakBitrate = РазобратьЦелоеПоложительноеЧисло(амАтрибуты.get('BANDWIDTH'));
				оНовыйВариант.сКодеки = амАтрибуты.has('CODECS') ? РазобратьСтроку(амАтрибуты.get('CODECS')) : '';
				Проверить(!амАтрибуты.has('AUDIO') && !амАтрибуты.has('SUBTITLES') && !амАтрибуты.has('CLOSED-CAPTIONS'));
				if (амАтрибуты.has('VIDEO'))
				{
					оНовыйВариант.сИдентификатор = РазобратьСтроку(амАтрибуты.get('VIDEO'));
				}
				break;
			}

			case 'EXT-X-I-FRAME-STREAM-INF':
			case 'EXT-X-SESSION-DATA':
			case 'EXT-X-SESSION-KEY':
				Проверить(лЭтоСписокВариантов);
				break;
		
			//
			// Нестандартные теги Twitch.
			//
			case 'EXT-X-TWITCH-INFO':
			{
				Проверить(лЭтоСписокВариантов);
				// Время SERVER-TIME содержит миллисекунды и поэтому более точное, чем заголовок ответа Date.
				const чСекунды = РазобратьПоложительноеЧисло(РазобратьСтроку(РазобратьСписокАтрибутов(сЗначениеТега).get('SERVER-TIME')));
				Проверить(чСекунды > 1531267200 && чСекунды < 1846886400);
				// Добавить ко времени несколько миллисекунд, затраченных на передачу данных по сети.
				const чМиллисекунды = чСекунды * 1000 + 50;
				const чРассинхронизация = чМиллисекунды - Date.now();
				м_Журнал[Math.abs(чРассинхронизация) > 1000 ? 'Ой' : 'Окак'](`[Список] Рассинхронизация времени: ${чРассинхронизация}мс`);
				г_чТочноеВремя = чМиллисекунды - performance.now();
				break;
			}

			//
			// Теги списка сегментов для всех сегментов.
			//
			case 'EXT-X-TARGETDURATION':
				Проверить(!лЭтоСписокВариантов);
				Проверить(nTargetDuration === undefined);
				nTargetDuration = РазобратьЦелоеПоложительноеЧисло(сЗначениеТега);
				Проверить(nTargetDuration > 0 && nTargetDuration < 60);
				break;

			case 'EXT-X-MEDIA-SEQUENCE':
				Проверить(!лЭтоСписокВариантов);
				Проверить(nMediaSequenceNumber === 0);
				nMediaSequenceNumber = РазобратьЦелоеПоложительноеЧисло(сЗначениеТега);
				break;

			case 'EXT-X-ENDLIST':
				Проверить(!лЭтоСписокВариантов);
				Проверить(лКонецСписка === undefined);
				Проверить(сЗначениеТега === undefined);
				лКонецСписка = true;
				м_Журнал.Окак(`[Список] #EXT-X-ENDLIST после сегмента ${nMediaSequenceNumber + моСегменты.length - 1}`);
				break;

			case 'EXT-X-DISCONTINUITY-SEQUENCE':
				Проверить(!лЭтоСписокВариантов);
				// Пока разбирать не нужно, потому что любой пропуск сегмента добавляет разрыв.
				break;

			case 'EXT-X-PLAYLIST-TYPE':
			case 'EXT-X-I-FRAMES-ONLY':
				Проверить(false);
				break;

			//
			// Теги списка сегментов для конкретного сегмента.
			//
			case 'EXTINF':
				Проверить(!лЭтоСписокВариантов);
				// Пропущен адрес?
				Проверить(!оНовыйСегмент);
				оНовыйСегмент = Object.create(null);
				// Twitch: Непосредственно перед #EXT-X-ENDLIST встречается сегмент с небольшой отрицательной длительностью.
				// Большая отрицательная длительность очень редко встречается при потере медиаданных.
				if (сЗначениеТега.charAt(0) === '-')
				{
					м_Журнал.Ой(`[Список] У сегмента ${nMediaSequenceNumber + моСегменты.length} отрицательная длительность ${сЗначениеТега}`);
					оНовыйСегмент.чДлительность = 0;
				}
				else
				{
					const чЗапятая = сЗначениеТега.indexOf(',');
					оНовыйСегмент.чДлительность = РазобратьПоложительноеЧисло(чЗапятая === -1 ? сЗначениеТега : сЗначениеТега.slice(0, чЗапятая));
				}
				if (Math.round(оНовыйСегмент.чДлительность) > nTargetDuration)
				{
					м_Журнал.Ой(`[Список] Длительность сегмента ${nMediaSequenceNumber + моСегменты.length} больше target duration на ${оНовыйСегмент.чДлительность - nTargetDuration}с`);
					// Twitch: При потере медиаданных очень редко встречаются сегменты с аномально большой длительностью,
					// которые в теории могут привести к переполнению очереди. Содержимое сегментов неизвестно.
					if (оНовыйСегмент.чДлительность > nTargetDuration * 3)
					{
						оНовыйСегмент.чДлительность = 0;
					}
				}
				break;

			case 'EXT-X-DISCONTINUITY':
				Проверить(!лЭтоСписокВариантов);
				Проверить(!лРазрыв);
				Проверить(сЗначениеТега === undefined);
				лРазрыв = true;
				м_Журнал.Ой(`[Список] #EXT-X-DISCONTINUITY у сегмента ${nMediaSequenceNumber + моСегменты.length}`);
				break;

			case 'EXT-X-PROGRAM-DATE-TIME':
			case 'EXT-X-DATERANGE':
				Проверить(!лЭтоСписокВариантов);
				break;

			case 'EXT-X-BYTERANGE':
			case 'EXT-X-KEY':
			case 'EXT-X-MAP':
			case 'EXT-X-GAP':
				Проверить(false);
				break;
			}
		}

		if (лЭтоСписокВариантов)
		{
			// Пропущен адрес?
			Проверить(!оНовыйВариант);

			for (let оВариант of моСписокВариантов)
			{
				if ('сИдентификатор' in оВариант)
				{
					оВариант.сНазвание = mapRenditionGroups.get(оВариант.сИдентификатор);
					Проверить(оВариант.сНазвание);
				}
				else
				{
					// #EXT-X-STREAM-INF без #EXT-X-MEDIA.
					оВариант.сИдентификатор = `CoolCmd${оВариант.nPeakBitrate}`;
					оВариант.сНазвание = `${м_i18n.ФорматироватьЧисло(оВариант.nPeakBitrate / 1000000, 1)} ${Текст('J0114')}`;
				}
				м_Журнал.Окак(`[Список] Добавлен вариант PeakBitrate=${оВариант.nPeakBitrate} Идентификатор=${оВариант.сИдентификатор} Название=${оВариант.сНазвание} Кодеки=${оВариант.сКодеки}`);
			}

			моСписокВариантов.sort(СравнитьВарианты);
			return моСписокВариантов;
		}

		// Пропущен адрес?
		Проверить(!оНовыйСегмент);
		// Пропущен #EXT-X-TARGETDURATION?
		Проверить(nTargetDuration !== undefined);
		const оСписокСегментов =
		{
			nTargetDuration,
			nMediaSequenceNumber,
			лКонецСписка: !!лКонецСписка,
			моСегменты
		};
		м_Журнал.Вот(`[Список] Разобран список сегментов TargetDuration=${nTargetDuration} MediaSequenceNumber=${nMediaSequenceNumber} КоличествоСегментов=${моСегменты.length} ДлительностьСписка=${м_Журнал.F1(чДлительностьСписка)}с`);
		м_Статистика.РазобранСписокСегментов(оСписокСегментов, чДлительностьСписка);
		return оСписокСегментов;
	}

	function СравнитьВарианты(оВариант1, оВариант2)
	// Сортирует список по убыванию nPeakBitrate. Исходный вариант всегда в начале списка.
	// HACK Twitch: nPeakBitrate исходного варианта отражает текущее значение, которое может быть намного
	// меньше среднего и максимального. Также при пережатии исходного варианта битрейт может не уменьшиться,
	// а увеличиться. В этих случаях сортировка только по nPeakBitrate переместит исходный вариант
	// в неправильную позицию.
	{
		return (оВариант2.сИдентификатор === 'chunked' ? 1000000000 : оВариант2.nPeakBitrate)
		     - (оВариант1.сИдентификатор === 'chunked' ? 1000000000 : оВариант1.nPeakBitrate);
	}

	function РазобратьСписокАтрибутов(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст);
		const амАтрибуты = new Map();
		const рвАтрибут = /([A-Z0-9\-]+)=("[^"]+"|[^",][^,]*)(?:,|$)/g;
		while (рвАтрибут.lastIndex !== сИсходныйТекст.length)
		{
			const чКонецАтрибута = рвАтрибут.lastIndex;
			const мсАтрибут = рвАтрибут.exec(сИсходныйТекст);
			Проверить(мсАтрибут.index === чКонецАтрибута);
			Проверить(!амАтрибуты.has(мсАтрибут[1]));
			амАтрибуты.set(мсАтрибут[1], мсАтрибут[2]);
		}
		return амАтрибуты;
	}

	function РазобратьЦелоеПоложительноеЧисло(сИсходныйТекст)
	{
		Проверить(/^[0-9]{1,15}$/.test(сИсходныйТекст));
		return Number.parseInt(сИсходныйТекст, 10);
	}

	function РазобратьПоложительноеЧисло(сИсходныйТекст)
	{
		// Нам нужны минимум 3 цифры после запятой.
		Проверить(/^[0-9]{1,14}(?:\.[0-9]{1,15})?$/.test(сИсходныйТекст));
		return Number.parseFloat(сИсходныйТекст);
	}

	function РазобратьСтроку(сИсходныйТекст)
	{
		Проверить(сИсходныйТекст.length > 2 && сИсходныйТекст.charAt(0) === '"' && сИсходныйТекст.charAt(сИсходныйТекст.length - 1) === '"');
		return сИсходныйТекст.slice(1, -1);
	}

	function ДобавитьСегментыВОчередь(оНовыйСписок)
	// Добавляет в очередь сегменты из оНовыйСписок.
	// Если нужно, добавляет в очередь СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ.
	// Возвращает количество добавленных в очередь сегментов.
	// Изменяет _чСостояние, _оПоследнийСписок.
	{
		const чНачалоНовогоСписка = оНовыйСписок.nMediaSequenceNumber;
		const чКонецНовогоСписка = чНачалоНовогоСписка + оНовыйСписок.моСегменты.length;
		let чНачалоПоследнегоСписка, чКонецПоследнегоСписка, чИндекс;
		if (_оПоследнийСписок === null)
		{
			// После окончания трансляции список может быть доступен довольно долго.
			if (оНовыйСписок.лКонецСписка)
			{
				throw 'Найден #EXT-X-ENDLIST';
			}

			// Twitch: Возможен пустой список с #EXT-X-ENDLIST и #EXT-X-MEDIA-SEQUENCE: 0.
			Проверить(оНовыйСписок.моСегменты.length !== 0);

			// Следующий добавляемый в очередь сегмент должен быть разорван.
			ДобавитьСегментыВОчередь.лРазрыв = true;
			чНачалоПоследнегоСписка = чКонецПоследнегоСписка = -1;

			чИндекс = оНовыйСписок.моСегменты.length;
			for (let чРазмерБуфера = м_Настройки.Получить('чРазмерБуфера'); --чИндекс > 0 && (чРазмерБуфера -= оНовыйСписок.моСегменты[чИндекс].чДлительность) > 0;) {}
		}
		else
		{
			Проверить(оНовыйСписок.моСегменты.length !== 0);

			чНачалоПоследнегоСписка = _оПоследнийСписок.nMediaSequenceNumber;
			чКонецПоследнегоСписка = чНачалоПоследнегоСписка + _оПоследнийСписок.моСегменты.length;
			чИндекс = 0;

			// Twitch, ТВЦ: Нам ошибочно прислали старый список.
			if (чНачалоНовогоСписка < чНачалоПоследнегоСписка
			// Twitch: Количество сегментов в списке ошибочно уменьшено с 15 до 14. #EXT-X-MEDIA-SEQUENCE не изменился.
			|| чКонецНовогоСписка < чКонецПоследнегоСписка)
			{
				м_Журнал.Ой(`[Список] Уменьшился media sequence number`
					+ ` [${чНачалоПоследнегоСписка}..${чКонецПоследнегоСписка}) ==> [${чНачалоНовогоСписка}..${чКонецНовогоСписка})`);
			}
			
			// Firefox 43: Из-за нехватки памяти в системе, загрузка списка может задержаться на несколько десятков секунд.
			const кСегментовПропущено = чНачалоНовогоСписка - чКонецПоследнегоСписка;
			if (кСегментовПропущено > 0)
			{
				м_Журнал.Ой(`[Список] Пропущено сегментов: ${кСегментовПропущено}`);
				м_Статистика.НеЗагруженыСегменты(кСегментовПропущено);
				ДобавитьСегментыВОчередь.лРазрыв = true;
			}

			if (оНовыйСписок.nTargetDuration !== _оПоследнийСписок.nTargetDuration)
			{
				м_Журнал.Ой(`[Список] Изменился target duration ${_оПоследнийСписок.nTargetDuration} ==> ${оНовыйСписок.nTargetDuration}`);
				СброситьИнтервалОбновленияСписков();
			}
		}

		let кСегментовДобавлено = 0;
		let кСекундДобавлено = 0; // Статистика.
		for (let оДобавляемыйСегмент; оДобавляемыйСегмент = оНовыйСписок.моСегменты[чИндекс]; ++чИндекс)
		{
			const чНомерДобавляемогоСегмента = чНачалоНовогоСписка + чИндекс;

			if (чНомерДобавляемогоСегмента >= чНачалоПоследнегоСписка && чНомерДобавляемогоСегмента < чКонецПоследнегоСписка)
			{
				const оСегмент = _оПоследнийСписок.моСегменты[чНомерДобавляемогоСегмента - чНачалоПоследнегоСписка];
				// Twitch: Раньше #EXT-X-MEDIA-SEQUENCE был ошибочно на 1 меньше после начала трансляции.
				if (оСегмент.сАдрес !== оДобавляемыйСегмент.сАдрес || оСегмент.чДлительность !== оДобавляемыйСегмент.чДлительность)
				{
					м_Журнал.Ой(`[Список] У сегмента ${чНомерДобавляемогоСегмента} изменились адрес ${оСегмент.сАдрес} ==> ${оДобавляемыйСегмент.сАдрес}`
						+ ` или длительность ${оСегмент.чДлительность} ==> ${оДобавляемыйСегмент.чДлительность}`);
					ДобавитьСегментыВОчередь.лРазрыв = true;
				}
			}

			if (чНомерДобавляемогоСегмента >= чКонецПоследнегоСписка)
			{
				if (_чСостояние !== СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
				{
					_чСостояние = СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ;
					г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ));
					СброситьИнтервалОбновленияСписков();
				}

				if (оДобавляемыйСегмент.чДлительность === 0)
				{
					м_Журнал.Ой(`[Список] Пропускаю сегмент MediaSequenceNumber=${чНомерДобавляемогоСегмента} Длительность=0`);
					м_Статистика.ПолученИсходныйСегмент();
					м_Статистика.ЗабракованСегмент();
					ДобавитьСегментыВОчередь.лРазрыв = true;
				}
				else
				{
					const оДобавлено = г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ, оДобавляемыйСегмент.сАдрес,
						оДобавляемыйСегмент.чДлительность, оДобавляемыйСегмент.лРазрыв || ДобавитьСегментыВОчередь.лРазрыв));
					м_Журнал.Вот(`[Список] Добавлен сегмент ${оДобавлено.чНомер} MediaSequenceNumber=${чНомерДобавляемогоСегмента}`
						+ ` Длительность=${оДобавлено.чДлительность} Разрыв=${оДобавлено.лРазрыв}`);
					кСегментовДобавлено += 1;
					кСекундДобавлено += оДобавлено.чДлительность;
					ДобавитьСегментыВОчередь.лРазрыв = false;
				}
			}
		}

		м_Статистика.ДобавленыСегментыВОчередь(кСегментовДобавлено, кСекундДобавлено);

		if (чКонецНовогоСписка >= чКонецПоследнегоСписка)
		{
			_оПоследнийСписок = оНовыйСписок;
		}

		if (оНовыйСписок.лКонецСписка)
		{
			throw 'Найден #EXT-X-ENDLIST';
		}

		return кСегментовДобавлено;
	}

	function ОбновитьСписки(чЧерез)
	{
		Проверить(Number.isFinite(чЧерез) && чЧерез >= 0);
		м_Журнал.Вот(`[Список] Загрузка списка начнется через ${м_Журнал.F0(чЧерез)}мс`);
		let оОбещание = Ждать(_ооОбновлениеСписков, чЧерез);
		if (!_моСписокВариантов)
		{
			let сАбсолютныйАдресСпискаВариантов;
			оОбещание = оОбещание.then(() =>
			{
				return м_Twitch.ПолучитьАбсолютныйАдресСпискаВариантов(_ооОбновлениеСписков);
			})
			.then(сРезультат =>
			{
				сАбсолютныйАдресСпискаВариантов = сРезультат;
				return м_Загрузчик.ЗагрузитьТекст(_ооОбновлениеСписков, сАбсолютныйАдресСпискаВариантов,
					ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ, 'список вариантов', false);
			})
			.then(сРезультат =>
			{
				м_Отладка.СохранитьСписокВариантов(сРезультат);
				_моСписокВариантов = РазобратьСписок(true, сАбсолютныйАдресСпискаВариантов, сРезультат);
				ВыбратьВариантТрансляции();
			});
		}
		let чНачалоОпроса;
		оОбещание.then(() =>
		{
			чНачалоОпроса = performance.now();
			return м_Загрузчик.ЗагрузитьТекст(_ооОбновлениеСписков,
				_моСписокВариантов[_чВыбранныйВариант].сАбсолютныйАдресСпискаСегментов,
				ЗАГРУЖАТЬ_СПИСОК_СЕГМЕНТОВ_НЕ_ДОЛЬШЕ, 'список сегментов', false);
		})
		.then(сРезультат =>
		{
			м_Отладка.СохранитьСписокСегментов(сРезультат);
			const чИнтервал = ПолучитьИнтервалОбновленияСпискаСегментов( ДобавитьСегментыВОчередь( РазобратьСписок(
				false, _моСписокВариантов[_чВыбранныйВариант].сАбсолютныйАдресСпискаСегментов, сРезультат)));
			ОбновитьСписки(Math.max(чИнтервал - performance.now() + чНачалоОпроса, 0));
			м_Загрузчик.ЗагрузитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Завершение трансляции?
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Список] Завершаю трансляцию. ${пПричина}`);
				ЗавершитьТрансляцию();
				ОбновитьСписки(ПолучитьИнтервалОбновленияСпискаВариантов());
				м_Загрузчик.ЗагрузитьСледующийСегмент();
			}
			// Выполнение этой цепочки обещаний было прервано вызовом _ооОбновлениеСписков.Отменить()?
			// В этот момент уже может работать другая цепочка обещаний.
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот('[Список] Отменено обновление списков');
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	function ОтменитьОбновлениеСписков()
	{
		м_Журнал.Вот('[Список] Отменяю обновление списков');
		_ооОбновлениеСписков.Отменить();
	}

	function СброситьИнтервалОбновленияСписков()
	{
		_мчДлительностьСегментов.fill(0);
		_чИнтервалОбновленияСписка = -1;
	}

	function ПолучитьИнтервалОбновленияСпискаСегментов(кСегментовДобавлено)
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ);

		const чМинИнтервал = МИН_ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКОВ * _оПоследнийСписок.nTargetDuration * 10;
		if (кСегментовДобавлено === 0)
		{
			return чМинИнтервал;
		}

		const чИнтервал = м_Настройки.Получить('чИнтервалОпроса');
		if (чИнтервал !== АВТОНАСТРОЙКА)
		{
			return чИнтервал * _оПоследнийСписок.nTargetDuration * 10;
		}

		Проверить(кСегментовДобавлено > 0 && кСегментовДобавлено <= _оПоследнийСписок.моСегменты.length);
		if (_чИнтервалОбновленияСписка === -1)
		{
			_чИнтервалОбновленияСписка = 0;
			// Ради этой строки _мчДлительностьСегментов[] заполняется без помощи ДобавитьСегментыВОчередь().
			кСегментовДобавлено = _оПоследнийСписок.моСегменты.length;
		}
		кСегментовДобавлено = Math.min(кСегментовДобавлено, _мчДлительностьСегментов.length);
		do
		{
			_мчДлительностьСегментов[_чИнтервалОбновленияСписка] = _оПоследнийСписок.моСегменты[_оПоследнийСписок.моСегменты.length - кСегментовДобавлено].чДлительность;
			if (++_чИнтервалОбновленияСписка === _мчДлительностьСегментов.length)
			{
				_чИнтервалОбновленияСписка = 0;
			}
		}
		while (--кСегментовДобавлено !== 0);
		return Math.max(Math.max(..._мчДлительностьСегментов) * 1000 + ДОБАВИТЬ_К_ИНТЕРВАЛУ_ОБНОВЛЕНИЯ_СПИСКА_СЕГМЕНТОВ, чМинИнтервал);
	}

	function ПолучитьИнтервалОбновленияСпискаВариантов()
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ);
		if (_чИнтервалОбновленияСписка === -1)
		{
			_чИнтервалОбновленияСписка = ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_НАЧАЛО;
		}
		else
		{
			_чИнтервалОбновленияСписка = Math.min(_чИнтервалОбновленияСписка + ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_ШАГ, ИНТЕРВАЛ_ОБНОВЛЕНИЯ_СПИСКА_ВАРИАНТОВ_КОНЕЦ);
		}
		return _чИнтервалОбновленияСписка;
	}

	function ВыбратьВариантТрансляции()
	// Изменяет _чВыбранныйВариант.
	{
		if (_моСписокВариантов.length === 0)
		{
			throw 'Список вариантов пуст';
		}
		// Если сЖелаемыйВариант не будет найден в списке, то возьмем вариант с максимальным качеством из начала списка.
		const сЖелаемыйВариант = м_Настройки.Получить('сНазваниеВарианта');
		_чВыбранныйВариант = _моСписокВариантов.length - 1;
		while (_чВыбранныйВариант !== 0 && _моСписокВариантов[_чВыбранныйВариант].сИдентификатор !== сЖелаемыйВариант)
		{
			--_чВыбранныйВариант
		}
		м_Журнал.Вот(`[Список] Выбран вариант трансляции ${_моСписокВариантов[_чВыбранныйВариант].сИдентификатор} ЖелаемыйВариант=${сЖелаемыйВариант}`);
		м_События.ПослатьСобытие('список-выбранварианттрансляции', [_моСписокВариантов, _чВыбранныйВариант]);
	}

	function ОчиститьСписокВариантовТрансляции()
	// Изменяет _моСписокВариантов.
	{
		if (_моСписокВариантов)
		{
			м_Журнал.Вот('[Список] Очищаю список вариантов трансляции');
			_моСписокВариантов = null;
			м_События.ПослатьСобытие('список-выбранварианттрансляции', [_моСписокВариантов, _чВыбранныйВариант]);
		}
	}

	function ЗавершитьТрансляцию()
	// Если нужно, добавляет в очередь СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ.
	{
		// Если СОСТОЯНИЕ_ОСТАНОВКА, то сменить СОСТОЯНИЕ_ЗАГРУЗКА на СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ.
		if (_чСостояние !== СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ)
		{
			_чСостояние = СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ;
			г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ));
			СброситьИнтервалОбновленияСписков();
		}
		ОчиститьСписокВариантовТрансляции();
		_оПоследнийСписок = null;
	}

	function ИзменитьВариантТрансляции()
	// Добавляет в очередь СОСТОЯНИЕ_СМЕНА_ВАРИАНТА. Не завершает трансляцию.
	// _чСостояние может быть любым, например если список вариантов уже загружен, а список сегментов - нет.
	{
		Проверить(_моСписокВариантов);
		ОтменитьОбновлениеСписков();
		СброситьИнтервалОбновленияСписков();
		ВыбратьВариантТрансляции();
		_оПоследнийСписок = null;
		_ооОбновлениеСписков.НачалоВыполнения();
		ОбновитьСписки(0);
		// Не очищать очередь "вручную" как в ПереключитьПросмотрТрансляции(). Нужно оставить в очереди элементы
		// со сменой состояния, включая те, что находятся в рабочем потоке. Также использование СОСТОЯНИЕ_СМЕНА_ВАРИАНТА
		// при необходимости позволит продолжать воспроизведение во время загрузки сегментов нового варианта.
		г_моОчередь.Добавить(new Сегмент(ОБРАБОТКА_ЗАГРУЖЕН, СОСТОЯНИЕ_СМЕНА_ВАРИАНТА));
		м_Загрузчик.ЗагрузитьСледующийСегмент();
	}


	function Остановить()
	// Не изменяет очередь.
	{
		_чСостояние = СОСТОЯНИЕ_ОСТАНОВКА;
		ОтменитьОбновлениеСписков();
		ОчиститьСписокВариантовТрансляции();
		_оПоследнийСписок = null;
	}

	function Запустить()
	{
		Проверить(_чСостояние === СОСТОЯНИЕ_ОСТАНОВКА);
		_ооОбновлениеСписков.НачалоВыполнения();
		ОбновитьСписки(0);
	}

	СброситьИнтервалОбновленияСписков();

	return {
		Запустить, Остановить,
		ИзменитьВариантТрансляции
	};
})();

const м_Преобразователь = (() =>
{
	let _оРабочийПоток = null;
	let _чПоследнийЗагруженный = -1;

	function ПреобразоватьСледующийСегмент()
	// СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ:
	//   Создает рабочий поток (включая компиляцию asmjs и wasm) пока сегменты закачиваются.
	//   Отсылается в рабочий поток, чтобы не изменилась позиция в очереди.
	// СОСТОЯНИЕ_ЗАВЕРШЕНИЕ_ТРАНСЛЯЦИИ:
	//   Отсылается в рабочий поток, чтобы не изменилась позиция в очереди.
	//   Освобождает память в рабочем потоке.
	//   TODO Убить рабочий поток когда в нем не останется ни одного сегмента.
	// СОСТОЯНИЕ_СМЕНА_ВАРИАНТА:
	//   Отсылается в рабочий поток, чтобы не изменилась позиция в очереди.
	{
		let кУдалить = 0, чУдалить;
		// Нельзя преобразовывать сегменты в произвольном порядке.
		for (let чСегмент = 0, оСегмент; оСегмент = г_моОчередь[чСегмент]; ++чСегмент)
		{
			if (оСегмент.чОбработка > ОБРАБОТКА_ЗАГРУЖЕН)
			{
				continue;
			}
			if (оСегмент.чОбработка < ОБРАБОТКА_ЗАГРУЖЕН)
			{
				break;
			}


			if (_чПоследнийЗагруженный !== -1 && _чПоследнийЗагруженный + 1 !== оСегмент.чНомер)
			{
				м_Журнал.Ой(`[Преобразование] Не загружены сегменты между ${_чПоследнийЗагруженный} и ${оСегмент.чНомер}`);
				оСегмент.лРазрыв = true;
			}
			_чПоследнийЗагруженный = оСегмент.чНомер;

			if (typeof оСегмент.пДанные === 'number' && _оРабочийПоток === null)
			{
				м_Журнал.Вот(`[Преобразование] Пропускаю сегмент ${оСегмент.чНомер} Состояние=${оСегмент.пДанные}`);
				оСегмент.чОбработка = ОБРАБОТКА_ПРЕОБРАЗОВАН;

				if (оСегмент.пДанные === СОСТОЯНИЕ_НАЧАЛО_ТРАНСЛЯЦИИ)
				{
					СоздатьРабочийПоток();
				}
			}
			else
			{
				if (typeof оСегмент.пДанные === 'number')
				{
					м_Журнал.Вот(`[Преобразование] Отсылаю сегмент ${оСегмент.чНомер} Состояние=${оСегмент.пДанные}`);
					_оРабочийПоток.postMessage(оСегмент);
				}
				else
				{
					м_Отладка.СохранитьТранспортныйПоток(оСегмент);
					м_Статистика.ПолученИсходныйСегмент();
					м_Журнал.Вот(`[Преобразование] Отсылаю сегмент ${оСегмент.чНомер}`);
					_оРабочийПоток.postMessage(оСегмент, [оСегмент.пДанные]);
				}

				if (++кУдалить === 1)
				{
					чУдалить = чСегмент;
				}
			}
		}
		
		if (кУдалить !== 0)
		{
			г_моОчередь.Удалить(чУдалить, кУдалить);
		}

		м_Проигрыватель.ДобавитьСледующийСегмент();
	}

	const ОбработатьОкончаниеПреобразования = ДобавитьОбработчикИсключений(оСобытие =>
	{
		const мДанные = оСобытие.data;
		Проверить(Array.isArray(мДанные));
		switch (мДанные[0])
		{
		case 1:
			Проверить(мДанные.length === 2 && ЭтоОбъект(мДанные[1]));
			const оСегмент = new Сегмент(ОБРАБОТКА_ПРЕОБРАЗОВАН, мДанные[1].пДанные, мДанные[1].чДлительность, мДанные[1].лРазрыв, мДанные[1].чНомер);
			м_Журнал.Вот(`[Преобразование] Получен сегмент ${оСегмент.чНомер} ПреобразованЗа=${м_Журнал.F0(оСегмент.пДанные.чПреобразованЗа)}мс`);
			if (typeof оСегмент.пДанные !== 'number')
			{
				м_Статистика.ПолученПреобразованныйСегмент(оСегмент);
				// Если исходный сегмент не был преобразован, то приходит только статистика без медиасегмента. Такое бывает очень редко.
				if (!оСегмент.пДанные.hasOwnProperty('мбМедиасегмент'))
				{
					return;
				}
				м_Отладка.СохранитьПреобразованныйСегмент(оСегмент);
			}
			г_моОчередь.Добавить(оСегмент);
			м_Проигрыватель.ДобавитьСледующийСегмент();
			return;

		case 2:
			const мсВажность = мДанные[1], мсЗаписи = мДанные[2];
			Проверить(мДанные.length === 3 && Array.isArray(мсВажность) && Array.isArray(мсЗаписи) && мсВажность.length === мсЗаписи.length);
			for (let ы = 0; ы < мсВажность.length; ++ы)
			{
				Проверить((мсВажность[ы] === 'Вот' || мсВажность[ы] === 'Окак' || мсВажность[ы] === 'Ой') && typeof мсЗаписи[ы] === 'string');
				м_Журнал[мсВажность[ы]](мсЗаписи[ы]);
			}
			return;

		case 3:
			Проверить(мДанные.length === 3 && typeof мДанные[1] === 'string' && typeof мДанные[2] === 'object');
			м_Отладка.ЗавершитьРаботуИОтправитьОтчет(мДанные[1], мДанные[2]);
			return;

		case 4:
			Проверить(мДанные.length === 2 && typeof мДанные[1] === 'string');
			м_Отладка.ЗавершитьРаботуИПоказатьСообщение(мДанные[1]);
			return;

		case 5:
			Проверить(мДанные.length === 2 && мДанные[1].byteLength);
			м_Помойка.Выбросить(мДанные[1]);
			return;

		default:
			Проверить(false);
		}
	});

	function ОбработатьОшибкуПреобразования(оСобытие)
	{
		м_Отладка.ЗавершитьРаботуИОтправитьОтчет(`Произошло событие ${оСобытие.type} в рабочем потоке в строке ${оСобытие.lineno}. ${оСобытие.message}`);
	}

	function СоздатьРабочийПоток()
	// Версии player.js и worker.js должны совпадать. Во время обновления расширения этим занимается браузер.
	{
		м_Журнал.Вот('[Преобразование] Создаю рабочий поток');
		_оРабочийПоток = new Worker('/worker.js');
		_оРабочийПоток.addEventListener('message', ОбработатьОкончаниеПреобразования);
		_оРабочийПоток.addEventListener('error', ОбработатьОшибкуПреобразования);
		_оРабочийПоток.addEventListener('messageerror', ОбработатьОшибкуПреобразования);
	}

	function Остановить()
	// Не изменяет очередь.
	{
		_чПоследнийЗагруженный = -1;
		if (_оРабочийПоток)
		{
			м_Журнал.Вот('[Преобразование] Убиваю рабочий поток');
			_оРабочийПоток.terminate();
			_оРабочийПоток = null;
		}
	}

	return {
		Остановить,
		ПреобразоватьСледующийСегмент
	};
})();

const м_Загрузчик = (() =>
{
	function ЗагрузитьТекст(ооОтменаОбещания, сАдрес, чНеДольше, сНазвание, лЖурнал, оЗаголовки = null, сМетод = 'GET')
	{
		return Загрузить(ооОтменаОбещания, сМетод, сАдрес, чНеДольше, оЗаголовки, сНазвание, лЖурнал, 'text');
	}

	function ЗагрузитьJson(ооОтменаОбещания, сАдрес, чНеДольше, сНазвание, лЖурнал, оЗаголовки = null, сМетод = 'GET')
	{
		return Загрузить(ооОтменаОбещания, сМетод, сАдрес, чНеДольше, оЗаголовки, сНазвание, лЖурнал, 'json');
	}

	function Загрузить(ооОтменаОбещания, сМетод, сАдрес, чНеДольше, оЗаголовки, сНазвание, лЖурнал, пТипДанных)
	// пТипДанных:
	//   'text' - текст. Возвращает строку, возможно пустую.
	//   'json' - JSON. Возвращает результат JSON.parse(). Отсутствие тела ответа считается ошибкой.
	//   число  - длительность загружаемого сегмента в секундах. Возвращает ArrayBuffer.
	// Если лЖурнал == true:
	//   Для текста - добавлять загруженный текст в м_Журнал.
	//   Для двоичных данных - рассчитывать _чОжиданиеОтвета.
	// TODO Firefox 46, Chrome 48, Edge 15 (выход из спячки): Иногда запрос не завершается, не посылая никаких событий.
	// TODO Firefox 56: Некэшируемые файлы попадают в кэш, находящийся в памяти, и вытесняют из него полезные данные.
	// https://bugzilla.mozilla.org/show_bug.cgi?id=1390844
	{
		Проверить(сМетод === 'GET' || сМетод === 'PUT' || сМетод === 'DELETE');
		Проверить(typeof сАдрес === 'string' && (сАдрес.startsWith('http://') || сАдрес.startsWith('https://') || (чНеДольше === 0 && сАдрес.startsWith(chrome.extension.getURL('')))));
		Проверить(Number.isFinite(чНеДольше) && (чНеДольше === 0 || чНеДольше > 1000));
		Проверить(typeof оЗаголовки === 'object' && typeof сНазвание === 'string' && typeof лЖурнал === 'boolean');
		Проверить(пТипДанных === 'text' || пТипДанных === 'json' || Number.isFinite(пТипДанных));

		м_Журнал.Вот(`[Загрузчик] ${сМетод} ${сНазвание} не дольше ${м_Журнал.F0(чНеДольше)}мс`);

		const оЗапрос = new XMLHttpRequest();
		оЗапрос._сМетод = сМетод;
		оЗапрос._сАдрес = сАдрес;
		оЗапрос._чНеДольше = чНеДольше;
		оЗапрос._оЗаголовки = оЗаголовки;
		оЗапрос._сНазвание = сНазвание;
		оЗапрос._лЖурнал = лЖурнал;
		оЗапрос._пТипДанных = пТипДанных;
		// Если вечером изменять параметры подписки, то 503 возвращается довольно часто. Согласно документации
		// Twitch, при получении кода 503 нужно повторить запрос 1 раз. Повтор не помешает и в других случаях.
		оЗапрос._кОсталосьПопыток = typeof пТипДанных === 'number' ? 1 : 2;
		оЗапрос._чВремяОтправкиЗапроса = performance.now();
		оЗапрос._чОжиданиеОтвета = NaN;
		
		оЗапрос.addEventListener('timeout', ОбработатьОшибку);
		оЗапрос.addEventListener('error', ОбработатьОшибку);
		оЗапрос.addEventListener('abort', ОбработатьОшибку);
		оЗапрос.addEventListener('load', ОбработатьОкончаниеЗагрузки);
		if (лЖурнал && typeof пТипДанных === 'number')
		{
			оЗапрос.addEventListener('readystatechange', ОбработатьПолучениеОтвета);
		}

		return new Promise((фВыполнить, фОтказаться) =>
		{
			оЗапрос._фВыполнить = фВыполнить;
			оЗапрос._фОтказаться = фОтказаться;
			if (ооОтменаОбещания)
			{
				ооОтменаОбещания.ЗаменитьОбработчик(ПолучитьОбработчикОтменыОбещания(оЗапрос));
			}
			ПослатьЗапрос(оЗапрос, false);
		});
	}

	function ПослатьЗапрос(оЗапрос, лПовторно)
	{
		if (оЗапрос._кОсталосьПопыток === 0)
		{
			return false;
		}
		if (лПовторно)
		{
			м_Журнал.Ой(`[Загрузчик] Повторно загружаю ${оЗапрос._сНазвание}`);
		}
		оЗапрос._кОсталосьПопыток -= 1;
		оЗапрос.open(оЗапрос._сМетод, оЗапрос._сАдрес);
		// text вместо json, потому что хочется в журнале видеть, что за фигню прислал сервер.
		оЗапрос.responseType = typeof оЗапрос._пТипДанных === 'number' ? 'arraybuffer' : 'text';
		оЗапрос.timeout = оЗапрос._чНеДольше;
		if (оЗапрос._оЗаголовки)
		{
			for (let сЗаголовок of Object.keys(оЗапрос._оЗаголовки))
			{
				оЗапрос.setRequestHeader(сЗаголовок, оЗапрос._оЗаголовки[сЗаголовок]);
			}
		}
		оЗапрос.send();
		return true;
	}

	function ПолучитьОбработчикОтменыОбещания(оЗапрос)
	{
		return () =>
		{
			м_Журнал.Вот(`[Загрузчик] Отменяю загрузку ${оЗапрос._сНазвание} readyState=${оЗапрос.readyState}`);
			оЗапрос.removeEventListener('abort', ОбработатьОшибку);
			// Меняет readyState на DONE.
			// Синхронно вызывает обработчики событий readystatechange и abort.
			// Меняет readyState на UNSENT.
			оЗапрос.abort();
			оЗапрос._фОтказаться(ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО);
		};
	}


	const ОбработатьПолучениеОтвета = ДобавитьОбработчикИсключений(({target: оЗапрос}) =>
	// Событие progress посылается примерно каждые 50 мс, readystatechange посылается намного чаще.
	// Firefox 51-: Первое событие progress посылается примерно через 50 мс после получения заголовков.
	// Edge 15: Последнее событие progress может быть послано по окончании загрузки ПРЕДпоследнего блока.
	{
		if (оЗапрос.readyState >= XMLHttpRequest.HEADERS_RECEIVED)
		{
			оЗапрос.removeEventListener('readystatechange', ОбработатьПолучениеОтвета);
			Проверить(Number.isNaN(оЗапрос._чОжиданиеОтвета));
			оЗапрос._чОжиданиеОтвета = Math.round(performance.now() - оЗапрос._чВремяОтправкиЗапроса);
		}
	});

	const ОбработатьОшибку = ДобавитьОбработчикИсключений(({target: оЗапрос, type: сТипСобытия}) =>
	{

		м_Журнал.Ой(`[Загрузчик] Не удалось загрузить ${оЗапрос._сНазвание}. Произошло событие ${сТипСобытия}`
			+ ` readyState=${оЗапрос.readyState}`
			+ (оЗапрос._лЖурнал && typeof оЗапрос._пТипДанных === 'number' ? ` ОжиданиеОтвета=${оЗапрос._чОжиданиеОтвета}мс` : ``)
		);

		// Во всех браузерах window.stop() вызвает abort().
		// Chrome 49 вызывает abort() во время выгрузки страницы, засыпания компа и еще непонятно когда.
		// Firefox раньше сам вызывал abort(). Возможно, продолжит это в будущем, беря пример с Chrome.
		if (сТипСобытия === 'abort' || !ПослатьЗапрос(оЗапрос, true))
		{
			if (оЗапрос.responseType === 'arraybuffer')
			{
				м_Статистика.ЗагруженСегмент(NaN, NaN, NaN, оЗапрос._чОжиданиеОтвета);
			}
			оЗапрос._фОтказаться(`Произошло событие ${сТипСобытия}`);
		}
	});

	const ОбработатьОкончаниеЗагрузки = ДобавитьОбработчикИсключений(({target: оЗапрос}) =>
	{
		Проверить(оЗапрос.readyState === XMLHttpRequest.DONE);


		const чКод = оЗапрос.status;
		// Возможно сочетание: responseType == arraybuffer, код == 200..299, response == null. report://03794749782803_15084697088
		if (чКод >= 200 && чКод <= 299 && оЗапрос.response !== null)
		{
			const чДлительностьЗагрузки = Math.round(performance.now() - оЗапрос._чВремяОтправкиЗапроса);

			м_Журнал[чКод === 200 ? 'Вот' : 'Ой'](
				`[Загрузчик] Загрузил ${оЗапрос._сНазвание} за ${чДлительностьЗагрузки}мс`
				+ (оЗапрос._лЖурнал && typeof оЗапрос._пТипДанных === 'number' ? ` ОжиданиеОтвета=${оЗапрос._чОжиданиеОтвета}мс` : ``)
				+ (typeof оЗапрос._пТипДанных === 'number' ? ` Отношение=${м_Журнал.F1(чДлительностьЗагрузки / оЗапрос._пТипДанных / 1000)}` : ``)
				+ (чКод === 200 ? `` : ` Код=${чКод} ${оЗапрос.statusText}`)
				+ (
					оЗапрос._лЖурнал && ЭтоНепустаяСтрока(оЗапрос.response) ? `\n${оЗапрос.response}`
					: оЗапрос.responseType === 'arraybuffer' ? ` Размер=${оЗапрос.response.byteLength}байт`
					: ` Размер=${оЗапрос.response.length}символов`
				)
			);

			// Файл загружен не с диска?
			if (оЗапрос._чНеДольше !== 0)
			{
				м_Статистика.СкачаноНечто(ПолучитьРазмерОтвета(оЗапрос));
			}

			if (оЗапрос.responseType === 'arraybuffer')
			{
				м_Статистика.ЗагруженСегмент(оЗапрос.response.byteLength, оЗапрос._пТипДанных, чДлительностьЗагрузки, оЗапрос._чОжиданиеОтвета);
				оЗапрос._фВыполнить(оЗапрос.response);
			}
			else if (оЗапрос._пТипДанных === 'json')
			{
				try
				{
					оЗапрос._фВыполнить(JSON.parse(оЗапрос.response));
				}
				catch (пИсключение)
				{
					// Не повторять ПослатьЗапрос().
					м_Журнал.Ой(`[Загрузчик] Не удалось разобрать ${оЗапрос._сНазвание}. ${пИсключение}`);
					оЗапрос._фОтказаться('Не удалось разобрать JSON');
				}
			}
			else
			{
				оЗапрос._фВыполнить(оЗапрос.response);
			}
		}
		else
		{
			м_Журнал.Ой(`[Загрузчик] Не удалось загрузить ${оЗапрос._сНазвание}. ${КОД_ОТВЕТА + чКод} ${оЗапрос.statusText}`
				+ (оЗапрос._лЖурнал && typeof оЗапрос._пТипДанных === 'number' ? ` ОжиданиеОтвета=${оЗапрос._чОжиданиеОтвета}мс` : ``)
				+ (
					ЭтоНепустаяСтрока(оЗапрос.response) ? `\n${оЗапрос.response}`
					: оЗапрос.response === null ? ' Response=null'
					: оЗапрос.responseType === 'arraybuffer' ? ` Размер=${оЗапрос.response.byteLength}байт`
					: ` Размер=${оЗапрос.response.length}символов`
				)
			);

			// Встречается код 302, видимо без заголовка запроса location. report://02880986452199_15106536708
			if ((чКод >= 400 && чКод <= 499) || оЗапрос.response === null || !ПослатьЗапрос(оЗапрос, true))
			{
				if (оЗапрос.responseType === 'arraybuffer')
				{
					м_Статистика.ЗагруженСегмент(NaN, NaN, NaN, оЗапрос._чОжиданиеОтвета);
				}
				оЗапрос._фОтказаться(КОД_ОТВЕТА + чКод);
			}
		}
	});

	function ПолучитьРазмерОтвета(оЗапрос)
	// TODO Twitch: Часть запросов к API может кэшироваться.
	{
		let кбРазмерЗаголовков = 17 + оЗапрос.statusText.length + оЗапрос.getAllResponseHeaders().length;
		// HTTP/2 сжимает заголовки. Итоговый размер равен ≈ 0,2..0,7 и зависит от
		// содержимого заголовков и количества запросов в соединении.
		if (ЭтоHTTP2(оЗапрос))
		{
			кбРазмерЗаголовков = Math.round(кбРазмерЗаголовков * 0.5);
		}
		
		let кбРазмерТела;
		// Нам нужен размер сжатых данных. Событие progress дает размер разжатых данных.
		// Content-Length отсутствует если используется Transfer-Encoding: chunked.
		// Content-Length не обязателен для протокола HTTP/2.
		let сЗаголовок = оЗапрос.getResponseHeader('Content-Length');
		if (сЗаголовок)
		{
			кбРазмерТела = Number.parseInt(сЗаголовок, 10);
		}
		else if (оЗапрос.responseType === 'arraybuffer')
		{
			кбРазмерТела = оЗапрос.response.byteLength;
			// TODO Расширение пока не скачивает сжатые двоичные файлы.
		}
		else
		{
			// TODO Размер в байтах исходного текста в кодировке UTF-8 может быть больше.
			// Twitch: Таких файлов очень мало.
			кбРазмерТела = оЗапрос.response.length;
			сЗаголовок = оЗапрос.getResponseHeader('Content-Encoding');
			if (сЗаголовок && сЗаголовок !== 'identity')
			{
				кбРазмерТела = Math.round(кбРазмерТела * 0.35);
			}
		}
		
		return кбРазмерЗаголовков + кбРазмерТела;
	}

	function ЭтоHTTP2(оЗапрос)
	// HACK Нет стандартного способа для определения версии протокола HTTP.
	{
		// Firefox 56: Заголовок Status может отсутствовать.
		// Firefox 56: statusText эмулируется.
		return оЗапрос.getResponseHeader('X-Firefox-Spdy') === 'h2';
	}

	function ЗагрузитьСледующийСегмент()
	// Начинает загрузку незагруженных сегментов и отправляет на преобразование загруженные.
	// Сегменты могут загружаться в произвольном порядке, преобразовываться - только по порядку.
	{
		// Для упрощения алгоритма, СОСТОЯНИЕ_СМЕНА_ВАРИАНТА должен быть последним в очереди.
		let ч = г_моОчередь.length - 1;
		if (ч >= 0 && г_моОчередь[ч].пДанные === СОСТОЯНИЕ_СМЕНА_ВАРИАНТА && г_моОчередь[ч].чОбработка === ОБРАБОТКА_ЗАГРУЖЕН)
		{
			г_моОчередь.ПоказатьСостояние();
			while (--ч >= 0 && г_моОчередь[ч].чОбработка <= ОБРАБОТКА_ЗАГРУЖЕН)
			{
				if (typeof г_моОчередь[ч].пДанные !== 'number')
				{
					г_моОчередь.Удалить(ч);
				}
			}
			г_моОчередь.ПоказатьСостояние();
		}
		else
		{
			let кОдновременныхЗагрузок = м_Настройки.Получить('кОдновременныхЗагрузок');
			let чДлительностьВсехЗагрузок = 0;
			for (let оСегмент of г_моОчередь)
			{
				// Загруженные сегменты могут застрять в очереди если из-за ошибки браузера завис XHR
				// и в настройках проигрывателя включена одновременная загрузка нескольких сегментов.
				if (оСегмент.чОбработка <= ОБРАБОТКА_ЗАГРУЖЕН)
				{
					чДлительностьВсехЗагрузок += оСегмент.чДлительность;
					if (оСегмент.чОбработка <= ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
					{
						--кОдновременныхЗагрузок;
						if (оСегмент.чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ && кОдновременныхЗагрузок >= 0)
						{
							ЗагрузитьСегмент(оСегмент);
						}
					}
				}
			}

			// Значение должно быть больше, чем ЗагружатьСегментНеДольше(), чтобы не путать ошибку загрузки с переполнением очереди.
			// TODO В качестве ограничения можно добавить проверку availability duration из стандарта HLS.
			const чПереполнениеОчереди = м_Настройки.Получить('чМаксРазмерБуфера') + м_Настройки.Получить('чРастягиваниеБуфера');
			if (чДлительностьВсехЗагрузок > чПереполнениеОчереди)
			{
				м_Журнал.Ой(`[Загрузчик] Длительность всех загрузок в очереди ${м_Журнал.F1(чДлительностьВсехЗагрузок)}с > ${м_Журнал.F1(чПереполнениеОчереди)}с`);
				ОбработатьНеудачнуюЗагрузкуСегмента(null);
				ЗагрузитьСледующийСегмент();
				return;
			}
		}

		м_Преобразователь.ПреобразоватьСледующийСегмент();
	}

	function ЗагрузитьСегмент(оСегмент)
	{
		const сАдрес = оСегмент.пДанные;
		оСегмент.пДанные = new ОтменаОбещания();
		оСегмент.пДанные.НачалоВыполнения();
		оСегмент.чОбработка = ОБРАБОТКА_ЗАГРУЖАЕТСЯ;
		Загрузить(оСегмент.пДанные, 'GET', сАдрес, ЗагружатьСегментНеДольше(оСегмент), null,
			`сегмент ${оСегмент.чНомер}`, м_Статистика.ОкноПоказано(), оСегмент.чДлительность)
		.then(буфДанные =>
		{
			Проверить(г_моОчередь.includes(оСегмент));
			оСегмент.пДанные = буфДанные;
			оСегмент.чОбработка = ОБРАБОТКА_ЗАГРУЖЕН;
			ЗагрузитьСледующийСегмент();
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Firefox: Во время отправки загруженного сегмента на преобразование может кинуть строковое исключение 'out of memory'.
			if (typeof пПричина === 'string' && оСегмент.чОбработка === ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
			{
				Проверить(г_моОчередь.includes(оСегмент));
				// Загрузить() уже добавила подробное сообщение об ошибке.
				// На всякий случай вызываем XMLHttpRequest.abort(). Для этого не обнуляем оСегмент.пДанные.
				ОбработатьНеудачнуюЗагрузкуСегмента(пПричина.сПричина === (КОД_ОТВЕТА + 404) || пПричина.сПричина === (КОД_ОТВЕТА + 410) ? null : оСегмент);
				Проверить(!г_моОчередь.includes(оСегмент));
				ЗагрузитьСледующийСегмент();
			}
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот(`[Загрузчик] Отменена загрузка сегмента ${оСегмент.чНомер}`);
				Проверить(!г_моОчередь.includes(оСегмент));
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	function ЗагружатьСегментНеДольше(оСегмент)
	{
		// Формула отношения времени загрузки ко времени воспроизведения:
		// В = БТ / мин(БЗ, ПСК / КС)
		// БТ  - Средний битрейт трансляции.
		// БЗ  - Битрейт загрузки одного сегмента. БЗ меньше БТ если канал от провайдера до сервера перегружен.
		// ПСК - Пропускная способность канала от зрителя к провайдеру.
		// КС  - Количество одновременно загружаемых сегментов.
		//
		// Воспроизведение идет без остановок если В <= КС. Пример:
		// БТ  =  8 Мбит/с
		// БЗ  =  6 Мбит/с
		// ПСК = 10 Мбит/с
		// КС  = 1  В = 1.3  Скорости загрузки недостаточно.
		// КС  = 2  В = 1.6  Скорости загрузки достаточно.
		// КС  = 3  В = 2.4  Скорости загрузки достаточно.

		// Увеличение в 2 и 3 раза возможно в следующих граничных ситуациях:
		// а) БЗ = БТ / КС. В этой ситуации одновременная загрузка максимально эффективна.
		// б) ПСК = БТ. В этой ситуации одновременная загрузка бесполезна.
		// На практике время может быть больше:
		// а) Загружаемые сегменты делят ПСК неравномерно.
		// б) Битрейт трансляции может плавать.
		// в) ПСК чуть меньше БТ. Некоторые зрители предпочитают смотреть с остановками вместо понижения качества.
		const чПеременная = оСегмент.чДлительность * м_Настройки.Получить('кОдновременныхЗагрузок') * 1.15;

		// Не уменьшать значение слишком сильно, чтобы кратковременное снижение скорости загрузки, например вследствии открытия
		// чата или страницы в другой вкладке, не отменяло загрузку сегмента. Не увеличивать слишком сильно, чтобы проблема с
		// одним сегментом не привела к долгой остановке воспроизведения и переполнения очереди в ЗагрузитьСледующийСегмент().
		// Включает в себя ожидание ответа, которое может составлять пару секунд из-за перегруженности сервера.
		const чПостоянная = 8;

		return (чПеременная + чПостоянная) * 1000;
	}

	function ОбработатьНеудачнуюЗагрузкуСегмента(оНезагруженныйСегмент)
	// оНезагруженныйСегмент - сегмент, во время загрузки которого произошла ошибка.
	// оНезагруженныйСегмент == null - произошло переполнение очереди.
	{
		г_моОчередь.ПоказатьСостояние();
		const кВОчереди = г_моОчередь.length;
		if (оНезагруженныйСегмент)
		{
			г_моОчередь.Удалить(оНезагруженныйСегмент);
		}
		else
		{
			let чРазмерБуфера = м_Настройки.Получить('чРазмерБуфера');
			for (let ы = кВОчереди, оСегмент; оСегмент = г_моОчередь[--ы];)
			{
				if (оСегмент.чОбработка === ОБРАБОТКА_ЖДЕТ_ЗАГРУЗКИ)
				{
					if (чРазмерБуфера > 0)
					{
						чРазмерБуфера -= оСегмент.чДлительность;
					}
					else
					{
						г_моОчередь.Удалить(ы);
					}
				}
				else if (оСегмент.чОбработка === ОБРАБОТКА_ЗАГРУЖАЕТСЯ)
				{
					г_моОчередь.Удалить(ы);
				}
			}
		}
		г_моОчередь.ПоказатьСостояние();
		м_Статистика.НеЗагруженыСегменты(кВОчереди - г_моОчередь.length);
	}


	return {
		ЗагрузитьТекст,
		ЗагрузитьJson,
		ЗагрузитьСледующийСегмент
	};
})();

let м_Twitch = null;

function Twitch(_сКодКанала)
{
	const ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ = 60000; // Миллисекунды.
	const ЗАДЕРЖКА_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ЗАПИСИ = 4 * 60000; // Миллисекунды.
	const ИДЕНТИФИКАТОР_КЛИЕНТА = 'jzkbprff40iqj646a697cyrvl0zt2m6';

	const ЗАГОЛОВКИ_ЗАПРОСА =
	{
		'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА,
		'Accept': 'application/vnd.twitchtv.v5+json'
	};

	let _сИдКанала     = '';
	let _сИдТрансляции = '';
	let _сАдресЗаписи  = '';
	let _сИдЗрителя    = '';
	let _сТокенЗрителя = '';
	let _ооОбновлениеМетаданных = new ОтменаОбещания();

	function ОчиститьДанныеТрансляции()
	{
		_сИдТрансляции = _сАдресЗаписи = '';
	}

	function ПолучитьАдресКанала(лНеПеренаправлять)
	{
		// Twitch переводит код канала и параметры в нижний регистр.
		return лНеПеренаправлять
			? `https://www.twitch.tv/${_сКодКанала}?${АДРЕС_НЕ_ПЕРЕНАПРАВЛЯТЬ}`
			: `https://www.twitch.tv/${_сКодКанала}`;
	}

	function ПолучитьАдресПанелиЧата()
	{
		if (м_Настройки.Получить('лПолноценныйЧат'))
		{
			return ЭТО_ПЛАНШЕТ
				? `https://www.twitch.tv/popout/${_сКодКанала}/chat?no-mobile-redirect=true`
				: `https://www.twitch.tv/popout/${_сКодКанала}/chat`
		}
		return м_Настройки.Получить('лЗатемнитьЧат')
			? `https://www.twitch.tv/embed/${_сКодКанала}/chat?darkpopout`
			: `https://www.twitch.tv/embed/${_сКодКанала}/chat`;
	}


	function ПолучитьАдресКаталогаИгры(сНазваниеИгры)
	{
		return 'https://www.twitch.tv/directory' + (сНазваниеИгры ? '/game/' + encodeURIComponent(сНазваниеИгры) : '');
	}

	function ИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		Проверить(Number.isInteger(чПодписка));
		ПолучитьИлиИзменитьПодпискуЗрителяНаКанал(чПодписка);
	}

	function ПолучитьИлиИзменитьПодпискуЗрителяНаКанал(чПодписка)
	{
		Проверить(_сИдЗрителя && _сИдКанала && _сТокенЗрителя);
		if (_сИдЗрителя === _сИдКанала)
		{
			Проверить(чПодписка === undefined);
			м_События.ПослатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕДОСТУПНА});
			return;
		}
		let сМетод, сПараметры;
		switch (чПодписка)
		{
			case undefined:             сМетод = 'GET';    сПараметры = ''; break;
			case ПОДПИСКА_НЕОФОРМЛЕНА:  сМетод = 'DELETE'; сПараметры = ''; break;
			case ПОДПИСКА_НЕУВЕДОМЛЯТЬ: сМетод = 'PUT';    сПараметры = '?notifications=false'; break;
			case ПОДПИСКА_УВЕДОМЛЯТЬ:   сМетод = 'PUT';    сПараметры = '?notifications=true';  break;
			default: Проверить(false);
		}
		// ЗагрузитьJson() считает ошибкой отсутствие тела ответа.
		м_Загрузчик.ЗагрузитьТекст(null,
			`https://api.twitch.tv/kraken/users/${_сИдЗрителя}/follows/channels/${_сИдКанала}${сПараметры}`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, `подписка ${чПодписка}`, true,
			чПодписка === undefined ? ЗАГОЛОВКИ_ЗАПРОСА :
			{
				'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА,
				'Accept': 'application/vnd.twitchtv.v5+json',
				'Authorization': `OAuth ${_сТокенЗрителя}`
			},
			сМетод
		)
		.then(сРезультат =>
		{
			// После DELETE код ответа 204.
			if (чПодписка === ПОДПИСКА_НЕОФОРМЛЕНА)
			{
				Проверить(сРезультат === '');
				м_События.ПослатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕОФОРМЛЕНА});
				return;
			}
			let оРезультат;
			try
			{
				оРезультат = JSON.parse(сРезультат);
			}
			catch (пИсключение)
			{
				throw String(пИсключение);
			}
			Проверить(ЭтоНепустаяСтрока(оРезультат.created_at));
			Проверить(typeof оРезультат.notifications === 'boolean');
			// После смены уведомления, оРезультат.notifications иногда содержит предыдущее значение.
			// Это ошибка Twitch или сделано специально?
			м_События.ПослатьСобытие('twitch-полученыметаданныезрителя',
			{
				чПодписка: чПодписка !== undefined ? чПодписка : оРезультат.notifications ? ПОДПИСКА_УВЕДОМЛЯТЬ : ПОДПИСКА_НЕУВЕДОМЛЯТЬ
			});
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// После GET код ответа 404 если зритель не подписан на канал.
			if (пПричина === (КОД_ОТВЕТА + 404))
			{
				Проверить(чПодписка === undefined);
				м_События.ПослатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕОФОРМЛЕНА});
			}
			// TODO Обновить метаданные, если ошибка произошла из-за протухшего токена.
			else if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось обновить подписку. ${пПричина}`);
				м_События.ПослатьСобытие('twitch-полученыметаданныезрителя', {чПодписка: ПОДПИСКА_НЕДОСТУПНА});
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				throw пПричина;
			}
		}));
	}

	const ПолученИдКанала = ДобавитьОбработчикИсключений(() =>
	{
		ПолучитьМетаданныеКанала();
		ПолучитьМетаданныеЗрителя();
	});

	function ПолучитьАбсолютныйАдресСпискаВариантов(ооОтменаОбещания, bHttp = false)
	// Загрузка по http меньше нагружает центральный процессор, но имеет недостатки:
	// - Этот протокол проще блокировать (report://03705462433077_15281664376).
	// - Могут мешать другие расширения браузера (report://07273043908108_15276834036).
	{
		// TODO ЗагрузитьJson() не подходит, потому что нужно послать отчет об ошибке если не удастся разобрать ответ?
		// TODO Хорошо бы передавать в запросе _сИдКанала вместо _сКодКанала.
		return м_Загрузчик.ЗагрузитьТекст(ооОтменаОбещания,
			`https://api.twitch.tv/api/channels/${_сКодКанала}/access_token?need_https=${!bHttp}`,
			ЗАГРУЖАТЬ_СПИСОК_ВАРИАНТОВ_НЕ_ДОЛЬШЕ, 'токен трансляции', true, {'Client-ID': ИДЕНТИФИКАТОР_КЛИЕНТА}
		)
		.then(
			сРезультат =>
			{
				const оРезультат = JSON.parse(сРезультат);
				Проверить(ЭтоНепустаяСтрока(оРезультат.token) && ЭтоНепустаяСтрока(оРезультат.sig));
				const оТокен = JSON.parse(оРезультат.token);
				Проверить(оТокен.channel === _сКодКанала);
				if (_сИдКанала === '')
				{
					Проверить(Number.isInteger(оТокен.channel_id));
					// В access token это число. В helix и части kraken это строка. Второй вариант более логичный.
					_сИдКанала = String(оТокен.channel_id);
					// Сначала загружаем видео, которое важнее метаданных.
					setImmediate(ПолученИдКанала);
				}
				else
				{
					// TODO Теоретически проверка может не сработать, если во время трансляции канал поменяет код,
					// другой канал возьмет себе старый код, и метаданные трансляции не успеют получить новый код?
					Проверить(_сИдКанала === String(оТокен.channel_id));
				}
				// Этот адрес есть в <head> файла player.html.
				return `${bHttp ? 'http' : 'https'}://usher.ttvnw.net/api/channel/hls/${_сКодКанала}.m3u8?allow_source=true&allow_audio_only=true&sig=${encodeURIComponent(оРезультат.sig)}&token=${encodeURIComponent(оРезультат.token)}`;
			},
			пПричина =>
			{
				// Недопустимый символ в коде канала || канала не существует || запрещенное название канала?
				if (пПричина === (КОД_ОТВЕТА + 400) || пПричина === (КОД_ОТВЕТА + 404) || пПричина === (КОД_ОТВЕТА + 422))
				{
					м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0203');
				}
				else
				{
					throw пПричина;
				}
			}
		);
	}

	function ПолучитьМетаданныеКанала()
	{
		Проверить(_сИдКанала);
		м_Загрузчик.ЗагрузитьJson(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(оРезультат =>
		{
			const чКаналСоздан = Date.parse(оРезультат.created_at); // ISO 8601
			Проверить(
				оРезультат._id === _сИдКанала
				&& Number.isFinite(оРезультат.followers)
				&& Number.isFinite(оРезультат.views)
				&& Number.isFinite(чКаналСоздан)
			);
			м_События.ПослатьСобытие('twitch-полученыметаданныеканала',
			{
				сИмя: оРезультат.display_name || оРезультат.name,
				сАватар: оРезультат.logo || 'glitch.svg#avatar',
				сОписание: оРезультат.description,
				сКодЯзыка: оРезультат.broadcaster_language === 'other' ? null : оРезультат.broadcaster_language,
				кПодписчиков: оРезультат.followers,
				кПросмотров: оРезультат.views,
				чКаналСоздан
			});
		})
		.catch(пПричина =>
		{
			// ПолучитьАбсолютныйАдресСпискаВариантов() стал возвращать 200 вместо 422, поэтому делаем проверку здесь.
			if (пПричина === (КОД_ОТВЕТА + 422))
			{
				м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0203');
			}
			else if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить метаданные канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});

		м_Загрузчик.ЗагрузитьJson(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}/communities`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'сообщества канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(оРезультат =>
		{
			Проверить(Array.isArray(оРезультат.communities));
			for (let оСообщество of оРезультат.communities)
			{
				Проверить(ЭтоНепустаяСтрока(оСообщество.name));
				оСообщество.сИмя = оСообщество.display_name || оСообщество.name;
				оСообщество.сОписание = оСообщество.description;
				оСообщество.сАдрес = `https://www.twitch.tv/communities/${encodeURIComponent(оСообщество.name)}`;
			}
			м_События.ПослатьСобытие('twitch-полученыметаданныеканала', {моСообщества: оРезультат.communities});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить сообщества канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});

		м_Загрузчик.ЗагрузитьJson(null,
			`https://api.twitch.tv/kraken/channels/${_сИдКанала}/teams`,
			ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'команды канала', true, ЗАГОЛОВКИ_ЗАПРОСА
		)
		.then(оРезультат =>
		{
			Проверить(Array.isArray(оРезультат.teams));
			for (let оКоманда of оРезультат.teams)
			{
				Проверить(ЭтоНепустаяСтрока(оКоманда.name));
				оКоманда.сИмя = оКоманда.display_name || оКоманда.name;
				if (оКоманда.info)
				{
					оКоманда.сОписание = ПреобразоватьРазметкуВТекст(оКоманда.info);
				}
				оКоманда.сАдрес = `https://www.twitch.tv/team/${encodeURIComponent(оКоманда.name)}`;
			}
			м_События.ПослатьСобытие('twitch-полученыметаданныеканала', {моКоманды: оРезультат.teams});
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось получить команды канала. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});
	}

	function ПолучитьМетаданныеЗрителя()
	{
		// HACK Edge 17: На странице расширения browser.cookies.get() валит вкладку.
		// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18467704/
		ПолучитьApiРасширения(oApi =>
		{
			oApi.cookies.get(
				{
					url: 'https://www.twitch.tv/',
					name: 'twilight-user'
				},
				ДобавитьОбработчикИсключений(оПеченька =>
				{
					let пДляЖурнала = оПеченька;
					if (ЭтоОбъект(оПеченька))
					{
						пДляЖурнала = JSON.stringify(оПеченька).replace(/%22authToken%22:%22[^%]+%22/, '---8<---');
						if (ЭтоНепустаяСтрока(оПеченька.value))
						{
							const оАвторизация = JSON.parse(decodeURIComponent(оПеченька.value));
							if (ЭтоНепустаяСтрока(оАвторизация.id)
							&&  ЭтоНепустаяСтрока(оАвторизация.login)
							&&  ЭтоНепустаяСтрока(оАвторизация.authToken))
							{
								м_Журнал.Вот(`[Twitch] Печенька авторизации:\n${пДляЖурнала}`);
								_сИдЗрителя = оАвторизация.id;
								_сТокенЗрителя = оАвторизация.authToken;
								м_События.ПослатьСобытие('twitch-полученыметаданныезрителя',
								{
									сИмя: ЭтоНепустаяСтрока(оАвторизация.displayName) ? оАвторизация.displayName : оАвторизация.login
								});
								ПолучитьИлиИзменитьПодпискуЗрителяНаКанал();
								return;
							}
						}
					}
					м_Журнал.Ой(`[Twitch] Печенька авторизации не найдена Ошибка=${chrome.runtime.lastError && chrome.runtime.lastError.message} Печенька=${пДляЖурнала}`);
					_сИдЗрителя = _сТокенЗрителя = '';
					м_События.ПослатьСобытие('twitch-полученыметаданныезрителя', {сИмя: ''});
				})
			);
		});
	}

	function ОбновитьМетаданныеТрансляции(чЧерез)
	{
		Проверить(_сИдКанала);
		м_Журнал.Вот(`[Twitch] Загрузка метаданных трансляции начнется через ${м_Журнал.F0(чЧерез)}мс`);
		Ждать(_ооОбновлениеМетаданных, чЧерез)
		.then(() =>
		{
			return м_Загрузчик.ЗагрузитьJson(_ооОбновлениеМетаданных,
				`https://api.twitch.tv/kraken/streams/${_сИдКанала}`,
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'метаданные трансляции', true, ЗАГОЛОВКИ_ЗАПРОСА
			);
		})
		.then(оРезультат =>
		{
			// Данные отсутствуют если трансляция скрыта или только началась.
			if (!ЭтоОбъект(оРезультат) || !ЭтоОбъект(оРезультат.stream))
			{
				throw 'В загруженном JSON нет метаданных';
			}
			const чТрансляцияСоздана = Date.parse(оРезультат.stream.created_at); // ISO 8601
			const чДлительностьТрансляции = performance.now() + г_чТочноеВремя - чТрансляцияСоздана;
			Проверить(
				String(оРезультат.stream.channel._id) === _сИдКанала
				&& оРезультат.stream.hasOwnProperty('_id')
				&& ЭтоНепустаяСтрока(оРезультат.stream.stream_type)
				&& Number.isFinite(оРезультат.stream.viewers)
				&& Number.isFinite(чТрансляцияСоздана)
				&& чДлительностьТрансляции > -1000
			);
			// Менять здесь: https://passport.twitch.tv/logins/new
			if (_сКодКанала !== оРезультат.stream.channel.name)
			{
				м_Журнал.Ой(`[Twitch] Изменился код канала с ${_сКодКанала} на ${оРезультат.stream.channel.name}`);
				_сКодКанала = оРезультат.stream.channel.name;
			}
			// live - прямая трансляция, rerun - повтор трансляции.
			const лЗапись = оРезультат.stream.stream_type !== 'live';
			const оМетаданные =
			{
				сНазваниеТрансляции: оРезультат.stream.channel.status || Текст('J0103'),
				сНазваниеИгры: лЗапись ? null : оРезультат.stream.game || Текст('J0104'),
				сАдресИгры: ПолучитьАдресКаталогаИгры(оРезультат.stream.game),
				кЗрителей: оРезультат.stream.viewers,
				чДлительностьТрансляции
			};
			// Теоретически возможна ситуация, когда сервер начал другую трансляцию, а старая еще не досмотрена
			// (часть находится в буфере проигрывателя). Поэтому не перезаписываем _сИдТрансляции.
			if (_сИдТрансляции === '')
			{
				м_Журнал.Окак(`[Twitch] Идентификатор трансляции: ${оРезультат.stream._id}`);
				_сИдТрансляции = String(оРезультат.stream._id);
				оМетаданные.лЗапись = лЗапись;
				оМетаданные.сАдресЗаписи = '';
				if (!лЗапись)
				{
					ПолучитьАдресЗаписиТрансляции(чДлительностьТрансляции);
				}
			}
			м_События.ПослатьСобытие('twitch-полученыметаданныетрансляции', оМетаданные);
			ОбновитьМетаданныеТрансляции(ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ);
		})
		.catch(ДобавитьОбработчикИсключений(пПричина =>
		{
			// Не удалось загрузить или разобрать файл?
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось загрузить метаданные трансляции. ${пПричина}`);
				ОбновитьМетаданныеТрансляции(ИНТЕРВАЛ_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ТРАНСЛЯЦИИ / 2);
			}
			// Загрузка отменена?
			else if (пПричина === ОтменаОбещания.ОБЕЩАНИЕ_ОТМЕНЕНО)
			{
				м_Журнал.Вот('[Twitch] Отменено обновление метаданных трансляции');
			}
			else
			{
				throw пПричина;
			}
		}));
	}

	function ПолучитьАдресЗаписиТрансляции(чДлительностьТрансляции)
	{
		Проверить(_сИдКанала && _сИдТрансляции);
		// _ооОбновлениеМетаданных использовать нельзя, потому что ОтменаОбещания может отменить только одну цепочку обещаний.
		const сИдТрансляции = _сИдТрансляции;
		// Запись доступна только через несколько минут после начала трансляции.
		const чЖдать = Math.max(ЗАДЕРЖКА_ОБНОВЛЕНИЯ_МЕТАДАННЫХ_ЗАПИСИ - чДлительностьТрансляции, 0);
		м_Журнал.Вот(`[Twitch] Получение записи трансляции начнется через ${м_Журнал.F0(чЖдать)}мс`);
		Ждать(null, чЖдать)
		.then(() =>
		{
			if (сИдТрансляции !== _сИдТрансляции)
			{
				throw 'Трансляция завершена';
			}
			// По broadcast_id фильровать не умеет.
			return м_Загрузчик.ЗагрузитьJson(null,
				`https://api.twitch.tv/kraken/channels/${_сИдКанала}/videos?broadcast_type=archive&limit=3`,
				ЗАГРУЖАТЬ_МЕТАДАННЫЕ_НЕ_ДОЛЬШЕ, 'запись трансляции', true, ЗАГОЛОВКИ_ЗАПРОСА
			);
		})
		.then(оРезультат =>
		{
			if (сИдТрансляции !== _сИдТрансляции)
			{
				throw 'Трансляция завершена';
			}
			for (let оЗапись of оРезультат.videos)
			{
				if (String(оЗапись.broadcast_id) === сИдТрансляции)
				{
					Проверить(оЗапись.broadcast_type === 'archive');
					Проверить(String(оЗапись.channel._id) === _сИдКанала);
					Проверить(ЭтоНепустаяСтрока(оЗапись.url));
					_сАдресЗаписи = оЗапись.url;
					м_События.ПослатьСобытие('twitch-полученыметаданныетрансляции',
					{
						лЗапись: false,
						сАдресЗаписи: _сАдресЗаписи
					});
					break;
				}
			}
		})
		.catch(пПричина =>
		{
			if (typeof пПричина === 'string')
			{
				м_Журнал.Ой(`[Twitch] Не удалось загрузить запись трансляции. ${пПричина}`);
			}
			// Отмены обещания в этой цепочке пока нет.
			else
			{
				м_Отладка.ПойманоИсключение(пПричина);
			}
		});
	}

	function НачатьСборМетаданныхТрансляции()
	{
		ОчиститьДанныеТрансляции();
		_ооОбновлениеМетаданных.НачалоВыполнения();
		ОбновитьМетаданныеТрансляции(0);
	}

	function ЗавершитьСборМетаданныхТрансляции(лТрансляцияЗавершена)
	{
		м_Журнал.Вот(`[Twitch] Отменяю обновление метаданных трансляции ТрансляцияЗавершена=${лТрансляцияЗавершена}`);
		// Не менять _сИдТрансляции после постановки на паузу, чтобы не прерывать работу
		// ПолучитьАдресЗаписиТрансляции(), а также чтобы была возможность создать клип.
		if (лТрансляцияЗавершена)
		{
			ОчиститьДанныеТрансляции();
		}
		_ооОбновлениеМетаданных.Отменить();
	}

	function ПолучитьАдресЗаписиДляТекущейПозиции()
	{
		const чПозиция = м_Проигрыватель.ПолучитьПозициюВоспроизведенияТрансляции(false);
		if (_сАдресЗаписи === '' || чПозиция === -1)
		{
			м_Журнал.Ой(`[Twitch] Недостаточно данных для получения адреса записи АдресЗаписи=${_сАдресЗаписи} Позиция=${чПозиция}`);
			return '';
		}
		return `${_сАдресЗаписи}?t=${Math.floor(чПозиция / 60 / 60)}h${Math.floor(чПозиция / 60 % 60)}m${Math.floor(чПозиция % 60)}s`;
	}

	function СоздатьКлип()
	{
		const чПозиция = м_Проигрыватель.ПолучитьПозициюВоспроизведенияТрансляции(true);
		if (_сТокенЗрителя === '' || _сИдТрансляции === '' || чПозиция === -1)
		{
			м_Журнал.Ой(`[Twitch] Недостаточно данных для создания клипа ИдЗрителя=${_сИдЗрителя} ИдТрансляции=${_сИдТрансляции} Позиция=${чПозиция}`);
			м_Уведомление.ПоказатьЖопу();
			return;
		}
		м_Журнал.Окак(`[Twitch] Создаю клип ИдЗрителя=${_сИдЗрителя} ИдТрансляции=${_сИдТрансляции} Позиция=${чПозиция}`);
		const оЗапрос = new XMLHttpRequest();
		оЗапрос.addEventListener('loadend', ДобавитьОбработчикИсключений(() =>
		{
			if (оЗапрос.status === 201 && ЭтоОбъект(оЗапрос.response) && ЭтоНепустаяСтрока(оЗапрос.response.edit_url))
			{
				м_Журнал.Вот(`[Twitch] Клип создан response=${м_Журнал.O(оЗапрос.response)}`);
				ОткрытьАдресВНовойВкладке(оЗапрос.response.edit_url);
			}
			else
			{
				м_Журнал.Ой(`[Twitch] Не удалось создать клип status=${оЗапрос.status} response=${м_Журнал.O(оЗапрос.response)}`);
				м_Уведомление.ПоказатьЖопу();
			}
		}));
		оЗапрос.open('POST', 'https://clips.twitch.tv/api/v2/clips');
		оЗапрос.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
		оЗапрос.setRequestHeader('Authorization', `OAuth ${_сТокенЗрителя}`);
		оЗапрос.responseType = 'json';
		оЗапрос.send(`broadcast_id=${_сИдТрансляции}&channel=${_сКодКанала}&offset=${Math.ceil(чПозиция)}&player_backend_type=mediaplayer`);
	}

	function ПолучитьАбсолютныйАдресСпискаСегментов(сАбсолютныйАдресСпискаСегментов)
	{
		return сАбсолютныйАдресСпискаСегментов;
	}

	Проверить(ЭтоНепустаяСтрока(_сКодКанала));

	return {
		ПолучитьАбсолютныйАдресСпискаВариантов, ПолучитьАбсолютныйАдресСпискаСегментов,
		ПолучитьАдресКанала, ПолучитьАдресПанелиЧата,
		НачатьСборМетаданныхТрансляции, ЗавершитьСборМетаданныхТрансляции,
		ИзменитьПодпискуЗрителяНаКанал,
		ПолучитьАдресЗаписиДляТекущейПозиции,
		СоздатьКлип
	};
}


//
// Запускалка.
//

function ЗавершитьРаботу(лБыстро)
{
	try
	{
		// После этой строки код, завернутый в ДобавитьОбработчикИсключений(), перестанет работать.
		// Если строку переместить в конец функции, то во время выполнения ЗавершитьРаботу() код
		// в catch может вызвать ЗавершитьРаботу(), что приведет к переполнению стека.
		г_лРаботаЗавершена = true;
		м_Журнал.Окак('[Запускалка] Завершаю работу');
		м_Настройки.Остановить();
		// Если разбор страницы не завершен, не вставлять оставшиеся <script>.
		// Chrome 49, 68: Синхронно прерывает выполнение всех XMLHttpRequest. Посылает событие abort.
		// Firefox 52, 61: Асинхронно прерывает выполнение всех XMLHttpRequest. Посылает событие error.
		// Edge 16: Не прерывает выполнение XMLHttpRequest.
		// HACK Firefox 61: window.stop() в обработчике unload прерывает загрузку не только текущей страницы, но
		// и части файлов следующей страницы с моим проигрывателем. В обработчике beforeunload такой проблемы нет.
		window.stop();
		if (!лБыстро)
		{
			м_Преобразователь.Остановить();
			м_Проигрыватель.Остановить();
			м_Помойка.Сжечь();
		}
		м_Журнал.Окак('[Запускалка] Работа завершена');
	}
	catch (_) {}
}

ДобавитьОбработчикИсключений(() =>
{
	function ВыделитьКанал(оАдрес)
	{
		// Канала с названием channel не существует.
		const сКанал = РазобратьПараметры(оАдрес).get('channel') || 'channel';
		// Вместо кода канала пользователь мог вставить название канала.
		return сКанал.includes(':') ? сКанал : сКанал.toLowerCase();
	}

	function ЭтотКаналУжеОткрыт(сКанал)
	// Используются сообщения вместо getViews(), потому что последняя жутко глючит в Edge:
	// Edge 15: У отключенного расширения доступна страница, но не работает getViews().
	// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12290588/
	// Edge 15: После установки расширения, getViews() не работает до перезапуска браузера.
	// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/13131564/
	// Edge 16: getViews() кидает исключение, если открыта другая вкладка расширения, которая еще не начала загружаться.
	// Edge 16: Иногда вместо окна расширения getViews() возвращает фрейм, который находится в этом окне.
	{
		Проверить(ЭтоНепустаяСтрока(сКанал));
		// HACK Edge 17: На странице расширения в режиме InPrivate не работает sendMessage().
		// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18721133/
		const чОтправитель = Math.random();
		ПолучитьApiРасширения(oApi =>
		{
			oApi.runtime.sendMessage(
				{
					сЗапрос: 'ЭтотКаналУжеОткрыт',
					чОтправитель,
					сКанал
				},
				undefined,
				пОтвет =>
				{
					// Обрабатывать исключения не нужно.
					// Firefox 60: chrome.runtime.lastError == null и пОтвет == undefined если произошла ошибка.
					if (пОтвет === true)
					{
						м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0211');
					}
				}
			);
		});
		chrome.runtime.onMessage.addListener(ДобавитьОбработчикИсключений((оСообщение, оОтправитель, фОтветить) =>
		{
			if (оСообщение.сЗапрос === 'ЭтотКаналУжеОткрыт' && оСообщение.чОтправитель !== чОтправитель)
			{
				м_Журнал.Ой(`[Запускалка] В другой вкладке открыт канал ${оСообщение.сКанал}`);
				if (оСообщение.сКанал === сКанал)
				{
					фОтветить(true);
				}
			}
		}));
	}

	function ПолучитьТекущуюВкладку()
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			chrome.tabs.getCurrent(оВкладка =>
			{
				try
				{
					Проверить(!chrome.runtime.lastError);
					Проверить(Number.isInteger(оВкладка.id) && оВкладка.id >= 0);
					г_чИдВкладки = оВкладка.id;
					фВыполнить();
				}
				catch (пИсключение)
				{
					фОтказаться(пИсключение);
				}
			});
		});
	}

	function ЖдатьЗагрузкуСтраницы()
	{
		return new Promise((фВыполнить, фОтказаться) =>
		{
			if (document.readyState === 'complete')
			{
				м_Журнал.Ой('[Запускалка] document.readyState=complete');
				фВыполнить();
			}
			else
			{
				м_Журнал.Вот(`[Запускалка] document.readyState=${document.readyState}`);
				window.addEventListener('load', function ОбработатьЗагрузкуСтраницы()
				{
					try
					{
						window.removeEventListener('load', ОбработатьЗагрузкуСтраницы);
						Проверить(document.readyState === 'complete');
						м_Журнал.Вот('[Запускалка] window.onload');
						фВыполнить();
					}
					catch (пИсключение)
					{
						фОтказаться(пИсключение);
					}
				});
			}
		});
	}

	function ОбработатьВыгрузкуСтраницы()
	{
		м_Журнал.Окак('[Запускалка] window.onbeforeunload');
		ЗавершитьРаботу(true);
	}

	function НачатьРаботу()
	{
		Проверить(!г_лРаботаЗавершена);
		м_Журнал.Вот(`[Запускалка] Начало работы ${performance.now().toFixed()}мс`);
		window.addEventListener('beforeunload', ОбработатьВыгрузкуСтраницы);
		м_Управление.Запустить();
		if (м_Проигрыватель.Запустить())
		{
			м_Список.Запустить();
		}
		else
		{
			м_Управление.ОстановитьПросмотрТрансляции();
		}
		м_Статистика.Запустить();
	}

	// Edge 15 не дает запускать проигрыватель во фрейме на обычном сайте.
	if (window.top !== window)
	{
		return;
	}

	// Firefox 56+ перестал запускать расширение в родительском процессе.
	// https://bugzilla.mozilla.org/show_bug.cgi?id=1389821
	if (!navigator.userAgent.includes('Gecko/') || ВЕРСИЯ_ДВИЖКА_БРАУЗЕРА === 55)
	{
		м_Отладка.ЗавершитьРаботуИПоказатьСообщение('J0204');
	}

	const сКанал = ВыделитьКанал(window.location);
	м_Журнал.Вот(`[Запускалка] Канал ${сКанал}`);
	ЭтотКаналУжеОткрыт(сКанал);
	м_Twitch = Twitch(сКанал);

	Promise.all(
	[
		м_Настройки.Восстановить(),
		м_Оформление.ЗапуститьАсинхронно(),
		ПолучитьТекущуюВкладку(),
		// Ждем загрузку остальных <script>.
		ЖдатьЗагрузкуСтраницы()
	])
	.then(НачатьРаботу)
	.catch(м_Отладка.ПойманоИсключение);

	м_i18n.TranslateDocument(document);
})();
